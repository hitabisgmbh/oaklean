{
  "sourceCodeMap": {
    "15": "/* eslint jsdoc/require-jsdoc: \"error\" */\n\n'use strict';\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberMAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER,\n  NumberParseInt,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeExec,\n  String,\n  StringPrototypeToUpperCase,\n  StringPrototypeTrim,\n} = primordials;\n\nconst {\n  hideStackFrames,\n  codes: {\n    ERR_SOCKET_BAD_PORT,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_OUT_OF_RANGE,\n    ERR_UNKNOWN_SIGNAL,\n  },\n} = require('internal/errors');\nconst { normalizeEncoding } = require('internal/util');\nconst {\n  isAsyncFunction,\n  isArrayBufferView,\n} = require('internal/util/types');\nconst { signals } = internalBinding('constants').os;\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isInt32(value) {\n  return value === (value | 0);\n}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isUint32(value) {\n  return value === (value >>> 0);\n}\n\nconst octalReg = /^[0-7]+$/;\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string';\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land, but any value higher than 0o777 will result in platform-specific\n * behaviors.\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified, will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value, name, def) {\n  value ??= def;\n  if (typeof value === 'string') {\n    if (RegExpPrototypeExec(octalReg, value) === null) {\n      throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);\n    }\n    value = NumberParseInt(value, 8);\n  }\n\n  validateUint32(value, name);\n  return value;\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInteger} */\nconst validateInteger = hideStackFrames(\n  (value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n    if (typeof value !== 'number')\n      throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n    if (!NumberIsInteger(value))\n      throw new ERR_OUT_OF_RANGE(name, 'an integer', value);\n    if (value < min || value > max)\n      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n  },\n);\n\n/**\n * @callback validateInt32\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInt32} */\nconst validateInt32 = hideStackFrames(\n  (value, name, min = -2147483648, max = 2147483647) => {\n    // The defaults for min and max correspond to the limits of 32-bit integers.\n    if (typeof value !== 'number') {\n      throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n    }\n    if (!NumberIsInteger(value)) {\n      throw new ERR_OUT_OF_RANGE(name, 'an integer', value);\n    }\n    if (value < min || value > max) {\n      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n    }\n  },\n);\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\n\n/** @type {validateUint32} */\nconst validateUint32 = hideStackFrames((value, name, positive = false) => {\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, 'an integer', value);\n  }\n  const min = positive ? 1 : 0;\n  // 2 ** 32 === 4294967296\n  const max = 4_294_967_295;\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n  }\n});\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== 'string')\n    throw new ERR_INVALID_ARG_TYPE(name, 'string', value);\n}\n\n/**\n * @callback validateNumber\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateNumber} */\nfunction validateNumber(value, name, min = undefined, max) {\n  if (typeof value !== 'number')\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n\n  if ((min != null && value < min) || (max != null && value > max) ||\n    ((min != null || max != null) && NumberIsNaN(value))) {\n    throw new ERR_OUT_OF_RANGE(\n      name,\n      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`,\n      value);\n  }\n}\n\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */\n\n/** @type {validateOneOf} */\nconst validateOneOf = hideStackFrames((value, name, oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf, value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf, (v) =>\n        (typeof v === 'string' ? `'${v}'` : String(v))),\n      ', ');\n    const reason = 'must be one of: ' + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n});\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\n\n/** @type {validateBoolean} */\nfunction validateBoolean(value, name) {\n  if (typeof value !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value);\n}\n\nconst kValidateObjectNone = 0;\nconst kValidateObjectAllowNullable = 1 << 0;\nconst kValidateObjectAllowArray = 1 << 1;\nconst kValidateObjectAllowFunction = 1 << 2;\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {number} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = hideStackFrames(\n  (value, name, options = kValidateObjectNone) => {\n    if (options === kValidateObjectNone) {\n      if (value === null || ArrayIsArray(value)) {\n        throw new ERR_INVALID_ARG_TYPE(name, 'Object', value);\n      }\n\n      if (typeof value !== 'object') {\n        throw new ERR_INVALID_ARG_TYPE(name, 'Object', value);\n      }\n    } else {\n      const throwOnNullable = (kValidateObjectAllowNullable & options) === 0;\n\n      if (throwOnNullable && value === null) {\n        throw new ERR_INVALID_ARG_TYPE(name, 'Object', value);\n      }\n\n      const throwOnArray = (kValidateObjectAllowArray & options) === 0;\n\n      if (throwOnArray && ArrayIsArray(value)) {\n        throw new ERR_INVALID_ARG_TYPE(name, 'Object', value);\n      }\n\n      const throwOnFunction = (kValidateObjectAllowFunction & options) === 0;\n      const typeofValue = typeof value;\n\n      if (typeofValue !== 'object' && (throwOnFunction || typeofValue !== 'function')) {\n        throw new ERR_INVALID_ARG_TYPE(name, 'Object', value);\n      }\n    }\n  });\n\n/**\n * @callback validateDictionary - We are using the Web IDL Standard definition\n *                                of \"dictionary\" here, which means any value\n *                                whose Type is either Undefined, Null, or\n *                                Object (which includes functions).\n * @param {*} value\n * @param {string} name\n * @see https://webidl.spec.whatwg.org/#es-dictionary\n * @see https://tc39.es/ecma262/#table-typeof-operator-results\n */\n\n/** @type {validateDictionary} */\nconst validateDictionary = hideStackFrames(\n  (value, name) => {\n    if (value != null && typeof value !== 'object' && typeof value !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(name, 'a dictionary', value);\n    }\n  });\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\n\n/** @type {validateArray} */\nconst validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Array', value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n});\n\n/**\n * @callback validateStringArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string[]}\n */\n\n/** @type {validateStringArray} */\nfunction validateStringArray(value, name) {\n  validateArray(value, name);\n  for (let i = 0; i < value.length; ++i) {\n    // Don't use validateString here for performance reasons, as\n    // we would generate intermediate strings for the name.\n    if (typeof value[i] !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE(`${name}[${i}]`, 'string', value[i]);\n    }\n  }\n}\n\n/**\n * @callback validateBooleanArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean[]}\n */\n\n/** @type {validateBooleanArray} */\nfunction validateBooleanArray(value, name) {\n  validateArray(value, name);\n  for (let i = 0; i < value.length; ++i) {\n    // Don't use validateBoolean here for performance reasons, as\n    // we would generate intermediate strings for the name.\n    if (value[i] !== true && value[i] !== false) {\n      throw new ERR_INVALID_ARG_TYPE(`${name}[${i}]`, 'boolean', value[i]);\n    }\n  }\n}\n\n/**\n * @callback validateAbortSignalArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is AbortSignal[]}\n */\n\n/** @type {validateAbortSignalArray} */\nfunction validateAbortSignalArray(value, name) {\n  validateArray(value, name);\n  for (let i = 0; i < value.length; i++) {\n    const signal = value[i];\n    const indexedName = `${name}[${i}]`;\n    if (signal == null) {\n      throw new ERR_INVALID_ARG_TYPE(indexedName, 'AbortSignal', signal);\n    }\n    validateAbortSignal(signal, indexedName);\n  }\n}\n\n/**\n * @param {*} signal\n * @param {string} [name='signal']\n * @returns {asserts signal is keyof signals}\n */\nfunction validateSignalName(signal, name = 'signal') {\n  validateString(signal, name);\n\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal +\n                                   ' (signals must use all capital letters)');\n    }\n\n    throw new ERR_UNKNOWN_SIGNAL(signal);\n  }\n}\n\n/**\n * @callback validateBuffer\n * @param {*} buffer\n * @param {string} [name='buffer']\n * @returns {asserts buffer is ArrayBufferView}\n */\n\n/** @type {validateBuffer} */\nconst validateBuffer = hideStackFrames((buffer, name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name,\n                                   ['Buffer', 'TypedArray', 'DataView'],\n                                   buffer);\n  }\n});\n\n/**\n * @param {string} data\n * @param {string} encoding\n */\nfunction validateEncoding(data, encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding);\n  const length = data.length;\n\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding', encoding,\n                                    `is invalid for data of length ${length}`);\n  }\n}\n\n/**\n * Check that the port number is not NaN when coerced to a number,\n * is an integer and that it falls within the legal range of port numbers.\n * @param {*} port\n * @param {string} [name='Port']\n * @param {boolean} [allowZero=true]\n * @returns {number}\n */\nfunction validatePort(port, name = 'Port', allowZero = true) {\n  if ((typeof port !== 'number' && typeof port !== 'string') ||\n      (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n      +port !== (+port >>> 0) ||\n      port > 0xFFFF ||\n      (port === 0 && !allowZero)) {\n    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);\n  }\n  return port | 0;\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\n\n/** @type {validateAbortSignal} */\nconst validateAbortSignal = hideStackFrames((signal, name) => {\n  if (signal !== undefined &&\n      (signal === null ||\n       typeof signal !== 'object' ||\n       !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal);\n  }\n});\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validateFunction} */\nconst validateFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function')\n    throw new ERR_INVALID_ARG_TYPE(name, 'Function', value);\n});\n\n/**\n * @callback validatePlainFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validatePlainFunction} */\nconst validatePlainFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function' || isAsyncFunction(value))\n    throw new ERR_INVALID_ARG_TYPE(name, 'Function', value);\n});\n\n/**\n * @callback validateUndefined\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is undefined}\n */\n\n/** @type {validateUndefined} */\nconst validateUndefined = hideStackFrames((value, name) => {\n  if (value !== undefined)\n    throw new ERR_INVALID_ARG_TYPE(name, 'undefined', value);\n});\n\n/**\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} union\n */\nfunction validateUnion(value, name, union) {\n  if (!ArrayPrototypeIncludes(union, value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, '|')}')`, value);\n  }\n}\n\n/*\n  The rules for the Link header field are described here:\n  https://www.rfc-editor.org/rfc/rfc8288.html#section-3\n\n  This regex validates any string surrounded by angle brackets\n  (not necessarily a valid URI reference) followed by zero or more\n  link-params separated by semicolons.\n*/\nconst linkValueRegExp = /^(?:<[^>]*>)(?:\\s*;\\s*[^;\"\\s]+(?:=(\")?[^;\"\\s]*\\1)?)*$/;\n\n/**\n * @param {any} value\n * @param {string} name\n */\nfunction validateLinkHeaderFormat(value, name) {\n  if (\n    typeof value === 'undefined' ||\n    !RegExpPrototypeExec(linkValueRegExp, value)\n  ) {\n    throw new ERR_INVALID_ARG_VALUE(\n      name,\n      value,\n      'must be an array or string of format \"</styles.css>; rel=preload; as=style\"',\n    );\n  }\n}\n\nconst validateInternalField = hideStackFrames((object, fieldKey, className) => {\n  if (typeof object !== 'object' || object === null || !ObjectPrototypeHasOwnProperty(object, fieldKey)) {\n    throw new ERR_INVALID_ARG_TYPE('this', className, object);\n  }\n});\n\n/**\n * @param {any} hints\n * @return {string}\n */\nfunction validateLinkHeaderValue(hints) {\n  if (typeof hints === 'string') {\n    validateLinkHeaderFormat(hints, 'hints');\n    return hints;\n  } else if (ArrayIsArray(hints)) {\n    const hintsLength = hints.length;\n    let result = '';\n\n    if (hintsLength === 0) {\n      return result;\n    }\n\n    for (let i = 0; i < hintsLength; i++) {\n      const link = hints[i];\n      validateLinkHeaderFormat(link, 'hints');\n      result += link;\n\n      if (i !== hintsLength - 1) {\n        result += ', ';\n      }\n    }\n\n    return result;\n  }\n\n  throw new ERR_INVALID_ARG_VALUE(\n    'hints',\n    hints,\n    'must be an array or string of format \"</styles.css>; rel=preload; as=style\"',\n  );\n}\n\nmodule.exports = {\n  isInt32,\n  isUint32,\n  parseFileMode,\n  validateArray,\n  validateStringArray,\n  validateBooleanArray,\n  validateAbortSignalArray,\n  validateBoolean,\n  validateBuffer,\n  validateDictionary,\n  validateEncoding,\n  validateFunction,\n  validateInt32,\n  validateInteger,\n  validateNumber,\n  validateObject,\n  kValidateObjectNone,\n  kValidateObjectAllowNullable,\n  kValidateObjectAllowArray,\n  kValidateObjectAllowFunction,\n  validateOneOf,\n  validatePlainFunction,\n  validatePort,\n  validateSignalName,\n  validateString,\n  validateUint32,\n  validateUndefined,\n  validateUnion,\n  validateAbortSignal,\n  validateLinkHeaderValue,\n  validateInternalField,\n};\n",
    "23": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeJoin,\n  ArrayPrototypePop,\n  ArrayPrototypePush,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSplice,\n  ArrayPrototypeUnshift,\n  Boolean,\n  Error,\n  ErrorCaptureStackTrace,\n  FunctionPrototypeBind,\n  FunctionPrototypeCall,\n  NumberMAX_SAFE_INTEGER,\n  ObjectDefineProperty,\n  ObjectDefineProperties,\n  ObjectGetPrototypeOf,\n  ObjectSetPrototypeOf,\n  Promise,\n  PromiseReject,\n  PromiseResolve,\n  ReflectApply,\n  ReflectOwnKeys,\n  String,\n  StringPrototypeSplit,\n  Symbol,\n  SymbolFor,\n  SymbolAsyncIterator,\n  SymbolDispose,\n} = primordials;\nconst kRejection = SymbolFor('nodejs.rejection');\n\nconst { kEmptyObject } = require('internal/util');\n\nconst {\n  inspect,\n  identicalSequenceRange,\n} = require('internal/util/inspect');\n\nlet spliceOne;\nlet FixedQueue;\nlet kFirstEventParam;\nlet kResistStopPropagation;\n\nconst {\n  AbortError,\n  kEnhanceStackBeforeInspector,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_THIS,\n    ERR_UNHANDLED_ERROR,\n  },\n  genericNodeError,\n} = require('internal/errors');\n\nconst {\n  validateInteger,\n  validateAbortSignal,\n  validateBoolean,\n  validateFunction,\n  validateNumber,\n  validateString,\n} = require('internal/validators');\n\nconst kCapture = Symbol('kCapture');\nconst kErrorMonitor = Symbol('events.errorMonitor');\nconst kShapeMode = Symbol('shapeMode');\nconst kMaxEventTargetListeners = Symbol('events.maxEventTargetListeners');\nconst kMaxEventTargetListenersWarned =\n  Symbol('events.maxEventTargetListenersWarned');\nconst kWatermarkData = SymbolFor('nodejs.watermarkData');\n\nlet EventEmitterAsyncResource;\n// The EventEmitterAsyncResource has to be initialized lazily because event.js\n// is loaded so early in the bootstrap process, before async_hooks is available.\n//\n// This implementation was adapted straight from addaleax's\n// eventemitter-asyncresource MIT-licensed userland module.\n// https://github.com/addaleax/eventemitter-asyncresource\nfunction lazyEventEmitterAsyncResource() {\n  if (EventEmitterAsyncResource === undefined) {\n    const {\n      AsyncResource,\n    } = require('async_hooks');\n\n    const kEventEmitter = Symbol('kEventEmitter');\n    const kAsyncResource = Symbol('kAsyncResource');\n    class EventEmitterReferencingAsyncResource extends AsyncResource {\n      /**\n       * @param {EventEmitter} ee\n       * @param {string} [type]\n       * @param {{\n       *   triggerAsyncId?: number,\n       *   requireManualDestroy?: boolean,\n       * }} [options]\n       */\n      constructor(ee, type, options) {\n        super(type, options);\n        this[kEventEmitter] = ee;\n      }\n\n      /**\n       * @type {EventEmitter}\n       */\n      get eventEmitter() {\n        if (this[kEventEmitter] === undefined)\n          throw new ERR_INVALID_THIS('EventEmitterReferencingAsyncResource');\n        return this[kEventEmitter];\n      }\n    }\n\n    EventEmitterAsyncResource =\n      class EventEmitterAsyncResource extends EventEmitter {\n        /**\n         * @param {{\n         *   name?: string,\n         *   triggerAsyncId?: number,\n         *   requireManualDestroy?: boolean,\n         * }} [options]\n         */\n        constructor(options = undefined) {\n          let name;\n          if (typeof options === 'string') {\n            name = options;\n            options = undefined;\n          } else {\n            if (new.target === EventEmitterAsyncResource) {\n              validateString(options?.name, 'options.name');\n            }\n            name = options?.name || new.target.name;\n          }\n          super(options);\n\n          this[kAsyncResource] =\n            new EventEmitterReferencingAsyncResource(this, name, options);\n        }\n\n        /**\n         * @param {symbol,string} event\n         * @param  {...any} args\n         * @returns {boolean}\n         */\n        emit(event, ...args) {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          const { asyncResource } = this;\n          ArrayPrototypeUnshift(args, super.emit, this, event);\n          return ReflectApply(asyncResource.runInAsyncScope, asyncResource,\n                              args);\n        }\n\n        /**\n         * @returns {void}\n         */\n        emitDestroy() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          this.asyncResource.emitDestroy();\n        }\n\n        /**\n         * @type {number}\n         */\n        get asyncId() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this.asyncResource.asyncId();\n        }\n\n        /**\n         * @type {number}\n         */\n        get triggerAsyncId() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this.asyncResource.triggerAsyncId();\n        }\n\n        /**\n         * @type {EventEmitterReferencingAsyncResource}\n         */\n        get asyncResource() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this[kAsyncResource];\n        }\n      };\n  }\n  return EventEmitterAsyncResource;\n}\n\n/**\n * Creates a new `EventEmitter` instance.\n * @param {{ captureRejections?: boolean; }} [opts]\n * @constructs {EventEmitter}\n */\nfunction EventEmitter(opts) {\n  EventEmitter.init.call(this, opts);\n}\nmodule.exports = EventEmitter;\nmodule.exports.addAbortListener = addAbortListener;\nmodule.exports.once = once;\nmodule.exports.on = on;\nmodule.exports.getEventListeners = getEventListeners;\nmodule.exports.getMaxListeners = getMaxListeners;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.captureRejectionSymbol = kRejection;\nObjectDefineProperty(EventEmitter, 'captureRejections', {\n  __proto__: null,\n  get() {\n    return EventEmitter.prototype[kCapture];\n  },\n  set(value) {\n    validateBoolean(value, 'EventEmitter.captureRejections');\n\n    EventEmitter.prototype[kCapture] = value;\n  },\n  enumerable: true,\n});\n\nObjectDefineProperty(EventEmitter, 'EventEmitterAsyncResource', {\n  __proto__: null,\n  enumerable: true,\n  get: lazyEventEmitterAsyncResource,\n  set: undefined,\n  configurable: true,\n});\n\nEventEmitter.errorMonitor = kErrorMonitor;\n\n// The default for captureRejections is false\nObjectDefineProperty(EventEmitter.prototype, kCapture, {\n  __proto__: null,\n  value: false,\n  writable: true,\n  enumerable: false,\n});\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nlet defaultMaxListeners = 10;\nlet isEventTarget;\n\nfunction checkListener(listener) {\n  validateFunction(listener, 'listener');\n}\n\nObjectDefineProperty(EventEmitter, 'defaultMaxListeners', {\n  __proto__: null,\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    validateNumber(arg, 'defaultMaxListeners', 0);\n    defaultMaxListeners = arg;\n  },\n});\n\nObjectDefineProperties(EventEmitter, {\n  kMaxEventTargetListeners: {\n    __proto__: null,\n    value: kMaxEventTargetListeners,\n    enumerable: false,\n    configurable: false,\n    writable: false,\n  },\n  kMaxEventTargetListenersWarned: {\n    __proto__: null,\n    value: kMaxEventTargetListenersWarned,\n    enumerable: false,\n    configurable: false,\n    writable: false,\n  },\n});\n\n/**\n * Sets the max listeners.\n * @param {number} n\n * @param {EventTarget[] | EventEmitter[]} [eventTargets]\n * @returns {void}\n */\nEventEmitter.setMaxListeners =\n  function(n = defaultMaxListeners, ...eventTargets) {\n    validateNumber(n, 'setMaxListeners', 0);\n    if (eventTargets.length === 0) {\n      defaultMaxListeners = n;\n    } else {\n      if (isEventTarget === undefined)\n        isEventTarget = require('internal/event_target').isEventTarget;\n\n      for (let i = 0; i < eventTargets.length; i++) {\n        const target = eventTargets[i];\n        if (isEventTarget(target)) {\n          target[kMaxEventTargetListeners] = n;\n          target[kMaxEventTargetListenersWarned] = false;\n        } else if (typeof target.setMaxListeners === 'function') {\n          target.setMaxListeners(n);\n        } else {\n          throw new ERR_INVALID_ARG_TYPE(\n            'eventTargets',\n            ['EventEmitter', 'EventTarget'],\n            target);\n        }\n      }\n    }\n  };\n\n// If you're updating this function definition, please also update any\n// re-definitions, such as the one in the Domain module (lib/domain.js).\nEventEmitter.init = function(opts) {\n\n  if (this._events === undefined ||\n      this._events === ObjectGetPrototypeOf(this)._events) {\n    this._events = { __proto__: null };\n    this._eventsCount = 0;\n    this[kShapeMode] = false;\n  } else {\n    this[kShapeMode] = true;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n\n\n  if (opts?.captureRejections) {\n    validateBoolean(opts.captureRejections, 'options.captureRejections');\n    this[kCapture] = Boolean(opts.captureRejections);\n  } else {\n    // Assigning the kCapture property directly saves an expensive\n    // prototype lookup in a very sensitive hot path.\n    this[kCapture] = EventEmitter.prototype[kCapture];\n  }\n};\n\nfunction addCatch(that, promise, type, args) {\n  if (!that[kCapture]) {\n    return;\n  }\n\n  // Handle Promises/A+ spec, then could be a getter\n  // that throws on second use.\n  try {\n    const then = promise.then;\n\n    if (typeof then === 'function') {\n      then.call(promise, undefined, function(err) {\n        // The callback is called with nextTick to avoid a follow-up\n        // rejection from this promise.\n        process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args);\n      });\n    }\n  } catch (err) {\n    that.emit('error', err);\n  }\n}\n\nfunction emitUnhandledRejectionOrErr(ee, err, type, args) {\n  if (typeof ee[kRejection] === 'function') {\n    ee[kRejection](err, type, ...args);\n  } else {\n    // We have to disable the capture rejections mechanism, otherwise\n    // we might end up in an infinite loop.\n    const prev = ee[kCapture];\n\n    // If the error handler throws, it is not catchable and it\n    // will end up in 'uncaughtException'. We restore the previous\n    // value of kCapture in case the uncaughtException is present\n    // and the exception is handled.\n    try {\n      ee[kCapture] = false;\n      ee.emit('error', err);\n    } finally {\n      ee[kCapture] = prev;\n    }\n  }\n}\n\n/**\n * Increases the max listeners of the event emitter.\n * @param {number} n\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  validateNumber(n, 'setMaxListeners', 0);\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\n/**\n * Returns the current max listener value for the event emitter.\n * @returns {number}\n */\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nfunction enhanceStackTrace(err, own) {\n  let ctorInfo = '';\n  try {\n    const { name } = this.constructor;\n    if (name !== 'EventEmitter')\n      ctorInfo = ` on ${name} instance`;\n  } catch {\n    // Continue regardless of error.\n  }\n  const sep = `\\nEmitted 'error' event${ctorInfo} at:\\n`;\n\n  const errStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(err.stack, '\\n'), 1);\n  const ownStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(own.stack, '\\n'), 1);\n\n  const { len, offset } = identicalSequenceRange(ownStack, errStack);\n  if (len > 0) {\n    ArrayPrototypeSplice(ownStack, offset + 1, len - 2,\n                         '    [... lines matching original stack trace ...]');\n  }\n\n  return err.stack + sep + ArrayPrototypeJoin(ownStack, '\\n');\n}\n\n/**\n * Synchronously calls each of the listeners registered\n * for the event.\n * @param {string | symbol} type\n * @param {...any} [args]\n * @returns {boolean}\n */\nEventEmitter.prototype.emit = function emit(type, ...args) {\n  let doError = (type === 'error');\n\n  const events = this._events;\n  if (events !== undefined) {\n    if (doError && events[kErrorMonitor] !== undefined)\n      this.emit(kErrorMonitor, ...args);\n    doError = (doError && events.error === undefined);\n  } else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    let er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      try {\n        const capture = {};\n        ErrorCaptureStackTrace(capture, EventEmitter.prototype.emit);\n        ObjectDefineProperty(er, kEnhanceStackBeforeInspector, {\n          __proto__: null,\n          value: FunctionPrototypeBind(enhanceStackTrace, this, er, capture),\n          configurable: true,\n        });\n      } catch {\n        // Continue regardless of error.\n      }\n\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n\n    let stringifiedEr;\n    try {\n      stringifiedEr = inspect(er);\n    } catch {\n      stringifiedEr = er;\n    }\n\n    // At least give some kind of context to the user\n    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  const handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    const result = handler.apply(this, args);\n\n    // We check if result is undefined first because that\n    // is the most common case so we do not pay any perf\n    // penalty\n    if (result !== undefined && result !== null) {\n      addCatch(this, result, type, args);\n    }\n  } else {\n    const len = handler.length;\n    const listeners = arrayClone(handler);\n    for (let i = 0; i < len; ++i) {\n      const result = listeners[i].apply(this, args);\n\n      // We check if result is undefined first because that\n      // is the most common case so we do not pay any perf\n      // penalty.\n      // This code is duplicated because extracting it away\n      // would make it non-inlineable.\n      if (result !== undefined && result !== null) {\n        addCatch(this, result, type, args);\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  let m;\n  let events;\n  let existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = { __proto__: null };\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ?? listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      const w = genericNodeError(\n        `Possible EventEmitter memory leak detected. ${existing.length} ${String(type)} listeners ` +\n        `added to ${inspect(target, { depth: -1 })}. Use emitter.setMaxListeners() to increase limit`,\n        { name: 'MaxListenersExceededWarning', emitter: target, type: type, count: existing.length });\n      process.emitWarning(w);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Adds a listener to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n/**\n * Adds the `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  const state = { fired: false, wrapFn: undefined, target, type, listener };\n  const wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\n/**\n * Adds a one-time `listener` function to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n/**\n * Adds a one-time `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n/**\n * Removes the specified `listener` from the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      checkListener(listener);\n\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      const list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        this._eventsCount -= 1;\n\n        if (this[kShapeMode]) {\n          events[type] = undefined;\n        } else if (this._eventsCount === 0) {\n          this._events = { __proto__: null };\n        } else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        let position = -1;\n\n        for (let i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          if (spliceOne === undefined)\n            spliceOne = require('internal/util').spliceOne;\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n/**\n * Removes all listeners from the event emitter. (Only\n * removes listeners for a specific event name if specified\n * as `type`).\n * @param {string | symbol} [type]\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      // Not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = { __proto__: null };\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = { __proto__: null };\n          else\n            delete events[type];\n        }\n        this[kShapeMode] = false;\n        return this;\n      }\n\n      // Emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        for (const key of ReflectOwnKeys(events)) {\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = { __proto__: null };\n        this._eventsCount = 0;\n        this[kShapeMode] = false;\n        return this;\n      }\n\n      const listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  const events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  const evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener);\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\n/**\n * Returns a copy of the array of listeners and wrappers for\n * the event name specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\n/**\n * Returns the number of listeners listening to the event name\n * specified as `type`.\n * @deprecated since v3.2.0\n * @param {EventEmitter} emitter\n * @param {string | symbol} type\n * @returns {number}\n */\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  }\n  return FunctionPrototypeCall(listenerCount, emitter, type);\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\n/**\n * Returns the number of listeners listening to event name\n * specified as `type`.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {number}\n */\nfunction listenerCount(type, listener) {\n  const events = this._events;\n\n  if (events !== undefined) {\n    const evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      if (listener != null) {\n        return listener === evlistener || listener === evlistener.listener ? 1 : 0;\n      }\n\n      return 1;\n    } else if (evlistener !== undefined) {\n      if (listener != null) {\n        let matching = 0;\n\n        for (let i = 0, l = evlistener.length; i < l; i++) {\n          if (evlistener[i] === listener || evlistener[i].listener === listener) {\n            matching++;\n          }\n        }\n\n        return matching;\n      }\n\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Returns an array listing the events for which\n * the emitter has registered listeners.\n * @returns {any[]}\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr) {\n  // At least since V8 8.3, this implementation is faster than the previous\n  // which always used a simple for-loop\n  switch (arr.length) {\n    case 2: return [arr[0], arr[1]];\n    case 3: return [arr[0], arr[1], arr[2]];\n    case 4: return [arr[0], arr[1], arr[2], arr[3]];\n    case 5: return [arr[0], arr[1], arr[2], arr[3], arr[4]];\n    case 6: return [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]];\n  }\n  return ArrayPrototypeSlice(arr);\n}\n\nfunction unwrapListeners(arr) {\n  const ret = arrayClone(arr);\n  for (let i = 0; i < ret.length; ++i) {\n    const orig = ret[i].listener;\n    if (typeof orig === 'function')\n      ret[i] = orig;\n  }\n  return ret;\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {EventEmitter | EventTarget} emitterOrTarget\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nfunction getEventListeners(emitterOrTarget, type) {\n  // First check if EventEmitter\n  if (typeof emitterOrTarget.listeners === 'function') {\n    return emitterOrTarget.listeners(type);\n  }\n  // Require event target lazily to avoid always loading it\n  const { isEventTarget, kEvents } = require('internal/event_target');\n  if (isEventTarget(emitterOrTarget)) {\n    const root = emitterOrTarget[kEvents].get(type);\n    const listeners = [];\n    let handler = root?.next;\n    while (handler?.listener !== undefined) {\n      const listener = handler.listener?.deref ?\n        handler.listener.deref() : handler.listener;\n      listeners.push(listener);\n      handler = handler.next;\n    }\n    return listeners;\n  }\n  throw new ERR_INVALID_ARG_TYPE('emitter',\n                                 ['EventEmitter', 'EventTarget'],\n                                 emitterOrTarget);\n}\n\n/**\n * Returns the max listeners set.\n * @param {EventEmitter | EventTarget} emitterOrTarget\n * @returns {number}\n */\nfunction getMaxListeners(emitterOrTarget) {\n  if (typeof emitterOrTarget?.getMaxListeners === 'function') {\n    return _getMaxListeners(emitterOrTarget);\n  } else if (emitterOrTarget?.[kMaxEventTargetListeners]) {\n    return emitterOrTarget[kMaxEventTargetListeners];\n  }\n\n  throw new ERR_INVALID_ARG_TYPE('emitter',\n                                 ['EventEmitter', 'EventTarget'],\n                                 emitterOrTarget);\n}\n\n/**\n * Creates a `Promise` that is fulfilled when the emitter\n * emits the given event.\n * @param {EventEmitter} emitter\n * @param {string} name\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {Promise}\n */\nasync function once(emitter, name, options = kEmptyObject) {\n  const signal = options?.signal;\n  validateAbortSignal(signal, 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError(undefined, { cause: signal?.reason });\n  return new Promise((resolve, reject) => {\n    const errorListener = (err) => {\n      emitter.removeListener(name, resolver);\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal, 'abort', abortListener);\n      }\n      reject(err);\n    };\n    const resolver = (...args) => {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal, 'abort', abortListener);\n      }\n      resolve(args);\n    };\n\n    kResistStopPropagation ??= require('internal/event_target').kResistStopPropagation;\n    const opts = { __proto__: null, once: true, [kResistStopPropagation]: true };\n    eventTargetAgnosticAddListener(emitter, name, resolver, opts);\n    if (name !== 'error' && typeof emitter.once === 'function') {\n      // EventTarget does not have `error` event semantics like Node\n      // EventEmitters, we listen to `error` events only on EventEmitters.\n      emitter.once('error', errorListener);\n    }\n    function abortListener() {\n      eventTargetAgnosticRemoveListener(emitter, name, resolver);\n      eventTargetAgnosticRemoveListener(emitter, 'error', errorListener);\n      reject(new AbortError(undefined, { cause: signal?.reason }));\n    }\n    if (signal != null) {\n      eventTargetAgnosticAddListener(\n        signal, 'abort', abortListener, { __proto__: null, once: true, [kResistStopPropagation]: true });\n    }\n  });\n}\n\nconst AsyncIteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf(async function* () {}).prototype);\n\nfunction createIterResult(value, done) {\n  return { value, done };\n}\n\nfunction eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {\n  if (typeof emitter.removeListener === 'function') {\n    emitter.removeListener(name, listener);\n  } else if (typeof emitter.removeEventListener === 'function') {\n    emitter.removeEventListener(name, listener, flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter', 'EventEmitter', emitter);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags?.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    emitter.addEventListener(name, listener, flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter', 'EventEmitter', emitter);\n  }\n}\n\n/**\n * Returns an `AsyncIterator` that iterates `event` events.\n * @param {EventEmitter} emitter\n * @param {string | symbol} event\n * @param {{\n *    signal: AbortSignal;\n *    close?: string[];\n *    highWatermark?: number,\n *    lowWatermark?: number\n *   }} [options]\n * @returns {AsyncIterator}\n */\nfunction on(emitter, event, options = kEmptyObject) {\n  // Parameters validation\n  const signal = options.signal;\n  validateAbortSignal(signal, 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError(undefined, { cause: signal?.reason });\n  const highWatermark = options.highWatermark ?? NumberMAX_SAFE_INTEGER;\n  validateInteger(highWatermark, 'options.highWatermark', 1);\n  const lowWatermark = options.lowWatermark ?? 1;\n  validateInteger(lowWatermark, 'options.lowWatermark', 1);\n\n  // Preparing controlling queues and variables\n  FixedQueue ??= require('internal/fixed_queue');\n  const unconsumedEvents = new FixedQueue();\n  const unconsumedPromises = new FixedQueue();\n  let paused = false;\n  let error = null;\n  let finished = false;\n  let size = 0;\n\n  const iterator = ObjectSetPrototypeOf({\n    next() {\n      // First, we consume all unread events\n      if (size) {\n        const value = unconsumedEvents.shift();\n        size--;\n        if (paused && size < lowWatermark) {\n          emitter.resume();\n          paused = false;\n        }\n        return PromiseResolve(createIterResult(value, false));\n      }\n\n      // Then we error, if an error happened\n      // This happens one time if at all, because after 'error'\n      // we stop listening\n      if (error) {\n        const p = PromiseReject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n\n      // If the iterator is finished, resolve to done\n      if (finished) return closeHandler();\n\n      // Wait until an event happens\n      return new Promise(function(resolve, reject) {\n        unconsumedPromises.push({ resolve, reject });\n      });\n    },\n\n    return() {\n      return closeHandler();\n    },\n\n    throw(err) {\n      if (!err || !(err instanceof Error)) {\n        throw new ERR_INVALID_ARG_TYPE('EventEmitter.AsyncIterator',\n                                       'Error', err);\n      }\n      errorHandler(err);\n    },\n    [SymbolAsyncIterator]() {\n      return this;\n    },\n    [kWatermarkData]: {\n      /**\n       * The current queue size\n       */\n      get size() {\n        return size;\n      },\n      /**\n       * The low watermark. The emitter is resumed every time size is lower than it\n       */\n      get low() {\n        return lowWatermark;\n      },\n      /**\n       * The high watermark. The emitter is paused every time size is higher than it\n       */\n      get high() {\n        return highWatermark;\n      },\n      /**\n       * It checks whether the emitter is paused by the watermark controller or not\n       */\n      get isPaused() {\n        return paused;\n      },\n    },\n  }, AsyncIteratorPrototype);\n\n  // Adding event handlers\n  const { addEventListener, removeAll } = listenersController();\n  kFirstEventParam ??= require('internal/events/symbols').kFirstEventParam;\n  addEventListener(emitter, event, options[kFirstEventParam] ? eventHandler : function(...args) {\n    return eventHandler(args);\n  });\n  if (event !== 'error' && typeof emitter.on === 'function') {\n    addEventListener(emitter, 'error', errorHandler);\n  }\n  const closeEvents = options?.close;\n  if (closeEvents?.length) {\n    for (let i = 0; i < closeEvents.length; i++) {\n      addEventListener(emitter, closeEvents[i], closeHandler);\n    }\n  }\n  if (signal) {\n    kResistStopPropagation ??= require('internal/event_target').kResistStopPropagation;\n    eventTargetAgnosticAddListener(\n      signal,\n      'abort',\n      abortListener,\n      { __proto__: null, once: true, [kResistStopPropagation]: true });\n  }\n\n  return iterator;\n\n  function abortListener() {\n    errorHandler(new AbortError(undefined, { cause: signal?.reason }));\n  }\n\n  function eventHandler(value) {\n    if (unconsumedPromises.isEmpty()) {\n      size++;\n      if (!paused && size > highWatermark) {\n        paused = true;\n        emitter.pause();\n      }\n      unconsumedEvents.push(value);\n    } else unconsumedPromises.shift().resolve(createIterResult(value, false));\n  }\n\n  function errorHandler(err) {\n    if (unconsumedPromises.isEmpty()) error = err;\n    else unconsumedPromises.shift().reject(err);\n\n    closeHandler();\n  }\n\n  function closeHandler() {\n    removeAll();\n    finished = true;\n    const doneResult = createIterResult(undefined, true);\n    while (!unconsumedPromises.isEmpty()) {\n      unconsumedPromises.shift().resolve(doneResult);\n    }\n\n    return PromiseResolve(doneResult);\n  }\n}\n\nfunction listenersController() {\n  const listeners = [];\n\n  return {\n    addEventListener(emitter, event, handler, flags) {\n      eventTargetAgnosticAddListener(emitter, event, handler, flags);\n      ArrayPrototypePush(listeners, [emitter, event, handler, flags]);\n    },\n    removeAll() {\n      while (listeners.length > 0) {\n        ReflectApply(eventTargetAgnosticRemoveListener, undefined, ArrayPrototypePop(listeners));\n      }\n    },\n  };\n}\n\nlet queueMicrotask;\n\nfunction addAbortListener(signal, listener) {\n  if (signal === undefined) {\n    throw new ERR_INVALID_ARG_TYPE('signal', 'AbortSignal', signal);\n  }\n  validateAbortSignal(signal, 'signal');\n  validateFunction(listener, 'listener');\n\n  let removeEventListener;\n  if (signal.aborted) {\n    queueMicrotask ??= require('internal/process/task_queues').queueMicrotask;\n    queueMicrotask(() => listener());\n  } else {\n    kResistStopPropagation ??= require('internal/event_target').kResistStopPropagation;\n    // TODO(atlowChemi) add { subscription: true } and return directly\n    signal.addEventListener('abort', listener, { __proto__: null, once: true, [kResistStopPropagation]: true });\n    removeEventListener = () => {\n      signal.removeEventListener('abort', listener);\n    };\n  }\n  return {\n    __proto__: null,\n    [SymbolDispose]() {\n      removeEventListener?.();\n    },\n  };\n}\n",
    "28": "'use strict';\n\nconst {\n  Array,\n  FunctionPrototypeBind,\n} = primordials;\n\nconst {\n  // For easy access to the nextTick state in the C++ land,\n  // and to avoid unnecessary calls into JS land.\n  tickInfo,\n  // Used to run V8's micro task queue.\n  runMicrotasks,\n  setTickCallback,\n  enqueueMicrotask,\n} = internalBinding('task_queue');\n\nconst {\n  setHasRejectionToWarn,\n  hasRejectionToWarn,\n  listenForRejections,\n  processPromiseRejections,\n} = require('internal/process/promises');\n\nconst {\n  getDefaultTriggerAsyncId,\n  newAsyncId,\n  initHooksExist,\n  destroyHooksExist,\n  emitInit,\n  emitBefore,\n  emitAfter,\n  emitDestroy,\n  symbols: { async_id_symbol, trigger_async_id_symbol },\n} = require('internal/async_hooks');\nconst FixedQueue = require('internal/fixed_queue');\n\nconst {\n  validateFunction,\n} = require('internal/validators');\n\nconst { AsyncResource } = require('async_hooks');\n\n// *Must* match Environment::TickInfo::Fields in src/env.h.\nconst kHasTickScheduled = 0;\n\nfunction hasTickScheduled() {\n  return tickInfo[kHasTickScheduled] === 1;\n}\n\nfunction setHasTickScheduled(value) {\n  tickInfo[kHasTickScheduled] = value ? 1 : 0;\n}\n\nconst queue = new FixedQueue();\n\n// Should be in sync with RunNextTicksNative in node_task_queue.cc\nfunction runNextTicks() {\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    runMicrotasks();\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    return;\n\n  processTicksAndRejections();\n}\n\nfunction processTicksAndRejections() {\n  let tock;\n  do {\n    while ((tock = queue.shift()) !== null) {\n      const asyncId = tock[async_id_symbol];\n      emitBefore(asyncId, tock[trigger_async_id_symbol], tock);\n\n      try {\n        const callback = tock.callback;\n        if (tock.args === undefined) {\n          callback();\n        } else {\n          const args = tock.args;\n          switch (args.length) {\n            case 1: callback(args[0]); break;\n            case 2: callback(args[0], args[1]); break;\n            case 3: callback(args[0], args[1], args[2]); break;\n            case 4: callback(args[0], args[1], args[2], args[3]); break;\n            default: callback(...args);\n          }\n        }\n      } finally {\n        if (destroyHooksExist())\n          emitDestroy(asyncId);\n      }\n\n      emitAfter(asyncId);\n    }\n    runMicrotasks();\n  } while (!queue.isEmpty() || processPromiseRejections());\n  setHasTickScheduled(false);\n  setHasRejectionToWarn(false);\n}\n\n// `nextTick()` will not enqueue any callback when the process is about to\n// exit since the callback would not have a chance to be executed.\nfunction nextTick(callback) {\n  validateFunction(callback, 'callback');\n\n  if (process._exiting)\n    return;\n\n  let args;\n  switch (arguments.length) {\n    case 1: break;\n    case 2: args = [arguments[1]]; break;\n    case 3: args = [arguments[1], arguments[2]]; break;\n    case 4: args = [arguments[1], arguments[2], arguments[3]]; break;\n    default:\n      args = new Array(arguments.length - 1);\n      for (let i = 1; i < arguments.length; i++)\n        args[i - 1] = arguments[i];\n  }\n\n  if (queue.isEmpty())\n    setHasTickScheduled(true);\n  const asyncId = newAsyncId();\n  const triggerAsyncId = getDefaultTriggerAsyncId();\n  const tickObject = {\n    [async_id_symbol]: asyncId,\n    [trigger_async_id_symbol]: triggerAsyncId,\n    callback,\n    args,\n  };\n  if (initHooksExist())\n    emitInit(asyncId, 'TickObject', triggerAsyncId, tickObject);\n  queue.push(tickObject);\n}\n\nfunction runMicrotask() {\n  this.runInAsyncScope(() => {\n    const callback = this.callback;\n    try {\n      callback();\n    } finally {\n      this.emitDestroy();\n    }\n  });\n}\n\nconst defaultMicrotaskResourceOpts = { requireManualDestroy: true };\n\nfunction queueMicrotask(callback) {\n  validateFunction(callback, 'callback');\n\n  const asyncResource = new AsyncResource(\n    'Microtask',\n    defaultMicrotaskResourceOpts,\n  );\n  asyncResource.callback = callback;\n\n  enqueueMicrotask(FunctionPrototypeBind(runMicrotask, asyncResource));\n}\n\nmodule.exports = {\n  setupTaskQueue() {\n    // Sets the per-isolate promise rejection callback\n    listenForRejections();\n    // Sets the callback to be run in every tick.\n    setTickCallback(processTicksAndRejections);\n    return {\n      nextTick,\n      runNextTicks,\n    };\n  },\n  queueMicrotask,\n};\n",
    "34": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  FunctionPrototypeBind,\n  StringPrototypeCharCodeAt,\n  StringPrototypeIndexOf,\n  StringPrototypeLastIndexOf,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeToLowerCase,\n} = primordials;\n\nconst {\n  CHAR_UPPERCASE_A,\n  CHAR_LOWERCASE_A,\n  CHAR_UPPERCASE_Z,\n  CHAR_LOWERCASE_Z,\n  CHAR_DOT,\n  CHAR_FORWARD_SLASH,\n  CHAR_BACKWARD_SLASH,\n  CHAR_COLON,\n  CHAR_QUESTION_MARK,\n} = require('internal/constants');\nconst {\n  validateObject,\n  validateString,\n} = require('internal/validators');\n\nconst platformIsWin32 = (process.platform === 'win32');\n\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = StringPrototypeCharCodeAt(path, i);\n    else if (isPathSeparator(code))\n      break;\n    else\n      code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 ||\n            StringPrototypeCharCodeAt(res, res.length - 1) !== CHAR_DOT ||\n            StringPrototypeCharCodeAt(res, res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = StringPrototypeLastIndexOf(res, separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = StringPrototypeSlice(res, 0, lastSlashIndex);\n              lastSegmentLength =\n                res.length - 1 - StringPrototypeLastIndexOf(res, separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += `${separator}${StringPrototypeSlice(path, lastSlash + 1, i)}`;\n        else\n          res = StringPrototypeSlice(path, lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction formatExt(ext) {\n  return ext ? `${ext[0] === '.' ? '' : '.'}${ext}` : '';\n}\n\n/**\n * @param {string} sep\n * @param {{\n *  dir?: string;\n *  root?: string;\n *  base?: string;\n *  name?: string;\n *  ext?: string;\n *  }} pathObject\n * @returns {string}\n */\nfunction _format(sep, pathObject) {\n  validateObject(pathObject, 'pathObject');\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base ||\n    `${pathObject.name || ''}${formatExt(pathObject.ext)}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nconst win32 = {\n  /**\n   * path.resolve([from ...], to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedDevice = '';\n    let resolvedTail = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1; i--) {\n      let path;\n      if (i >= 0) {\n        path = args[i];\n        validateString(path, `paths[${i}]`);\n\n        // Skip empty entries\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path, get cwd for that drive, or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points, because UNC paths are always absolute.\n        path = process.env[`=${resolvedDevice}`] || process.cwd();\n\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not, default to the drive's root.\n        if (path === undefined ||\n            (StringPrototypeToLowerCase(StringPrototypeSlice(path, 0, 2)) !==\n            StringPrototypeToLowerCase(resolvedDevice) &&\n            StringPrototypeCharCodeAt(path, 2) === CHAR_BACKWARD_SLASH)) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n\n      const len = path.length;\n      let rootEnd = 0;\n      let device = '';\n      let isAbsolute = false;\n      const code = StringPrototypeCharCodeAt(path, 0);\n\n      // Try to match a root\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          // `path` contains just a path separator\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        // Possible UNC root\n\n        // If we started with a separator, we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(StringPrototypeCharCodeAt(path, 1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          while (j < len &&\n                 !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            const firstPart = StringPrototypeSlice(path, last, j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            while (j < len &&\n                   isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n              j++;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              while (j < len &&\n                     !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                // We matched a UNC root\n                device =\n                  `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path, last, j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) &&\n                  StringPrototypeCharCodeAt(path, 1) === CHAR_COLON) {\n        // Possible device root\n        device = StringPrototypeSlice(path, 0, 2);\n        rootEnd = 2;\n        if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path, 2))) {\n          // Treat separator following drive name as an absolute path\n          // indicator\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (StringPrototypeToLowerCase(device) !==\n              StringPrototypeToLowerCase(resolvedDevice))\n            // This path points to another device so it is not applicable\n            continue;\n        } else {\n          resolvedDevice = device;\n        }\n      }\n\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0)\n          break;\n      } else {\n        resolvedTail =\n          `${StringPrototypeSlice(path, rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    }\n\n    // At this point the path should be resolved to a full absolute path,\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n                                   isPathSeparator);\n\n    return resolvedAbsolute ?\n      `${resolvedDevice}\\\\${resolvedTail}` :\n      `${resolvedDevice}${resolvedTail}` || '.';\n  },\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path, 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = StringPrototypeCharCodeAt(path, 0);\n\n    // Try to match a root\n    if (len === 1) {\n      // `path` contains just a single char, exit early to avoid\n      // unnecessary work\n      return isPosixPathSeparator(code) ? '\\\\' : path;\n    }\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator, we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          const firstPart = StringPrototypeSlice(path, last, j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n              return `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path, last)}\\\\`;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              device =\n                `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path, last, j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path, 1) === CHAR_COLON) {\n      // Possible device root\n      device = StringPrototypeSlice(path, 0, 2);\n      rootEnd = 2;\n      if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path, 2))) {\n        // Treat separator following drive name as an absolute path\n        // indicator\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n\n    let tail = rootEnd < len ?\n      normalizeString(StringPrototypeSlice(path, rootEnd),\n                      !isAbsolute, '\\\\', isPathSeparator) :\n      '';\n    if (tail.length === 0 && !isAbsolute)\n      tail = '.';\n    if (tail.length > 0 &&\n        isPathSeparator(StringPrototypeCharCodeAt(path, len - 1)))\n      tail += '\\\\';\n    if (device === undefined) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  },\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path, 'path');\n    const len = path.length;\n    if (len === 0)\n      return false;\n\n    const code = StringPrototypeCharCodeAt(path, 0);\n    return isPathSeparator(code) ||\n      // Possible device root\n      (len > 2 &&\n      isWindowsDeviceRoot(code) &&\n      StringPrototypeCharCodeAt(path, 1) === CHAR_COLON &&\n      isPathSeparator(StringPrototypeCharCodeAt(path, 2)));\n  },\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n\n    let joined;\n    let firstPart;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = firstPart = arg;\n        else\n          joined += `\\\\${arg}`;\n      }\n    }\n\n    if (joined === undefined)\n      return '.';\n\n    // Make sure that the joined path doesn't start with two slashes, because\n    // normalize() will mistake it for a UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at a UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as a UNC path it needs to\n    // have at least 2 components, so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n    let needsReplace = true;\n    let slashCount = 0;\n    if (isPathSeparator(StringPrototypeCharCodeAt(firstPart, 0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1 &&\n          isPathSeparator(StringPrototypeCharCodeAt(firstPart, 1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(StringPrototypeCharCodeAt(firstPart, 2)))\n            ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      while (slashCount < joined.length &&\n             isPathSeparator(StringPrototypeCharCodeAt(joined, slashCount))) {\n        slashCount++;\n      }\n\n      // Replace the slashes if needed\n      if (slashCount >= 2)\n        joined = `\\\\${StringPrototypeSlice(joined, slashCount)}`;\n    }\n\n    return win32.normalize(joined);\n  },\n\n  /**\n   * It will solve the relative path from `from` to `to`, for instance\n   * from = 'C:\\\\orandea\\\\test\\\\aaa'\n   * to = 'C:\\\\orandea\\\\impl\\\\bbb'\n   * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to)\n      return '';\n\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig)\n      return '';\n\n    from = StringPrototypeToLowerCase(fromOrig);\n    to = StringPrototypeToLowerCase(toOrig);\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    let fromStart = 0;\n    while (fromStart < from.length &&\n           StringPrototypeCharCodeAt(from, fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let fromEnd = from.length;\n    while (\n      fromEnd - 1 > fromStart &&\n      StringPrototypeCharCodeAt(from, fromEnd - 1) === CHAR_BACKWARD_SLASH\n    ) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    let toStart = 0;\n    while (toStart < to.length &&\n           StringPrototypeCharCodeAt(to, toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let toEnd = to.length;\n    while (toEnd - 1 > toStart &&\n           StringPrototypeCharCodeAt(to, toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from, fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to, toStart + i))\n        break;\n      else if (fromCode === CHAR_BACKWARD_SLASH)\n        lastCommonSep = i;\n    }\n\n    // We found a mismatch before the first common path separator was seen, so\n    // return the original `to`.\n    if (i !== length) {\n      if (lastCommonSep === -1)\n        return toOrig;\n    } else {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to, toStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return StringPrototypeSlice(toOrig, toStart + i + 1);\n        }\n        if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return StringPrototypeSlice(toOrig, toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from, fromStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1)\n        lastCommonSep = 0;\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from, i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? '..' : '\\\\..';\n      }\n    }\n\n    toStart += lastCommonSep;\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return `${out}${StringPrototypeSlice(toOrig, toStart, toEnd)}`;\n\n    if (StringPrototypeCharCodeAt(toOrig, toStart) === CHAR_BACKWARD_SLASH)\n      ++toStart;\n    return StringPrototypeSlice(toOrig, toStart, toEnd);\n  },\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string' || path.length === 0)\n      return path;\n\n    const resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length <= 2)\n      return path;\n\n    if (StringPrototypeCharCodeAt(resolvedPath, 0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n      if (StringPrototypeCharCodeAt(resolvedPath, 1) === CHAR_BACKWARD_SLASH) {\n        const code = StringPrototypeCharCodeAt(resolvedPath, 2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root, convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${StringPrototypeSlice(resolvedPath, 2)}`;\n        }\n      }\n    } else if (\n      isWindowsDeviceRoot(StringPrototypeCharCodeAt(resolvedPath, 0)) &&\n      StringPrototypeCharCodeAt(resolvedPath, 1) === CHAR_COLON &&\n      StringPrototypeCharCodeAt(resolvedPath, 2) === CHAR_BACKWARD_SLASH\n    ) {\n      // Matched device root, convert the path to a long UNC path\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n\n    return path;\n  },\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path, 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = -1;\n    let offset = 0;\n    const code = StringPrototypeCharCodeAt(path, 0);\n\n    if (len === 1) {\n      // `path` contains just a path separator, exit early to avoid\n      // unnecessary work or a dot.\n      return isPathSeparator(code) ? path : '.';\n    }\n\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a \"normal root\" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    // Possible device root\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path, 1) === CHAR_COLON) {\n      rootEnd =\n        len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path, 2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1)\n        return '.';\n\n      end = rootEnd;\n    }\n    return StringPrototypeSlice(path, 0, end);\n  },\n\n  /**\n   * @param {string} path\n   * @param {string} [suffix]\n   * @returns {string}\n   */\n  basename(path, suffix) {\n    if (suffix !== undefined)\n      validateString(suffix, 'ext');\n    validateString(path, 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2 &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path, 0)) &&\n        StringPrototypeCharCodeAt(path, 1) === CHAR_COLON) {\n      start = 2;\n    }\n\n    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n      if (suffix === path)\n        return '';\n      let extIdx = suffix.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= start; --i) {\n        const code = StringPrototypeCharCodeAt(path, i);\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(suffix, extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path, start, end);\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, i))) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path, start, end);\n  },\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path, 'path');\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 &&\n        StringPrototypeCharCodeAt(path, 1) === CHAR_COLON &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path, 0))) {\n      start = startPart = 2;\n    }\n\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path, i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path, startDot, end);\n  },\n\n  format: FunctionPrototypeBind(_format, null, '\\\\'),\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *  dir: string;\n   *  root: string;\n   *  base: string;\n   *  name: string;\n   *  ext: string;\n   *  }}\n   */\n  parse(path) {\n    validateString(path, 'path');\n\n    const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0)\n      return ret;\n\n    const len = path.length;\n    let rootEnd = 0;\n    let code = StringPrototypeCharCodeAt(path, 0);\n\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        // `path` contains just a path separator, exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = 1;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path, 1) === CHAR_COLON) {\n      // Possible device root\n      if (len <= 2) {\n        // `path` contains just a drive root, exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, 2))) {\n        if (len === 3) {\n          // `path` contains just a drive root, exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd > 0)\n      ret.root = StringPrototypeSlice(path, 0, rootEnd);\n\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = StringPrototypeCharCodeAt(path, i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n           startDot === end - 1 &&\n           startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path, startPart, end);\n      } else {\n        ret.name = StringPrototypeSlice(path, startPart, startDot);\n        ret.base = StringPrototypeSlice(path, startPart, end);\n        ret.ext = StringPrototypeSlice(path, startDot, end);\n      }\n    }\n\n    // If the directory is the root, use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n    if (startPart > 0 && startPart !== rootEnd)\n      ret.dir = StringPrototypeSlice(path, 0, startPart - 1);\n    else\n      ret.dir = ret.root;\n\n    return ret;\n  },\n\n  sep: '\\\\',\n  delimiter: ';',\n  win32: null,\n  posix: null,\n};\n\nconst posixCwd = (() => {\n  if (platformIsWin32) {\n    // Converts Windows' backslash path separators to POSIX forward slashes\n    // and truncates any drive indicator\n    const regexp = /\\\\/g;\n    return () => {\n      const cwd = StringPrototypeReplace(process.cwd(), regexp, '/');\n      return StringPrototypeSlice(cwd, StringPrototypeIndexOf(cwd, '/'));\n    };\n  }\n\n  // We're already on POSIX, no need for any transformations\n  return () => process.cwd();\n})();\n\nconst posix = {\n  /**\n   * path.resolve([from ...], to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? args[i] : posixCwd();\n      validateString(path, `paths[${i}]`);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute =\n        StringPrototypeCharCodeAt(path, 0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n                                   isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  },\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path, 'path');\n\n    if (path.length === 0)\n      return '.';\n\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path, 0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator =\n      StringPrototypeCharCodeAt(path, path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute)\n        return '/';\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator)\n      path += '/';\n\n    return isAbsolute ? `/${path}` : path;\n  },\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path, 'path');\n    return path.length > 0 &&\n           StringPrototypeCharCodeAt(path, 0) === CHAR_FORWARD_SLASH;\n  },\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n    let joined;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += `/${arg}`;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to)\n      return '';\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = (fromLen < toLen ? fromLen : toLen);\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from, fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to, toStart + i))\n        break;\n      else if (fromCode === CHAR_FORWARD_SLASH)\n        lastCommonSep = i;\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to, toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return StringPrototypeSlice(to, toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return StringPrototypeSlice(to, toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from, fromStart + i) ===\n            CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from, i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${StringPrototypeSlice(to, toStart + lastCommonSep)}`;\n  },\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path;\n  },\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path, 'path');\n    if (path.length === 0)\n      return '.';\n    const hasRoot = StringPrototypeCharCodeAt(path, 0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return StringPrototypeSlice(path, 0, end);\n  },\n\n  /**\n   * @param {string} path\n   * @param {string} [suffix]\n   * @returns {string}\n   */\n  basename(path, suffix) {\n    if (suffix !== undefined)\n      validateString(suffix, 'ext');\n    validateString(path, 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n      if (suffix === path)\n        return '';\n      let extIdx = suffix.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= 0; --i) {\n        const code = StringPrototypeCharCodeAt(path, i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(suffix, extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path, start, end);\n    }\n    for (let i = path.length - 1; i >= 0; --i) {\n      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path, start, end);\n  },\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path, 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(path, i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path, startDot, end);\n  },\n\n  format: FunctionPrototypeBind(_format, null, '/'),\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *   dir: string;\n   *   root: string;\n   *   base: string;\n   *   name: string;\n   *   ext: string;\n   *   }}\n   */\n  parse(path) {\n    validateString(path, 'path');\n\n    const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0)\n      return ret;\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path, 0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path, i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n          startDot === end - 1 &&\n          startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path, start, end);\n      } else {\n        ret.name = StringPrototypeSlice(path, start, startDot);\n        ret.base = StringPrototypeSlice(path, start, end);\n        ret.ext = StringPrototypeSlice(path, startDot, end);\n      }\n    }\n\n    if (startPart > 0)\n      ret.dir = StringPrototypeSlice(path, 0, startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null,\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\n// Legacy internal API, docs-only deprecated: DEP0080\nwin32._makeLong = win32.toNamespacedPath;\nposix._makeLong = posix.toNamespacedPath;\n\nmodule.exports = platformIsWin32 ? win32 : posix;\n",
    "136": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// WARNING: THIS MODULE IS PENDING DEPRECATION.\n//\n// No new pull requests targeting this module will be accepted\n// unless they address existing, critical bugs.\n\nconst {\n  ArrayPrototypeEvery,\n  ArrayPrototypeIndexOf,\n  ArrayPrototypeLastIndexOf,\n  ArrayPrototypePush,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSplice,\n  Error,\n  FunctionPrototypeCall,\n  ObjectDefineProperty,\n  Promise,\n  ReflectApply,\n  SafeMap,\n  SafeWeakMap,\n  Symbol,\n} = primordials;\n\nconst EventEmitter = require('events');\nconst {\n  ERR_DOMAIN_CALLBACK_NOT_AVAILABLE,\n  ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE,\n  ERR_UNHANDLED_ERROR,\n} = require('internal/errors').codes;\nconst { createHook } = require('async_hooks');\nconst { useDomainTrampoline } = require('internal/async_hooks');\n\nconst kWeak = Symbol('kWeak');\nconst { WeakReference } = require('internal/util');\n\n// Overwrite process.domain with a getter/setter that will allow for more\n// effective optimizations\nconst _domain = [null];\nObjectDefineProperty(process, 'domain', {\n  __proto__: null,\n  enumerable: true,\n  get: function() {\n    return _domain[0];\n  },\n  set: function(arg) {\n    return _domain[0] = arg;\n  },\n});\n\nconst vmPromises = new SafeWeakMap();\nconst pairing = new SafeMap();\nconst asyncHook = createHook({\n  init(asyncId, type, triggerAsyncId, resource) {\n    if (process.domain !== null && process.domain !== undefined) {\n      // If this operation is created while in a domain, let's mark it\n      pairing.set(asyncId, process.domain[kWeak]);\n      // Promises from other contexts, such as with the VM module, should not\n      // have a domain property as it can be used to escape the sandbox.\n      if (type !== 'PROMISE' || resource instanceof Promise) {\n        ObjectDefineProperty(resource, 'domain', {\n          __proto__: null,\n          configurable: true,\n          enumerable: false,\n          value: process.domain,\n          writable: true,\n        });\n      // Because promises from other contexts don't get a domain field,\n      // the domain needs to be held alive another way. Stuffing it in a\n      // weakmap connected to the promise lifetime can fix that.\n      } else {\n        vmPromises.set(resource, process.domain);\n      }\n    }\n  },\n  before(asyncId) {\n    const current = pairing.get(asyncId);\n    if (current !== undefined) { // Enter domain for this cb\n      // We will get the domain through current.get(), because the resource\n      // object's .domain property makes sure it is not garbage collected.\n      // However, we do need to make the reference to the domain non-weak,\n      // so that it cannot be garbage collected before the after() hook.\n      current.incRef();\n      current.get().enter();\n    }\n  },\n  after(asyncId) {\n    const current = pairing.get(asyncId);\n    if (current !== undefined) { // Exit domain for this cb\n      const domain = current.get();\n      current.decRef();\n      domain.exit();\n    }\n  },\n  destroy(asyncId) {\n    pairing.delete(asyncId); // cleaning up\n  },\n});\n\n// When domains are in use, they claim full ownership of the\n// uncaught exception capture callback.\nif (process.hasUncaughtExceptionCaptureCallback()) {\n  throw new ERR_DOMAIN_CALLBACK_NOT_AVAILABLE();\n}\n\n// Get the stack trace at the point where `domain` was required.\n// eslint-disable-next-line no-restricted-syntax\nconst domainRequireStack = new Error('require(`domain`) at this point').stack;\n\nconst { setUncaughtExceptionCaptureCallback } = process;\nprocess.setUncaughtExceptionCaptureCallback = function(fn) {\n  const err = new ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE();\n  err.stack = err.stack + '\\n' + '-'.repeat(40) + '\\n' + domainRequireStack;\n  throw err;\n};\n\n\nlet sendMakeCallbackDeprecation = false;\nfunction emitMakeCallbackDeprecation({ target, method }) {\n  if (!sendMakeCallbackDeprecation) {\n    process.emitWarning(\n      'Using a domain property in MakeCallback is deprecated. Use the ' +\n      'async_context variant of MakeCallback or the AsyncResource class ' +\n      'instead. ' +\n      `(Triggered by calling ${method?.name || '<anonymous>'} ` +\n      `on ${target?.constructor?.name}.)`,\n      'DeprecationWarning', 'DEP0097');\n    sendMakeCallbackDeprecation = true;\n  }\n}\n\nfunction topLevelDomainCallback(cb, ...args) {\n  const domain = this.domain;\n  if (exports.active && domain)\n    emitMakeCallbackDeprecation({ target: this, method: cb });\n\n  if (domain)\n    domain.enter();\n  const ret = ReflectApply(cb, this, args);\n  if (domain)\n    domain.exit();\n\n  return ret;\n}\n\n// It's possible to enter one domain while already inside\n// another one. The stack is each entered domain.\nlet stack = [];\nexports._stack = stack;\nuseDomainTrampoline(topLevelDomainCallback);\n\nfunction updateExceptionCapture() {\n  if (ArrayPrototypeEvery(stack,\n                          (domain) => domain.listenerCount('error') === 0)) {\n    setUncaughtExceptionCaptureCallback(null);\n  } else {\n    setUncaughtExceptionCaptureCallback(null);\n    setUncaughtExceptionCaptureCallback((er) => {\n      return process.domain._errorHandler(er);\n    });\n  }\n}\n\n\nprocess.on('newListener', (name, listener) => {\n  if (name === 'uncaughtException' &&\n      listener !== domainUncaughtExceptionClear) {\n    // Make sure the first listener for `uncaughtException` always clears\n    // the domain stack.\n    process.removeListener(name, domainUncaughtExceptionClear);\n    process.prependListener(name, domainUncaughtExceptionClear);\n  }\n});\n\nprocess.on('removeListener', (name, listener) => {\n  if (name === 'uncaughtException' &&\n      listener !== domainUncaughtExceptionClear) {\n    // If the domain listener would be the only remaining one, remove it.\n    const listeners = process.listeners('uncaughtException');\n    if (listeners.length === 1 && listeners[0] === domainUncaughtExceptionClear)\n      process.removeListener(name, domainUncaughtExceptionClear);\n  }\n});\n\nfunction domainUncaughtExceptionClear() {\n  stack.length = 0;\n  exports.active = process.domain = null;\n  updateExceptionCapture();\n}\n\n\nclass Domain extends EventEmitter {\n  constructor() {\n    super();\n\n    this.members = [];\n    this[kWeak] = new WeakReference(this);\n    asyncHook.enable();\n\n    this.on('removeListener', updateExceptionCapture);\n    this.on('newListener', updateExceptionCapture);\n  }\n}\n\nexports.Domain = Domain;\n\nexports.create = exports.createDomain = function createDomain() {\n  return new Domain();\n};\n\n// The active domain is always the one that we're currently in.\nexports.active = null;\nDomain.prototype.members = undefined;\n\n// Called by process._fatalException in case an error was thrown.\nDomain.prototype._errorHandler = function(er) {\n  let caught = false;\n\n  if ((typeof er === 'object' && er !== null) || typeof er === 'function') {\n    ObjectDefineProperty(er, 'domain', {\n      __proto__: null,\n      configurable: true,\n      enumerable: false,\n      value: this,\n      writable: true,\n    });\n    er.domainThrown = true;\n  }\n  // Pop all adjacent duplicates of the currently active domain from the stack.\n  // This is done to prevent a domain's error handler to run within the context\n  // of itself, and re-entering itself recursively handler as a result of an\n  // exception thrown in its context.\n  while (exports.active === this) {\n    this.exit();\n  }\n\n  // The top-level domain-handler is handled separately.\n  //\n  // The reason is that if V8 was passed a command line option\n  // asking it to abort on an uncaught exception (currently\n  // \"--abort-on-uncaught-exception\"), we want an uncaught exception\n  // in the top-level domain error handler to make the\n  // process abort. Using try/catch here would always make V8 think\n  // that these exceptions are caught, and thus would prevent it from\n  // aborting in these cases.\n  if (stack.length === 0) {\n    // If there's no error handler, do not emit an 'error' event\n    // as this would throw an error, make the process exit, and thus\n    // prevent the process 'uncaughtException' event from being emitted\n    // if a listener is set.\n    if (EventEmitter.listenerCount(this, 'error') > 0) {\n      // Clear the uncaughtExceptionCaptureCallback so that we know that, since\n      // the top-level domain is not active anymore, it would be ok to abort on\n      // an uncaught exception at this point\n      setUncaughtExceptionCaptureCallback(null);\n      try {\n        caught = this.emit('error', er);\n      } finally {\n        updateExceptionCapture();\n      }\n    }\n  } else {\n    // Wrap this in a try/catch so we don't get infinite throwing\n    try {\n      // One of three things will happen here.\n      //\n      // 1. There is a handler, caught = true\n      // 2. There is no handler, caught = false\n      // 3. It throws, caught = false\n      //\n      // If caught is false after this, then there's no need to exit()\n      // the domain, because we're going to crash the process anyway.\n      caught = this.emit('error', er);\n    } catch (er2) {\n      // The domain error handler threw!  oh no!\n      // See if another domain can catch THIS error,\n      // or else crash on the original one.\n      updateExceptionCapture();\n      if (stack.length) {\n        exports.active = process.domain = stack[stack.length - 1];\n        caught = process.domain._errorHandler(er2);\n      } else {\n        // Pass on to the next exception handler.\n        throw er2;\n      }\n    }\n  }\n\n  // Exit all domains on the stack.  Uncaught exceptions end the\n  // current tick and no domains should be left on the stack\n  // between ticks.\n  domainUncaughtExceptionClear();\n\n  return caught;\n};\n\n\nDomain.prototype.enter = function() {\n  // Note that this might be a no-op, but we still need\n  // to push it onto the stack so that we can pop it later.\n  exports.active = process.domain = this;\n  ArrayPrototypePush(stack, this);\n  updateExceptionCapture();\n};\n\n\nDomain.prototype.exit = function() {\n  // Don't do anything if this domain is not on the stack.\n  const index = ArrayPrototypeLastIndexOf(stack, this);\n  if (index === -1) return;\n\n  // Exit all domains until this one.\n  ArrayPrototypeSplice(stack, index);\n\n  exports.active = stack.length === 0 ? undefined : stack[stack.length - 1];\n  process.domain = exports.active;\n  updateExceptionCapture();\n};\n\n\n// note: this works for timers as well.\nDomain.prototype.add = function(ee) {\n  // If the domain is already added, then nothing left to do.\n  if (ee.domain === this)\n    return;\n\n  // Has a domain already - remove it first.\n  if (ee.domain)\n    ee.domain.remove(ee);\n\n  // Check for circular Domain->Domain links.\n  // They cause big issues.\n  //\n  // For example:\n  // var d = domain.create();\n  // var e = domain.create();\n  // d.add(e);\n  // e.add(d);\n  // e.emit('error', er); // RangeError, stack overflow!\n  if (this.domain && (ee instanceof Domain)) {\n    for (let d = this.domain; d; d = d.domain) {\n      if (ee === d) return;\n    }\n  }\n\n  ObjectDefineProperty(ee, 'domain', {\n    __proto__: null,\n    configurable: true,\n    enumerable: false,\n    value: this,\n    writable: true,\n  });\n  ArrayPrototypePush(this.members, ee);\n};\n\n\nDomain.prototype.remove = function(ee) {\n  ee.domain = null;\n  const index = ArrayPrototypeIndexOf(this.members, ee);\n  if (index !== -1)\n    ArrayPrototypeSplice(this.members, index, 1);\n};\n\n\nDomain.prototype.run = function(fn) {\n  this.enter();\n  const ret = ReflectApply(fn, this, ArrayPrototypeSlice(arguments, 1));\n  this.exit();\n\n  return ret;\n};\n\n\nfunction intercepted(_this, self, cb, fnargs) {\n  if (fnargs[0] && fnargs[0] instanceof Error) {\n    const er = fnargs[0];\n    er.domainBound = cb;\n    er.domainThrown = false;\n    ObjectDefineProperty(er, 'domain', {\n      __proto__: null,\n      configurable: true,\n      enumerable: false,\n      value: self,\n      writable: true,\n    });\n    self.emit('error', er);\n    return;\n  }\n\n  self.enter();\n  const ret = ReflectApply(cb, _this, ArrayPrototypeSlice(fnargs, 1));\n  self.exit();\n\n  return ret;\n}\n\n\nDomain.prototype.intercept = function(cb) {\n  const self = this;\n\n  function runIntercepted() {\n    return intercepted(this, self, cb, arguments);\n  }\n\n  return runIntercepted;\n};\n\n\nfunction bound(_this, self, cb, fnargs) {\n  self.enter();\n  const ret = ReflectApply(cb, _this, fnargs);\n  self.exit();\n\n  return ret;\n}\n\n\nDomain.prototype.bind = function(cb) {\n  const self = this;\n\n  function runBound() {\n    return bound(this, self, cb, arguments);\n  }\n\n  ObjectDefineProperty(runBound, 'domain', {\n    __proto__: null,\n    configurable: true,\n    enumerable: false,\n    value: this,\n    writable: true,\n  });\n\n  return runBound;\n};\n\n// Override EventEmitter methods to make it domain-aware.\nEventEmitter.usingDomains = true;\n\nconst eventInit = EventEmitter.init;\nEventEmitter.init = function(opts) {\n  ObjectDefineProperty(this, 'domain', {\n    __proto__: null,\n    configurable: true,\n    enumerable: false,\n    value: null,\n    writable: true,\n  });\n  if (exports.active && !(this instanceof exports.Domain)) {\n    this.domain = exports.active;\n  }\n\n  return FunctionPrototypeCall(eventInit, this, opts);\n};\n\nconst eventEmit = EventEmitter.prototype.emit;\nEventEmitter.prototype.emit = function emit(...args) {\n  const domain = this.domain;\n\n  const type = args[0];\n  const shouldEmitError = type === 'error' &&\n                          this.listenerCount(type) > 0;\n\n  // Just call original `emit` if current EE instance has `error`\n  // handler, there's no active domain or this is process\n  if (shouldEmitError || domain === null || domain === undefined ||\n      this === process) {\n    return ReflectApply(eventEmit, this, args);\n  }\n\n  if (type === 'error') {\n    const er = args.length > 1 && args[1] ?\n      args[1] : new ERR_UNHANDLED_ERROR();\n\n    if (typeof er === 'object') {\n      er.domainEmitter = this;\n      ObjectDefineProperty(er, 'domain', {\n        __proto__: null,\n        configurable: true,\n        enumerable: false,\n        value: domain,\n        writable: true,\n      });\n      er.domainThrown = false;\n    }\n\n    // Remove the current domain (and its duplicates) from the domains stack and\n    // set the active domain to its parent (if any) so that the domain's error\n    // handler doesn't run in its own context. This prevents any event emitter\n    // created or any exception thrown in that error handler from recursively\n    // executing that error handler.\n    const origDomainsStack = ArrayPrototypeSlice(stack);\n    const origActiveDomain = process.domain;\n\n    // Travel the domains stack from top to bottom to find the first domain\n    // instance that is not a duplicate of the current active domain.\n    let idx = stack.length - 1;\n    while (idx > -1 && process.domain === stack[idx]) {\n      --idx;\n    }\n\n    // Change the stack to not contain the current active domain, and only the\n    // domains above it on the stack.\n    if (idx < 0) {\n      stack.length = 0;\n    } else {\n      ArrayPrototypeSplice(stack, idx + 1);\n    }\n\n    // Change the current active domain\n    if (stack.length > 0) {\n      exports.active = process.domain = stack[stack.length - 1];\n    } else {\n      exports.active = process.domain = null;\n    }\n\n    updateExceptionCapture();\n\n    domain.emit('error', er);\n\n    // Now that the domain's error handler has completed, restore the domains\n    // stack and the active domain to their original values.\n    exports._stack = stack = origDomainsStack;\n    exports.active = process.domain = origActiveDomain;\n    updateExceptionCapture();\n\n    return false;\n  }\n\n  domain.enter();\n  const ret = ReflectApply(eventEmit, this, args);\n  domain.exit();\n\n  return ret;\n};\n",
    "220": "\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst html_minifier_1 = __importDefault(require(\"html-minifier\"));\nconst index_1 = require(\"../src/index\");\nconst profile = new index_1.Profiler('example002');\nfunction main() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const title = 'latest';\n        yield profile.start(title);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const result = html_minifier_1.default.minify('<style>* { font-size: 11px }</style><p title=\"blah\" id=\"moo\">foo</p>', {\n            minifyCSS: true\n        });\n        yield profile.finish(title);\n    });\n}\nmain();\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2theW1ha293c2t5L0RvY3VtZW50cy9IaXRhYmlzL0N1cnJlbnQtV29ya3NwYWNlcy9HcmVlbklUL09ha2xlYW4vcGFja2FnZXMvcHJvZmlsZXIvZXhhbXBsZXMvZXhhbXBsZTAwMi50cyIsInNvdXJjZXMiOlsiL1VzZXJzL2theW1ha293c2t5L0RvY3VtZW50cy9IaXRhYmlzL0N1cnJlbnQtV29ya3NwYWNlcy9HcmVlbklUL09ha2xlYW4vcGFja2FnZXMvcHJvZmlsZXIvZXhhbXBsZXMvZXhhbXBsZTAwMi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLGtFQUFvQztBQUVwQyx3Q0FBdUM7QUFFdkMsTUFBTSxPQUFPLEdBQUcsSUFBSSxnQkFBUSxDQUFDLFlBQVksQ0FBQyxDQUFBO0FBRTFDLFNBQWUsSUFBSTs7UUFDbEIsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFBO1FBQ3RCLE1BQU0sT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQTtRQUMxQiw2REFBNkQ7UUFDN0QsTUFBTSxNQUFNLEdBQUcsdUJBQVEsQ0FBQyxNQUFNLENBQUMsc0VBQXNFLEVBQUU7WUFDdEcsU0FBUyxFQUFFLElBQUk7U0FDZixDQUFDLENBQUE7UUFFRixNQUFNLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUE7SUFDNUIsQ0FBQztDQUFBO0FBRUQsSUFBSSxFQUFFLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbWluaWZpZXIgZnJvbSAnaHRtbC1taW5pZmllcidcblxuaW1wb3J0IHsgUHJvZmlsZXIgfSBmcm9tICcuLi9zcmMvaW5kZXgnXG5cbmNvbnN0IHByb2ZpbGUgPSBuZXcgUHJvZmlsZXIoJ2V4YW1wbGUwMDInKVxuXG5hc3luYyBmdW5jdGlvbiBtYWluKCkge1xuXHRjb25zdCB0aXRsZSA9ICdsYXRlc3QnXG5cdGF3YWl0IHByb2ZpbGUuc3RhcnQodGl0bGUpXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcblx0Y29uc3QgcmVzdWx0ID0gbWluaWZpZXIubWluaWZ5KCc8c3R5bGU+KiB7IGZvbnQtc2l6ZTogMTFweCB9PC9zdHlsZT48cCB0aXRsZT1cImJsYWhcIiBpZD1cIm1vb1wiPmZvbzwvcD4nLCB7XG5cdFx0bWluaWZ5Q1NTOiB0cnVlXG5cdH0pXG5cblx0YXdhaXQgcHJvZmlsZS5maW5pc2godGl0bGUpXG59XG5cbm1haW4oKSJdfQ==",
    "221": "'use strict';\n\nvar CleanCSS = require('clean-css');\nvar decode = require('he').decode;\nvar HTMLParser = require('./htmlparser').HTMLParser;\nvar RelateUrl = require('relateurl');\nvar TokenChain = require('./tokenchain');\nvar UglifyJS = require('uglify-js');\nvar utils = require('./utils');\n\nfunction trimWhitespace(str) {\n  return str && str.replace(/^[ \\n\\r\\t\\f]+/, '').replace(/[ \\n\\r\\t\\f]+$/, '');\n}\n\nfunction collapseWhitespaceAll(str) {\n  // Non-breaking space is specifically handled inside the replacer function here:\n  return str && str.replace(/[ \\n\\r\\t\\f\\xA0]+/g, function(spaces) {\n    return spaces === '\\t' ? '\\t' : spaces.replace(/(^|\\xA0+)[^\\xA0]+/g, '$1 ');\n  });\n}\n\nfunction collapseWhitespace(str, options, trimLeft, trimRight, collapseAll) {\n  var lineBreakBefore = '', lineBreakAfter = '';\n\n  if (options.preserveLineBreaks) {\n    str = str.replace(/^[ \\n\\r\\t\\f]*?[\\n\\r][ \\n\\r\\t\\f]*/, function() {\n      lineBreakBefore = '\\n';\n      return '';\n    }).replace(/[ \\n\\r\\t\\f]*?[\\n\\r][ \\n\\r\\t\\f]*$/, function() {\n      lineBreakAfter = '\\n';\n      return '';\n    });\n  }\n\n  if (trimLeft) {\n    // Non-breaking space is specifically handled inside the replacer function here:\n    str = str.replace(/^[ \\n\\r\\t\\f\\xA0]+/, function(spaces) {\n      var conservative = !lineBreakBefore && options.conservativeCollapse;\n      if (conservative && spaces === '\\t') {\n        return '\\t';\n      }\n      return spaces.replace(/^[^\\xA0]+/, '').replace(/(\\xA0+)[^\\xA0]+/g, '$1 ') || (conservative ? ' ' : '');\n    });\n  }\n\n  if (trimRight) {\n    // Non-breaking space is specifically handled inside the replacer function here:\n    str = str.replace(/[ \\n\\r\\t\\f\\xA0]+$/, function(spaces) {\n      var conservative = !lineBreakAfter && options.conservativeCollapse;\n      if (conservative && spaces === '\\t') {\n        return '\\t';\n      }\n      return spaces.replace(/[^\\xA0]+(\\xA0+)/g, ' $1').replace(/[^\\xA0]+$/, '') || (conservative ? ' ' : '');\n    });\n  }\n\n  if (collapseAll) {\n    // strip non space whitespace then compress spaces to one\n    str = collapseWhitespaceAll(str);\n  }\n\n  return lineBreakBefore + str + lineBreakAfter;\n}\n\nvar createMapFromString = utils.createMapFromString;\n// non-empty tags that will maintain whitespace around them\nvar inlineTags = createMapFromString('a,abbr,acronym,b,bdi,bdo,big,button,cite,code,del,dfn,em,font,i,ins,kbd,label,mark,math,nobr,object,q,rp,rt,rtc,ruby,s,samp,select,small,span,strike,strong,sub,sup,svg,textarea,time,tt,u,var');\n// non-empty tags that will maintain whitespace within them\nvar inlineTextTags = createMapFromString('a,abbr,acronym,b,big,del,em,font,i,ins,kbd,mark,nobr,rp,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var');\n// self-closing tags that will maintain whitespace around them\nvar selfClosingInlineTags = createMapFromString('comment,img,input,wbr');\n\nfunction collapseWhitespaceSmart(str, prevTag, nextTag, options) {\n  var trimLeft = prevTag && !selfClosingInlineTags(prevTag);\n  if (trimLeft && !options.collapseInlineTagWhitespace) {\n    trimLeft = prevTag.charAt(0) === '/' ? !inlineTags(prevTag.slice(1)) : !inlineTextTags(prevTag);\n  }\n  var trimRight = nextTag && !selfClosingInlineTags(nextTag);\n  if (trimRight && !options.collapseInlineTagWhitespace) {\n    trimRight = nextTag.charAt(0) === '/' ? !inlineTextTags(nextTag.slice(1)) : !inlineTags(nextTag);\n  }\n  return collapseWhitespace(str, options, trimLeft, trimRight, prevTag && nextTag);\n}\n\nfunction isConditionalComment(text) {\n  return /^\\[if\\s[^\\]]+]|\\[endif]$/.test(text);\n}\n\nfunction isIgnoredComment(text, options) {\n  for (var i = 0, len = options.ignoreCustomComments.length; i < len; i++) {\n    if (options.ignoreCustomComments[i].test(text)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isEventAttribute(attrName, options) {\n  var patterns = options.customEventAttributes;\n  if (patterns) {\n    for (var i = patterns.length; i--;) {\n      if (patterns[i].test(attrName)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  return /^on[a-z]{3,}$/.test(attrName);\n}\n\nfunction canRemoveAttributeQuotes(value) {\n  // https://mathiasbynens.be/notes/unquoted-attribute-values\n  return /^[^ \\t\\n\\f\\r\"'`=<>]+$/.test(value);\n}\n\nfunction attributesInclude(attributes, attribute) {\n  for (var i = attributes.length; i--;) {\n    if (attributes[i].name.toLowerCase() === attribute) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isAttributeRedundant(tag, attrName, attrValue, attrs) {\n  attrValue = attrValue ? trimWhitespace(attrValue.toLowerCase()) : '';\n\n  return (\n    tag === 'script' &&\n    attrName === 'language' &&\n    attrValue === 'javascript' ||\n\n    tag === 'form' &&\n    attrName === 'method' &&\n    attrValue === 'get' ||\n\n    tag === 'input' &&\n    attrName === 'type' &&\n    attrValue === 'text' ||\n\n    tag === 'script' &&\n    attrName === 'charset' &&\n    !attributesInclude(attrs, 'src') ||\n\n    tag === 'a' &&\n    attrName === 'name' &&\n    attributesInclude(attrs, 'id') ||\n\n    tag === 'area' &&\n    attrName === 'shape' &&\n    attrValue === 'rect'\n  );\n}\n\n// https://mathiasbynens.be/demo/javascript-mime-type\n// https://developer.mozilla.org/en/docs/Web/HTML/Element/script#attr-type\nvar executableScriptsMimetypes = utils.createMap([\n  'text/javascript',\n  'text/ecmascript',\n  'text/jscript',\n  'application/javascript',\n  'application/x-javascript',\n  'application/ecmascript'\n]);\n\nfunction isScriptTypeAttribute(attrValue) {\n  attrValue = trimWhitespace(attrValue.split(/;/, 2)[0]).toLowerCase();\n  return attrValue === '' || executableScriptsMimetypes(attrValue);\n}\n\nfunction isExecutableScript(tag, attrs) {\n  if (tag !== 'script') {\n    return false;\n  }\n  for (var i = 0, len = attrs.length; i < len; i++) {\n    var attrName = attrs[i].name.toLowerCase();\n    if (attrName === 'type') {\n      return isScriptTypeAttribute(attrs[i].value);\n    }\n  }\n  return true;\n}\n\nfunction isStyleLinkTypeAttribute(attrValue) {\n  attrValue = trimWhitespace(attrValue).toLowerCase();\n  return attrValue === '' || attrValue === 'text/css';\n}\n\nfunction isStyleSheet(tag, attrs) {\n  if (tag !== 'style') {\n    return false;\n  }\n  for (var i = 0, len = attrs.length; i < len; i++) {\n    var attrName = attrs[i].name.toLowerCase();\n    if (attrName === 'type') {\n      return isStyleLinkTypeAttribute(attrs[i].value);\n    }\n  }\n  return true;\n}\n\nvar isSimpleBoolean = createMapFromString('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible');\nvar isBooleanValue = createMapFromString('true,false');\n\nfunction isBooleanAttribute(attrName, attrValue) {\n  return isSimpleBoolean(attrName) || attrName === 'draggable' && !isBooleanValue(attrValue);\n}\n\nfunction isUriTypeAttribute(attrName, tag) {\n  return (\n    /^(?:a|area|link|base)$/.test(tag) && attrName === 'href' ||\n    tag === 'img' && /^(?:src|longdesc|usemap)$/.test(attrName) ||\n    tag === 'object' && /^(?:classid|codebase|data|usemap)$/.test(attrName) ||\n    tag === 'q' && attrName === 'cite' ||\n    tag === 'blockquote' && attrName === 'cite' ||\n    (tag === 'ins' || tag === 'del') && attrName === 'cite' ||\n    tag === 'form' && attrName === 'action' ||\n    tag === 'input' && (attrName === 'src' || attrName === 'usemap') ||\n    tag === 'head' && attrName === 'profile' ||\n    tag === 'script' && (attrName === 'src' || attrName === 'for')\n  );\n}\n\nfunction isNumberTypeAttribute(attrName, tag) {\n  return (\n    /^(?:a|area|object|button)$/.test(tag) && attrName === 'tabindex' ||\n    tag === 'input' && (attrName === 'maxlength' || attrName === 'tabindex') ||\n    tag === 'select' && (attrName === 'size' || attrName === 'tabindex') ||\n    tag === 'textarea' && /^(?:rows|cols|tabindex)$/.test(attrName) ||\n    tag === 'colgroup' && attrName === 'span' ||\n    tag === 'col' && attrName === 'span' ||\n    (tag === 'th' || tag === 'td') && (attrName === 'rowspan' || attrName === 'colspan')\n  );\n}\n\nfunction isLinkType(tag, attrs, value) {\n  if (tag !== 'link') {\n    return false;\n  }\n  for (var i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i].name === 'rel' && attrs[i].value === value) {\n      return true;\n    }\n  }\n}\n\nfunction isMediaQuery(tag, attrs, attrName) {\n  return attrName === 'media' && (isLinkType(tag, attrs, 'stylesheet') || isStyleSheet(tag, attrs));\n}\n\nvar srcsetTags = createMapFromString('img,source');\n\nfunction isSrcset(attrName, tag) {\n  return attrName === 'srcset' && srcsetTags(tag);\n}\n\nfunction cleanAttributeValue(tag, attrName, attrValue, options, attrs) {\n  if (isEventAttribute(attrName, options)) {\n    attrValue = trimWhitespace(attrValue).replace(/^javascript:\\s*/i, '');\n    return options.minifyJS(attrValue, true);\n  }\n  else if (attrName === 'class') {\n    attrValue = trimWhitespace(attrValue);\n    if (options.sortClassName) {\n      attrValue = options.sortClassName(attrValue);\n    }\n    else {\n      attrValue = collapseWhitespaceAll(attrValue);\n    }\n    return attrValue;\n  }\n  else if (isUriTypeAttribute(attrName, tag)) {\n    attrValue = trimWhitespace(attrValue);\n    return isLinkType(tag, attrs, 'canonical') ? attrValue : options.minifyURLs(attrValue);\n  }\n  else if (isNumberTypeAttribute(attrName, tag)) {\n    return trimWhitespace(attrValue);\n  }\n  else if (attrName === 'style') {\n    attrValue = trimWhitespace(attrValue);\n    if (attrValue) {\n      if (/;$/.test(attrValue) && !/&#?[0-9a-zA-Z]+;$/.test(attrValue)) {\n        attrValue = attrValue.replace(/\\s*;$/, ';');\n      }\n      attrValue = options.minifyCSS(attrValue, 'inline');\n    }\n    return attrValue;\n  }\n  else if (isSrcset(attrName, tag)) {\n    // https://html.spec.whatwg.org/multipage/embedded-content.html#attr-img-srcset\n    attrValue = trimWhitespace(attrValue).split(/\\s+,\\s*|\\s*,\\s+/).map(function(candidate) {\n      var url = candidate;\n      var descriptor = '';\n      var match = candidate.match(/\\s+([1-9][0-9]*w|[0-9]+(?:\\.[0-9]+)?x)$/);\n      if (match) {\n        url = url.slice(0, -match[0].length);\n        var num = +match[1].slice(0, -1);\n        var suffix = match[1].slice(-1);\n        if (num !== 1 || suffix !== 'x') {\n          descriptor = ' ' + num + suffix;\n        }\n      }\n      return options.minifyURLs(url) + descriptor;\n    }).join(', ');\n  }\n  else if (isMetaViewport(tag, attrs) && attrName === 'content') {\n    attrValue = attrValue.replace(/\\s+/g, '').replace(/[0-9]+\\.[0-9]+/g, function(numString) {\n      // \"0.90000\" -> \"0.9\"\n      // \"1.0\" -> \"1\"\n      // \"1.0001\" -> \"1.0001\" (unchanged)\n      return (+numString).toString();\n    });\n  }\n  else if (isContentSecurityPolicy(tag, attrs) && attrName.toLowerCase() === 'content') {\n    return collapseWhitespaceAll(attrValue);\n  }\n  else if (options.customAttrCollapse && options.customAttrCollapse.test(attrName)) {\n    attrValue = attrValue.replace(/\\n+|\\r+|\\s{2,}/g, '');\n  }\n  else if (tag === 'script' && attrName === 'type') {\n    attrValue = trimWhitespace(attrValue.replace(/\\s*;\\s*/g, ';'));\n  }\n  else if (isMediaQuery(tag, attrs, attrName)) {\n    attrValue = trimWhitespace(attrValue);\n    return options.minifyCSS(attrValue, 'media');\n  }\n  return attrValue;\n}\n\nfunction isMetaViewport(tag, attrs) {\n  if (tag !== 'meta') {\n    return false;\n  }\n  for (var i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i].name === 'name' && attrs[i].value === 'viewport') {\n      return true;\n    }\n  }\n}\n\nfunction isContentSecurityPolicy(tag, attrs) {\n  if (tag !== 'meta') {\n    return false;\n  }\n  for (var i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i].name.toLowerCase() === 'http-equiv' && attrs[i].value.toLowerCase() === 'content-security-policy') {\n      return true;\n    }\n  }\n}\n\nfunction ignoreCSS(id) {\n  return '/* clean-css ignore:start */' + id + '/* clean-css ignore:end */';\n}\n\n// Wrap CSS declarations for CleanCSS > 3.x\n// See https://github.com/jakubpawlowicz/clean-css/issues/418\nfunction wrapCSS(text, type) {\n  switch (type) {\n    case 'inline':\n      return '*{' + text + '}';\n    case 'media':\n      return '@media ' + text + '{a{top:0}}';\n    default:\n      return text;\n  }\n}\n\nfunction unwrapCSS(text, type) {\n  var matches;\n  switch (type) {\n    case 'inline':\n      matches = text.match(/^\\*\\{([\\s\\S]*)\\}$/);\n      break;\n    case 'media':\n      matches = text.match(/^@media ([\\s\\S]*?)\\s*{[\\s\\S]*}$/);\n      break;\n  }\n  return matches ? matches[1] : text;\n}\n\nfunction cleanConditionalComment(comment, options) {\n  return options.processConditionalComments ? comment.replace(/^(\\[if\\s[^\\]]+]>)([\\s\\S]*?)(<!\\[endif])$/, function(match, prefix, text, suffix) {\n    return prefix + minify(text, options, true) + suffix;\n  }) : comment;\n}\n\nfunction processScript(text, options, currentAttrs) {\n  for (var i = 0, len = currentAttrs.length; i < len; i++) {\n    if (currentAttrs[i].name.toLowerCase() === 'type' &&\n        options.processScripts.indexOf(currentAttrs[i].value) > -1) {\n      return minify(text, options);\n    }\n  }\n  return text;\n}\n\n// Tag omission rules from https://html.spec.whatwg.org/multipage/syntax.html#optional-tags\n// with the following deviations:\n// - retain <body> if followed by <noscript>\n// - </rb>, </rt>, </rtc>, </rp> & </tfoot> follow https://www.w3.org/TR/html5/syntax.html#optional-tags\n// - retain all tags which are adjacent to non-standard HTML tags\nvar optionalStartTags = createMapFromString('html,head,body,colgroup,tbody');\nvar optionalEndTags = createMapFromString('html,head,body,li,dt,dd,p,rb,rt,rtc,rp,optgroup,option,colgroup,caption,thead,tbody,tfoot,tr,td,th');\nvar headerTags = createMapFromString('meta,link,script,style,template,noscript');\nvar descriptionTags = createMapFromString('dt,dd');\nvar pBlockTags = createMapFromString('address,article,aside,blockquote,details,div,dl,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,hr,main,menu,nav,ol,p,pre,section,table,ul');\nvar pInlineTags = createMapFromString('a,audio,del,ins,map,noscript,video');\nvar rubyTags = createMapFromString('rb,rt,rtc,rp');\nvar rtcTag = createMapFromString('rb,rtc,rp');\nvar optionTag = createMapFromString('option,optgroup');\nvar tableContentTags = createMapFromString('tbody,tfoot');\nvar tableSectionTags = createMapFromString('thead,tbody,tfoot');\nvar cellTags = createMapFromString('td,th');\nvar topLevelTags = createMapFromString('html,head,body');\nvar compactTags = createMapFromString('html,body');\nvar looseTags = createMapFromString('head,colgroup,caption');\nvar trailingTags = createMapFromString('dt,thead');\nvar htmlTags = createMapFromString('a,abbr,acronym,address,applet,area,article,aside,audio,b,base,basefont,bdi,bdo,bgsound,big,blink,blockquote,body,br,button,canvas,caption,center,cite,code,col,colgroup,command,content,data,datalist,dd,del,details,dfn,dialog,dir,div,dl,dt,element,em,embed,fieldset,figcaption,figure,font,footer,form,frame,frameset,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,i,iframe,image,img,input,ins,isindex,kbd,keygen,label,legend,li,link,listing,main,map,mark,marquee,menu,menuitem,meta,meter,multicol,nav,nobr,noembed,noframes,noscript,object,ol,optgroup,option,output,p,param,picture,plaintext,pre,progress,q,rb,rp,rt,rtc,ruby,s,samp,script,section,select,shadow,small,source,spacer,span,strike,strong,style,sub,summary,sup,table,tbody,td,template,textarea,tfoot,th,thead,time,title,tr,track,tt,u,ul,var,video,wbr,xmp');\n\nfunction canRemoveParentTag(optionalStartTag, tag) {\n  switch (optionalStartTag) {\n    case 'html':\n    case 'head':\n      return true;\n    case 'body':\n      return !headerTags(tag);\n    case 'colgroup':\n      return tag === 'col';\n    case 'tbody':\n      return tag === 'tr';\n  }\n  return false;\n}\n\nfunction isStartTagMandatory(optionalEndTag, tag) {\n  switch (tag) {\n    case 'colgroup':\n      return optionalEndTag === 'colgroup';\n    case 'tbody':\n      return tableSectionTags(optionalEndTag);\n  }\n  return false;\n}\n\nfunction canRemovePrecedingTag(optionalEndTag, tag) {\n  switch (optionalEndTag) {\n    case 'html':\n    case 'head':\n    case 'body':\n    case 'colgroup':\n    case 'caption':\n      return true;\n    case 'li':\n    case 'optgroup':\n    case 'tr':\n      return tag === optionalEndTag;\n    case 'dt':\n    case 'dd':\n      return descriptionTags(tag);\n    case 'p':\n      return pBlockTags(tag);\n    case 'rb':\n    case 'rt':\n    case 'rp':\n      return rubyTags(tag);\n    case 'rtc':\n      return rtcTag(tag);\n    case 'option':\n      return optionTag(tag);\n    case 'thead':\n    case 'tbody':\n      return tableContentTags(tag);\n    case 'tfoot':\n      return tag === 'tbody';\n    case 'td':\n    case 'th':\n      return cellTags(tag);\n  }\n  return false;\n}\n\nvar reEmptyAttribute = new RegExp(\n  '^(?:class|id|style|title|lang|dir|on(?:focus|blur|change|click|dblclick|mouse(' +\n    '?:down|up|over|move|out)|key(?:press|down|up)))$');\n\nfunction canDeleteEmptyAttribute(tag, attrName, attrValue, options) {\n  var isValueEmpty = !attrValue || /^\\s*$/.test(attrValue);\n  if (!isValueEmpty) {\n    return false;\n  }\n  if (typeof options.removeEmptyAttributes === 'function') {\n    return options.removeEmptyAttributes(attrName, tag);\n  }\n  return tag === 'input' && attrName === 'value' || reEmptyAttribute.test(attrName);\n}\n\nfunction hasAttrName(name, attrs) {\n  for (var i = attrs.length - 1; i >= 0; i--) {\n    if (attrs[i].name === name) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction canRemoveElement(tag, attrs) {\n  switch (tag) {\n    case 'textarea':\n      return false;\n    case 'audio':\n    case 'script':\n    case 'video':\n      if (hasAttrName('src', attrs)) {\n        return false;\n      }\n      break;\n    case 'iframe':\n      if (hasAttrName('src', attrs) || hasAttrName('srcdoc', attrs)) {\n        return false;\n      }\n      break;\n    case 'object':\n      if (hasAttrName('data', attrs)) {\n        return false;\n      }\n      break;\n    case 'applet':\n      if (hasAttrName('code', attrs)) {\n        return false;\n      }\n      break;\n  }\n  return true;\n}\n\nfunction canCollapseWhitespace(tag) {\n  return !/^(?:script|style|pre|textarea)$/.test(tag);\n}\n\nfunction canTrimWhitespace(tag) {\n  return !/^(?:pre|textarea)$/.test(tag);\n}\n\nfunction normalizeAttr(attr, attrs, tag, options) {\n  var attrName = options.name(attr.name),\n      attrValue = attr.value;\n\n  if (options.decodeEntities && attrValue) {\n    attrValue = decode(attrValue, { isAttributeValue: true });\n  }\n\n  if (options.removeRedundantAttributes &&\n    isAttributeRedundant(tag, attrName, attrValue, attrs) ||\n    options.removeScriptTypeAttributes && tag === 'script' &&\n    attrName === 'type' && isScriptTypeAttribute(attrValue) ||\n    options.removeStyleLinkTypeAttributes && (tag === 'style' || tag === 'link') &&\n    attrName === 'type' && isStyleLinkTypeAttribute(attrValue)) {\n    return;\n  }\n\n  if (attrValue) {\n    attrValue = cleanAttributeValue(tag, attrName, attrValue, options, attrs);\n  }\n\n  if (options.removeEmptyAttributes &&\n      canDeleteEmptyAttribute(tag, attrName, attrValue, options)) {\n    return;\n  }\n\n  if (options.decodeEntities && attrValue) {\n    attrValue = attrValue.replace(/&(#?[0-9a-zA-Z]+;)/g, '&amp;$1');\n  }\n\n  return {\n    attr: attr,\n    name: attrName,\n    value: attrValue\n  };\n}\n\nfunction buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr) {\n  var attrName = normalized.name,\n      attrValue = normalized.value,\n      attr = normalized.attr,\n      attrQuote = attr.quote,\n      attrFragment,\n      emittedAttrValue;\n\n  if (typeof attrValue !== 'undefined' && (!options.removeAttributeQuotes ||\n      ~attrValue.indexOf(uidAttr) || !canRemoveAttributeQuotes(attrValue))) {\n    if (!options.preventAttributesEscaping) {\n      if (typeof options.quoteCharacter === 'undefined') {\n        var apos = (attrValue.match(/'/g) || []).length;\n        var quot = (attrValue.match(/\"/g) || []).length;\n        attrQuote = apos < quot ? '\\'' : '\"';\n      }\n      else {\n        attrQuote = options.quoteCharacter === '\\'' ? '\\'' : '\"';\n      }\n      if (attrQuote === '\"') {\n        attrValue = attrValue.replace(/\"/g, '&#34;');\n      }\n      else {\n        attrValue = attrValue.replace(/'/g, '&#39;');\n      }\n    }\n    emittedAttrValue = attrQuote + attrValue + attrQuote;\n    if (!isLast && !options.removeTagWhitespace) {\n      emittedAttrValue += ' ';\n    }\n  }\n  // make sure trailing slash is not interpreted as HTML self-closing tag\n  else if (isLast && !hasUnarySlash && !/\\/$/.test(attrValue)) {\n    emittedAttrValue = attrValue;\n  }\n  else {\n    emittedAttrValue = attrValue + ' ';\n  }\n\n  if (typeof attrValue === 'undefined' || options.collapseBooleanAttributes &&\n      isBooleanAttribute(attrName.toLowerCase(), attrValue.toLowerCase())) {\n    attrFragment = attrName;\n    if (!isLast) {\n      attrFragment += ' ';\n    }\n  }\n  else {\n    attrFragment = attrName + attr.customAssign + emittedAttrValue;\n  }\n\n  return attr.customOpen + attrFragment + attr.customClose;\n}\n\nfunction identity(value) {\n  return value;\n}\n\nfunction processOptions(values) {\n  var options = {\n    name: function(name) {\n      return name.toLowerCase();\n    },\n    canCollapseWhitespace: canCollapseWhitespace,\n    canTrimWhitespace: canTrimWhitespace,\n    html5: true,\n    ignoreCustomComments: [/^!/],\n    ignoreCustomFragments: [\n      /<%[\\s\\S]*?%>/,\n      /<\\?[\\s\\S]*?\\?>/\n    ],\n    includeAutoGeneratedTags: true,\n    log: identity,\n    minifyCSS: identity,\n    minifyJS: identity,\n    minifyURLs: identity\n  };\n  Object.keys(values).forEach(function(key) {\n    var value = values[key];\n    if (key === 'caseSensitive') {\n      if (value) {\n        options.name = identity;\n      }\n    }\n    else if (key === 'log') {\n      if (typeof value === 'function') {\n        options.log = value;\n      }\n    }\n    else if (key === 'minifyCSS' && typeof value !== 'function') {\n      if (!value) {\n        return;\n      }\n      if (typeof value !== 'object') {\n        value = {};\n      }\n      options.minifyCSS = function(text, type) {\n        text = text.replace(/(url\\s*\\(\\s*)(\"|'|)(.*?)\\2(\\s*\\))/ig, function(match, prefix, quote, url, suffix) {\n          return prefix + quote + options.minifyURLs(url) + quote + suffix;\n        });\n        var cleanCssOutput = new CleanCSS(value).minify(wrapCSS(text, type));\n        if (cleanCssOutput.errors.length > 0) {\n          cleanCssOutput.errors.forEach(options.log);\n          return text;\n        }\n        return unwrapCSS(cleanCssOutput.styles, type);\n      };\n    }\n    else if (key === 'minifyJS' && typeof value !== 'function') {\n      if (!value) {\n        return;\n      }\n      if (typeof value !== 'object') {\n        value = {};\n      }\n      (value.parse || (value.parse = {})).bare_returns = false;\n      options.minifyJS = function(text, inline) {\n        var start = text.match(/^\\s*<!--.*/);\n        var code = start ? text.slice(start[0].length).replace(/\\n\\s*-->\\s*$/, '') : text;\n        value.parse.bare_returns = inline;\n        var result = UglifyJS.minify(code, value);\n        if (result.error) {\n          options.log(result.error);\n          return text;\n        }\n        return result.code.replace(/;$/, '');\n      };\n    }\n    else if (key === 'minifyURLs' && typeof value !== 'function') {\n      if (!value) {\n        return;\n      }\n      if (typeof value === 'string') {\n        value = { site: value };\n      }\n      else if (typeof value !== 'object') {\n        value = {};\n      }\n      options.minifyURLs = function(text) {\n        try {\n          return RelateUrl.relate(text, value);\n        }\n        catch (err) {\n          options.log(err);\n          return text;\n        }\n      };\n    }\n    else {\n      options[key] = value;\n    }\n  });\n  return options;\n}\n\nfunction uniqueId(value) {\n  var id;\n  do {\n    id = Math.random().toString(36).replace(/^0\\.[0-9]*/, '');\n  } while (~value.indexOf(id));\n  return id;\n}\n\nvar specialContentTags = createMapFromString('script,style');\n\nfunction createSortFns(value, options, uidIgnore, uidAttr) {\n  var attrChains = options.sortAttributes && Object.create(null);\n  var classChain = options.sortClassName && new TokenChain();\n\n  function attrNames(attrs) {\n    return attrs.map(function(attr) {\n      return options.name(attr.name);\n    });\n  }\n\n  function shouldSkipUID(token, uid) {\n    return !uid || token.indexOf(uid) === -1;\n  }\n\n  function shouldSkipUIDs(token) {\n    return shouldSkipUID(token, uidIgnore) && shouldSkipUID(token, uidAttr);\n  }\n\n  function scan(input) {\n    var currentTag, currentType;\n    new HTMLParser(input, {\n      start: function(tag, attrs) {\n        if (attrChains) {\n          if (!attrChains[tag]) {\n            attrChains[tag] = new TokenChain();\n          }\n          attrChains[tag].add(attrNames(attrs).filter(shouldSkipUIDs));\n        }\n        for (var i = 0, len = attrs.length; i < len; i++) {\n          var attr = attrs[i];\n          if (classChain && attr.value && options.name(attr.name) === 'class') {\n            classChain.add(trimWhitespace(attr.value).split(/[ \\t\\n\\f\\r]+/).filter(shouldSkipUIDs));\n          }\n          else if (options.processScripts && attr.name.toLowerCase() === 'type') {\n            currentTag = tag;\n            currentType = attr.value;\n          }\n        }\n      },\n      end: function() {\n        currentTag = '';\n      },\n      chars: function(text) {\n        if (options.processScripts && specialContentTags(currentTag) &&\n            options.processScripts.indexOf(currentType) > -1) {\n          scan(text);\n        }\n      }\n    });\n  }\n\n  var log = options.log;\n  options.log = identity;\n  options.sortAttributes = false;\n  options.sortClassName = false;\n  scan(minify(value, options));\n  options.log = log;\n  if (attrChains) {\n    var attrSorters = Object.create(null);\n    for (var tag in attrChains) {\n      attrSorters[tag] = attrChains[tag].createSorter();\n    }\n    options.sortAttributes = function(tag, attrs) {\n      var sorter = attrSorters[tag];\n      if (sorter) {\n        var attrMap = Object.create(null);\n        var names = attrNames(attrs);\n        names.forEach(function(name, index) {\n          (attrMap[name] || (attrMap[name] = [])).push(attrs[index]);\n        });\n        sorter.sort(names).forEach(function(name, index) {\n          attrs[index] = attrMap[name].shift();\n        });\n      }\n    };\n  }\n  if (classChain) {\n    var sorter = classChain.createSorter();\n    options.sortClassName = function(value) {\n      return sorter.sort(value.split(/[ \\n\\f\\r]+/)).join(' ');\n    };\n  }\n}\n\nfunction minify(value, options, partialMarkup) {\n  if (options.collapseWhitespace) {\n    value = collapseWhitespace(value, options, true, true);\n  }\n\n  var buffer = [],\n      charsPrevTag,\n      currentChars = '',\n      hasChars,\n      currentTag = '',\n      currentAttrs = [],\n      stackNoTrimWhitespace = [],\n      stackNoCollapseWhitespace = [],\n      optionalStartTag = '',\n      optionalEndTag = '',\n      ignoredMarkupChunks = [],\n      ignoredCustomMarkupChunks = [],\n      uidIgnore,\n      uidAttr,\n      uidPattern;\n\n  // temporarily replace ignored chunks with comments,\n  // so that we don't have to worry what's there.\n  // for all we care there might be\n  // completely-horribly-broken-alien-non-html-emoj-cthulhu-filled content\n  value = value.replace(/<!-- htmlmin:ignore -->([\\s\\S]*?)<!-- htmlmin:ignore -->/g, function(match, group1) {\n    if (!uidIgnore) {\n      uidIgnore = uniqueId(value);\n      var pattern = new RegExp('^' + uidIgnore + '([0-9]+)$');\n      if (options.ignoreCustomComments) {\n        options.ignoreCustomComments = options.ignoreCustomComments.slice();\n      }\n      else {\n        options.ignoreCustomComments = [];\n      }\n      options.ignoreCustomComments.push(pattern);\n    }\n    var token = '<!--' + uidIgnore + ignoredMarkupChunks.length + '-->';\n    ignoredMarkupChunks.push(group1);\n    return token;\n  });\n\n  var customFragments = options.ignoreCustomFragments.map(function(re) {\n    return re.source;\n  });\n  if (customFragments.length) {\n    var reCustomIgnore = new RegExp('\\\\s*(?:' + customFragments.join('|') + ')+\\\\s*', 'g');\n    // temporarily replace custom ignored fragments with unique attributes\n    value = value.replace(reCustomIgnore, function(match) {\n      if (!uidAttr) {\n        uidAttr = uniqueId(value);\n        uidPattern = new RegExp('(\\\\s*)' + uidAttr + '([0-9]+)' + uidAttr + '(\\\\s*)', 'g');\n        if (options.minifyCSS) {\n          options.minifyCSS = (function(fn) {\n            return function(text, type) {\n              text = text.replace(uidPattern, function(match, prefix, index) {\n                var chunks = ignoredCustomMarkupChunks[+index];\n                return chunks[1] + uidAttr + index + uidAttr + chunks[2];\n              });\n              var ids = [];\n              new CleanCSS().minify(wrapCSS(text, type)).warnings.forEach(function(warning) {\n                var match = uidPattern.exec(warning);\n                if (match) {\n                  var id = uidAttr + match[2] + uidAttr;\n                  text = text.replace(id, ignoreCSS(id));\n                  ids.push(id);\n                }\n              });\n              text = fn(text, type);\n              ids.forEach(function(id) {\n                text = text.replace(ignoreCSS(id), id);\n              });\n              return text;\n            };\n          })(options.minifyCSS);\n        }\n        if (options.minifyJS) {\n          options.minifyJS = (function(fn) {\n            return function(text, type) {\n              return fn(text.replace(uidPattern, function(match, prefix, index) {\n                var chunks = ignoredCustomMarkupChunks[+index];\n                return chunks[1] + uidAttr + index + uidAttr + chunks[2];\n              }), type);\n            };\n          })(options.minifyJS);\n        }\n      }\n      var token = uidAttr + ignoredCustomMarkupChunks.length + uidAttr;\n      ignoredCustomMarkupChunks.push(/^(\\s*)[\\s\\S]*?(\\s*)$/.exec(match));\n      return '\\t' + token + '\\t';\n    });\n  }\n\n  if (options.sortAttributes && typeof options.sortAttributes !== 'function' ||\n      options.sortClassName && typeof options.sortClassName !== 'function') {\n    createSortFns(value, options, uidIgnore, uidAttr);\n  }\n\n  function _canCollapseWhitespace(tag, attrs) {\n    return options.canCollapseWhitespace(tag, attrs, canCollapseWhitespace);\n  }\n\n  function _canTrimWhitespace(tag, attrs) {\n    return options.canTrimWhitespace(tag, attrs, canTrimWhitespace);\n  }\n\n  function removeStartTag() {\n    var index = buffer.length - 1;\n    while (index > 0 && !/^<[^/!]/.test(buffer[index])) {\n      index--;\n    }\n    buffer.length = Math.max(0, index);\n  }\n\n  function removeEndTag() {\n    var index = buffer.length - 1;\n    while (index > 0 && !/^<\\//.test(buffer[index])) {\n      index--;\n    }\n    buffer.length = Math.max(0, index);\n  }\n\n  // look for trailing whitespaces, bypass any inline tags\n  function trimTrailingWhitespace(index, nextTag) {\n    for (var endTag = null; index >= 0 && _canTrimWhitespace(endTag); index--) {\n      var str = buffer[index];\n      var match = str.match(/^<\\/([\\w:-]+)>$/);\n      if (match) {\n        endTag = match[1];\n      }\n      else if (/>$/.test(str) || (buffer[index] = collapseWhitespaceSmart(str, null, nextTag, options))) {\n        break;\n      }\n    }\n  }\n\n  // look for trailing whitespaces from previously processed text\n  // which may not be trimmed due to a following comment or an empty\n  // element which has now been removed\n  function squashTrailingWhitespace(nextTag) {\n    var charsIndex = buffer.length - 1;\n    if (buffer.length > 1) {\n      var item = buffer[buffer.length - 1];\n      if (/^(?:<!|$)/.test(item) && item.indexOf(uidIgnore) === -1) {\n        charsIndex--;\n      }\n    }\n    trimTrailingWhitespace(charsIndex, nextTag);\n  }\n\n  new HTMLParser(value, {\n    partialMarkup: partialMarkup,\n    continueOnParseError: options.continueOnParseError,\n    customAttrAssign: options.customAttrAssign,\n    customAttrSurround: options.customAttrSurround,\n    html5: options.html5,\n\n    start: function(tag, attrs, unary, unarySlash, autoGenerated) {\n      if (tag.toLowerCase() === 'svg') {\n        options = Object.create(options);\n        options.caseSensitive = true;\n        options.keepClosingSlash = true;\n        options.name = identity;\n      }\n      tag = options.name(tag);\n      currentTag = tag;\n      charsPrevTag = tag;\n      if (!inlineTextTags(tag)) {\n        currentChars = '';\n      }\n      hasChars = false;\n      currentAttrs = attrs;\n\n      var optional = options.removeOptionalTags;\n      if (optional) {\n        var htmlTag = htmlTags(tag);\n        // <html> may be omitted if first thing inside is not comment\n        // <head> may be omitted if first thing inside is an element\n        // <body> may be omitted if first thing inside is not space, comment, <meta>, <link>, <script>, <style> or <template>\n        // <colgroup> may be omitted if first thing inside is <col>\n        // <tbody> may be omitted if first thing inside is <tr>\n        if (htmlTag && canRemoveParentTag(optionalStartTag, tag)) {\n          removeStartTag();\n        }\n        optionalStartTag = '';\n        // end-tag-followed-by-start-tag omission rules\n        if (htmlTag && canRemovePrecedingTag(optionalEndTag, tag)) {\n          removeEndTag();\n          // <colgroup> cannot be omitted if preceding </colgroup> is omitted\n          // <tbody> cannot be omitted if preceding </tbody>, </thead> or </tfoot> is omitted\n          optional = !isStartTagMandatory(optionalEndTag, tag);\n        }\n        optionalEndTag = '';\n      }\n\n      // set whitespace flags for nested tags (eg. <code> within a <pre>)\n      if (options.collapseWhitespace) {\n        if (!stackNoTrimWhitespace.length) {\n          squashTrailingWhitespace(tag);\n        }\n        if (!unary) {\n          if (!_canTrimWhitespace(tag, attrs) || stackNoTrimWhitespace.length) {\n            stackNoTrimWhitespace.push(tag);\n          }\n          if (!_canCollapseWhitespace(tag, attrs) || stackNoCollapseWhitespace.length) {\n            stackNoCollapseWhitespace.push(tag);\n          }\n        }\n      }\n\n      var openTag = '<' + tag;\n      var hasUnarySlash = unarySlash && options.keepClosingSlash;\n\n      buffer.push(openTag);\n\n      if (options.sortAttributes) {\n        options.sortAttributes(tag, attrs);\n      }\n\n      var parts = [];\n      for (var i = attrs.length, isLast = true; --i >= 0;) {\n        var normalized = normalizeAttr(attrs[i], attrs, tag, options);\n        if (normalized) {\n          parts.unshift(buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr));\n          isLast = false;\n        }\n      }\n      if (parts.length > 0) {\n        buffer.push(' ');\n        buffer.push.apply(buffer, parts);\n      }\n      // start tag must never be omitted if it has any attributes\n      else if (optional && optionalStartTags(tag)) {\n        optionalStartTag = tag;\n      }\n\n      buffer.push(buffer.pop() + (hasUnarySlash ? '/' : '') + '>');\n\n      if (autoGenerated && !options.includeAutoGeneratedTags) {\n        removeStartTag();\n        optionalStartTag = '';\n      }\n    },\n    end: function(tag, attrs, autoGenerated) {\n      if (tag.toLowerCase() === 'svg') {\n        options = Object.getPrototypeOf(options);\n      }\n      tag = options.name(tag);\n\n      // check if current tag is in a whitespace stack\n      if (options.collapseWhitespace) {\n        if (stackNoTrimWhitespace.length) {\n          if (tag === stackNoTrimWhitespace[stackNoTrimWhitespace.length - 1]) {\n            stackNoTrimWhitespace.pop();\n          }\n        }\n        else {\n          squashTrailingWhitespace('/' + tag);\n        }\n        if (stackNoCollapseWhitespace.length &&\n          tag === stackNoCollapseWhitespace[stackNoCollapseWhitespace.length - 1]) {\n          stackNoCollapseWhitespace.pop();\n        }\n      }\n\n      var isElementEmpty = false;\n      if (tag === currentTag) {\n        currentTag = '';\n        isElementEmpty = !hasChars;\n      }\n\n      if (options.removeOptionalTags) {\n        // <html>, <head> or <body> may be omitted if the element is empty\n        if (isElementEmpty && topLevelTags(optionalStartTag)) {\n          removeStartTag();\n        }\n        optionalStartTag = '';\n        // </html> or </body> may be omitted if not followed by comment\n        // </head> may be omitted if not followed by space or comment\n        // </p> may be omitted if no more content in non-</a> parent\n        // except for </dt> or </thead>, end tags may be omitted if no more content in parent element\n        if (htmlTags(tag) && optionalEndTag && !trailingTags(optionalEndTag) && (optionalEndTag !== 'p' || !pInlineTags(tag))) {\n          removeEndTag();\n        }\n        optionalEndTag = optionalEndTags(tag) ? tag : '';\n      }\n\n      if (options.removeEmptyElements && isElementEmpty && canRemoveElement(tag, attrs)) {\n        // remove last \"element\" from buffer\n        removeStartTag();\n        optionalStartTag = '';\n        optionalEndTag = '';\n      }\n      else {\n        if (autoGenerated && !options.includeAutoGeneratedTags) {\n          optionalEndTag = '';\n        }\n        else {\n          buffer.push('</' + tag + '>');\n        }\n        charsPrevTag = '/' + tag;\n        if (!inlineTags(tag)) {\n          currentChars = '';\n        }\n        else if (isElementEmpty) {\n          currentChars += '|';\n        }\n      }\n    },\n    chars: function(text, prevTag, nextTag) {\n      prevTag = prevTag === '' ? 'comment' : prevTag;\n      nextTag = nextTag === '' ? 'comment' : nextTag;\n      if (options.decodeEntities && text && !specialContentTags(currentTag)) {\n        text = decode(text);\n      }\n      if (options.collapseWhitespace) {\n        if (!stackNoTrimWhitespace.length) {\n          if (prevTag === 'comment') {\n            var prevComment = buffer[buffer.length - 1];\n            if (prevComment.indexOf(uidIgnore) === -1) {\n              if (!prevComment) {\n                prevTag = charsPrevTag;\n              }\n              if (buffer.length > 1 && (!prevComment || !options.conservativeCollapse && / $/.test(currentChars))) {\n                var charsIndex = buffer.length - 2;\n                buffer[charsIndex] = buffer[charsIndex].replace(/\\s+$/, function(trailingSpaces) {\n                  text = trailingSpaces + text;\n                  return '';\n                });\n              }\n            }\n          }\n          if (prevTag) {\n            if (prevTag === '/nobr' || prevTag === 'wbr') {\n              if (/^\\s/.test(text)) {\n                var tagIndex = buffer.length - 1;\n                while (tagIndex > 0 && buffer[tagIndex].lastIndexOf('<' + prevTag) !== 0) {\n                  tagIndex--;\n                }\n                trimTrailingWhitespace(tagIndex - 1, 'br');\n              }\n            }\n            else if (inlineTextTags(prevTag.charAt(0) === '/' ? prevTag.slice(1) : prevTag)) {\n              text = collapseWhitespace(text, options, /(?:^|\\s)$/.test(currentChars));\n            }\n          }\n          if (prevTag || nextTag) {\n            text = collapseWhitespaceSmart(text, prevTag, nextTag, options);\n          }\n          else {\n            text = collapseWhitespace(text, options, true, true);\n          }\n          if (!text && /\\s$/.test(currentChars) && prevTag && prevTag.charAt(0) === '/') {\n            trimTrailingWhitespace(buffer.length - 1, nextTag);\n          }\n        }\n        if (!stackNoCollapseWhitespace.length && nextTag !== 'html' && !(prevTag && nextTag)) {\n          text = collapseWhitespace(text, options, false, false, true);\n        }\n      }\n      if (options.processScripts && specialContentTags(currentTag)) {\n        text = processScript(text, options, currentAttrs);\n      }\n      if (isExecutableScript(currentTag, currentAttrs)) {\n        text = options.minifyJS(text);\n      }\n      if (isStyleSheet(currentTag, currentAttrs)) {\n        text = options.minifyCSS(text);\n      }\n      if (options.removeOptionalTags && text) {\n        // <html> may be omitted if first thing inside is not comment\n        // <body> may be omitted if first thing inside is not space, comment, <meta>, <link>, <script>, <style> or <template>\n        if (optionalStartTag === 'html' || optionalStartTag === 'body' && !/^\\s/.test(text)) {\n          removeStartTag();\n        }\n        optionalStartTag = '';\n        // </html> or </body> may be omitted if not followed by comment\n        // </head>, </colgroup> or </caption> may be omitted if not followed by space or comment\n        if (compactTags(optionalEndTag) || looseTags(optionalEndTag) && !/^\\s/.test(text)) {\n          removeEndTag();\n        }\n        optionalEndTag = '';\n      }\n      charsPrevTag = /^\\s*$/.test(text) ? prevTag : 'comment';\n      if (options.decodeEntities && text && !specialContentTags(currentTag)) {\n        // Escape any `&` symbols that start either:\n        // 1) a legacy named character reference (i.e. one that doesn't end with `;`)\n        // 2) or any other character reference (i.e. one that does end with `;`)\n        // Note that `&` can be escaped as `&amp`, without the semi-colon.\n        // https://mathiasbynens.be/notes/ambiguous-ampersands\n        text = text.replace(/&((?:Iacute|aacute|uacute|plusmn|Otilde|otilde|agrave|Agrave|Yacute|yacute|Oslash|oslash|atilde|Atilde|brvbar|ccedil|Ccedil|Ograve|curren|divide|eacute|Eacute|ograve|Oacute|egrave|Egrave|Ugrave|frac12|frac14|frac34|ugrave|oacute|iacute|Ntilde|ntilde|Uacute|middot|igrave|Igrave|iquest|Aacute|cedil|laquo|micro|iexcl|Icirc|icirc|acirc|Ucirc|Ecirc|ocirc|Ocirc|ecirc|ucirc|Aring|aring|AElig|aelig|acute|pound|raquo|Acirc|times|THORN|szlig|thorn|COPY|auml|ordf|ordm|Uuml|macr|uuml|Auml|ouml|Ouml|para|nbsp|euml|quot|QUOT|Euml|yuml|cent|sect|copy|sup1|sup2|sup3|iuml|Iuml|ETH|shy|reg|not|yen|amp|AMP|REG|uml|eth|deg|gt|GT|LT|lt)(?!;)|(?:#?[0-9a-zA-Z]+;))/g, '&amp$1').replace(/</g, '&lt;');\n      }\n      if (uidPattern && options.collapseWhitespace && stackNoTrimWhitespace.length) {\n        text = text.replace(uidPattern, function(match, prefix, index) {\n          return ignoredCustomMarkupChunks[+index][0];\n        });\n      }\n      currentChars += text;\n      if (text) {\n        hasChars = true;\n      }\n      buffer.push(text);\n    },\n    comment: function(text, nonStandard) {\n      var prefix = nonStandard ? '<!' : '<!--';\n      var suffix = nonStandard ? '>' : '-->';\n      if (isConditionalComment(text)) {\n        text = prefix + cleanConditionalComment(text, options) + suffix;\n      }\n      else if (options.removeComments) {\n        if (isIgnoredComment(text, options)) {\n          text = '<!--' + text + '-->';\n        }\n        else {\n          text = '';\n        }\n      }\n      else {\n        text = prefix + text + suffix;\n      }\n      if (options.removeOptionalTags && text) {\n        // preceding comments suppress tag omissions\n        optionalStartTag = '';\n        optionalEndTag = '';\n      }\n      buffer.push(text);\n    },\n    doctype: function(doctype) {\n      buffer.push(options.useShortDoctype ? '<!doctype' +\n        (options.removeTagWhitespace ? '' : ' ') + 'html>' :\n        collapseWhitespaceAll(doctype));\n    }\n  });\n\n  if (options.removeOptionalTags) {\n    // <html> may be omitted if first thing inside is not comment\n    // <head> or <body> may be omitted if empty\n    if (topLevelTags(optionalStartTag)) {\n      removeStartTag();\n    }\n    // except for </dt> or </thead>, end tags may be omitted if no more content in parent element\n    if (optionalEndTag && !trailingTags(optionalEndTag)) {\n      removeEndTag();\n    }\n  }\n  if (options.collapseWhitespace) {\n    squashTrailingWhitespace('br');\n  }\n\n  return joinResultSegments(buffer, options, uidPattern ? function(str) {\n    return str.replace(uidPattern, function(match, prefix, index, suffix) {\n      var chunk = ignoredCustomMarkupChunks[+index][0];\n      if (options.collapseWhitespace) {\n        if (prefix !== '\\t') {\n          chunk = prefix + chunk;\n        }\n        if (suffix !== '\\t') {\n          chunk += suffix;\n        }\n        return collapseWhitespace(chunk, {\n          preserveLineBreaks: options.preserveLineBreaks,\n          conservativeCollapse: !options.trimCustomFragments\n        }, /^[ \\n\\r\\t\\f]/.test(chunk), /[ \\n\\r\\t\\f]$/.test(chunk));\n      }\n      return chunk;\n    });\n  } : identity, uidIgnore ? function(str) {\n    return str.replace(new RegExp('<!--' + uidIgnore + '([0-9]+)-->', 'g'), function(match, index) {\n      return ignoredMarkupChunks[+index];\n    });\n  } : identity);\n}\n\nfunction joinResultSegments(results, options, restoreCustom, restoreIgnore) {\n  var str;\n  var maxLineLength = options.maxLineLength;\n  if (maxLineLength) {\n    var line = '', lines = [];\n    while (results.length) {\n      var len = line.length;\n      var end = results[0].indexOf('\\n');\n      if (end < 0) {\n        line += restoreIgnore(restoreCustom(results.shift()));\n      }\n      else {\n        line += restoreIgnore(restoreCustom(results[0].slice(0, end)));\n        results[0] = results[0].slice(end + 1);\n      }\n      if (len > 0 && line.length > maxLineLength) {\n        lines.push(line.slice(0, len));\n        line = line.slice(len);\n      }\n      else if (end >= 0) {\n        lines.push(line);\n        line = '';\n      }\n    }\n    if (line) {\n      lines.push(line);\n    }\n    str = lines.join('\\n');\n  }\n  else {\n    str = restoreIgnore(restoreCustom(results.join('')));\n  }\n  return options.collapseWhitespace ? collapseWhitespace(str, options, true, true) : str;\n}\n\nexports.minify = function(value, options) {\n  var start = Date.now();\n  options = processOptions(options || {});\n  var result = minify(value, options);\n  options.log('minified in: ' + (Date.now() - start) + 'ms');\n  return result;\n};\n",
    "223": "/**\n * Clean-css - https://github.com/jakubpawlowicz/clean-css\n * Released under the terms of MIT license\n *\n * Copyright (C) 2017 JakubPawlowicz.com\n */\n\nvar level0Optimize = require('./optimizer/level-0/optimize');\nvar level1Optimize = require('./optimizer/level-1/optimize');\nvar level2Optimize = require('./optimizer/level-2/optimize');\nvar validator = require('./optimizer/validator');\n\nvar compatibilityFrom = require('./options/compatibility');\nvar fetchFrom = require('./options/fetch');\nvar formatFrom = require('./options/format').formatFrom;\nvar inlineFrom = require('./options/inline');\nvar inlineRequestFrom = require('./options/inline-request');\nvar inlineTimeoutFrom = require('./options/inline-timeout');\nvar OptimizationLevel = require('./options/optimization-level').OptimizationLevel;\nvar optimizationLevelFrom = require('./options/optimization-level').optimizationLevelFrom;\nvar rebaseFrom = require('./options/rebase');\nvar rebaseToFrom = require('./options/rebase-to');\n\nvar inputSourceMapTracker = require('./reader/input-source-map-tracker');\nvar readSources = require('./reader/read-sources');\n\nvar serializeStyles = require('./writer/simple');\nvar serializeStylesAndSourceMap = require('./writer/source-maps');\n\nvar CleanCSS = module.exports = function CleanCSS(options) {\n  options = options || {};\n\n  this.options = {\n    compatibility: compatibilityFrom(options.compatibility),\n    fetch: fetchFrom(options.fetch),\n    format: formatFrom(options.format),\n    inline: inlineFrom(options.inline),\n    inlineRequest: inlineRequestFrom(options.inlineRequest),\n    inlineTimeout: inlineTimeoutFrom(options.inlineTimeout),\n    level: optimizationLevelFrom(options.level),\n    rebase: rebaseFrom(options.rebase),\n    rebaseTo: rebaseToFrom(options.rebaseTo),\n    returnPromise: !!options.returnPromise,\n    sourceMap: !!options.sourceMap,\n    sourceMapInlineSources: !!options.sourceMapInlineSources\n  };\n};\n\n\n// for compatibility with optimize-css-assets-webpack-plugin\nCleanCSS.process = function (input, opts) {\n  var cleanCss;\n  var optsTo = opts.to;\n\n  delete opts.to;\n  cleanCss = new CleanCSS(Object.assign({ returnPromise: true, rebaseTo: optsTo }, opts));\n\n  return cleanCss.minify(input)\n    .then(function(output) {\n      return { css: output.styles };\n    });\n};\n\n\nCleanCSS.prototype.minify = function (input, maybeSourceMap, maybeCallback) {\n  var options = this.options;\n\n  if (options.returnPromise) {\n    return new Promise(function (resolve, reject) {\n      minify(input, options, maybeSourceMap, function (errors, output) {\n        return errors ?\n          reject(errors) :\n          resolve(output);\n      });\n    });\n  } else {\n    return minify(input, options, maybeSourceMap, maybeCallback);\n  }\n};\n\nfunction minify(input, options, maybeSourceMap, maybeCallback) {\n  var sourceMap = typeof maybeSourceMap != 'function' ?\n    maybeSourceMap :\n    null;\n  var callback = typeof maybeCallback == 'function' ?\n    maybeCallback :\n    (typeof maybeSourceMap == 'function' ? maybeSourceMap : null);\n  var context = {\n    stats: {\n      efficiency: 0,\n      minifiedSize: 0,\n      originalSize: 0,\n      startedAt: Date.now(),\n      timeSpent: 0\n    },\n    cache: {\n      specificity: {}\n    },\n    errors: [],\n    inlinedStylesheets: [],\n    inputSourceMapTracker: inputSourceMapTracker(),\n    localOnly: !callback,\n    options: options,\n    source: null,\n    sourcesContent: {},\n    validator: validator(options.compatibility),\n    warnings: []\n  };\n\n  if (sourceMap) {\n    context.inputSourceMapTracker.track(undefined, sourceMap);\n  }\n\n  return runner(context.localOnly)(function () {\n    return readSources(input, context, function (tokens) {\n      var serialize = context.options.sourceMap ?\n        serializeStylesAndSourceMap :\n        serializeStyles;\n\n      var optimizedTokens = optimize(tokens, context);\n      var optimizedStyles = serialize(optimizedTokens, context);\n      var output = withMetadata(optimizedStyles, context);\n\n      return callback ?\n        callback(context.errors.length > 0 ? context.errors : null, output) :\n        output;\n    });\n  });\n}\n\nfunction runner(localOnly) {\n  // to always execute code asynchronously when a callback is given\n  // more at blog.izs.me/post/59142742143/designing-apis-for-asynchrony\n  return localOnly ?\n    function (callback) { return callback(); } :\n    process.nextTick;\n}\n\nfunction optimize(tokens, context) {\n  var optimized;\n\n  optimized = level0Optimize(tokens, context);\n  optimized = OptimizationLevel.One in context.options.level ?\n    level1Optimize(tokens, context) :\n    tokens;\n  optimized = OptimizationLevel.Two in context.options.level ?\n    level2Optimize(tokens, context, true) :\n    optimized;\n\n  return optimized;\n}\n\nfunction withMetadata(output, context) {\n  output.stats = calculateStatsFrom(output.styles, context);\n  output.errors = context.errors;\n  output.inlinedStylesheets = context.inlinedStylesheets;\n  output.warnings = context.warnings;\n\n  return output;\n}\n\nfunction calculateStatsFrom(styles, context) {\n  var finishedAt = Date.now();\n  var timeSpent = finishedAt - context.stats.startedAt;\n\n  delete context.stats.startedAt;\n  context.stats.timeSpent = timeSpent;\n  context.stats.efficiency = 1 - styles.length / context.stats.originalSize;\n  context.stats.minifiedSize = styles.length;\n\n  return context.stats;\n}\n",
    "225": "var shortenHex = require('./shorten-hex');\nvar shortenHsl = require('./shorten-hsl');\nvar shortenRgb = require('./shorten-rgb');\nvar sortSelectors = require('./sort-selectors');\nvar tidyRules = require('./tidy-rules');\nvar tidyBlock = require('./tidy-block');\nvar tidyAtRule = require('./tidy-at-rule');\n\nvar Hack = require('../hack');\nvar removeUnused = require('../remove-unused');\nvar restoreFromOptimizing = require('../restore-from-optimizing');\nvar wrapForOptimizing = require('../wrap-for-optimizing').all;\n\nvar OptimizationLevel = require('../../options/optimization-level').OptimizationLevel;\n\nvar Token = require('../../tokenizer/token');\nvar Marker = require('../../tokenizer/marker');\n\nvar formatPosition = require('../../utils/format-position');\nvar split = require('../../utils/split');\n\nvar serializeRules = require('../../writer/one-time').rules;\n\nvar IgnoreProperty = 'ignore-property';\n\nvar CHARSET_TOKEN = '@charset';\nvar CHARSET_REGEXP = new RegExp('^' + CHARSET_TOKEN, 'i');\n\nvar DEFAULT_ROUNDING_PRECISION = require('../../options/rounding-precision').DEFAULT;\n\nvar WHOLE_PIXEL_VALUE = /(?:^|\\s|\\()(-?\\d+)px/;\nvar TIME_VALUE = /^(\\-?[\\d\\.]+)(m?s)$/;\n\nvar HEX_VALUE_PATTERN = /[0-9a-f]/i;\nvar PROPERTY_NAME_PATTERN = /^(?:\\-chrome\\-|\\-[\\w\\-]+\\w|\\w[\\w\\-]+\\w|\\-\\-\\S+)$/;\nvar IMPORT_PREFIX_PATTERN = /^@import/i;\nvar QUOTED_PATTERN = /^('.*'|\".*\")$/;\nvar QUOTED_BUT_SAFE_PATTERN = /^['\"][a-zA-Z][a-zA-Z\\d\\-_]+['\"]$/;\nvar URL_PREFIX_PATTERN = /^url\\(/i;\nvar LOCAL_PREFIX_PATTERN = /^local\\(/i;\nvar VARIABLE_NAME_PATTERN = /^--\\S+$/;\n\nfunction isLocal(value){\n  return LOCAL_PREFIX_PATTERN.test(value);\n}\n\nfunction isNegative(value) {\n  return value && value[1][0] == '-' && parseFloat(value[1]) < 0;\n}\n\nfunction isQuoted(value) {\n  return QUOTED_PATTERN.test(value);\n}\n\nfunction isUrl(value) {\n  return URL_PREFIX_PATTERN.test(value);\n}\n\nfunction normalizeUrl(value) {\n  return value\n    .replace(URL_PREFIX_PATTERN, 'url(')\n    .replace(/\\\\?\\n|\\\\?\\r\\n/g, '');\n}\n\nfunction optimizeBackground(property) {\n  var values = property.value;\n\n  if (values.length == 1 && values[0][1] == 'none') {\n    values[0][1] = '0 0';\n  }\n\n  if (values.length == 1 && values[0][1] == 'transparent') {\n    values[0][1] = '0 0';\n  }\n}\n\nfunction optimizeBorderRadius(property) {\n  var values = property.value;\n  var spliceAt;\n\n  if (values.length == 3 && values[1][1] == '/' && values[0][1] == values[2][1]) {\n    spliceAt = 1;\n  } else if (values.length == 5 && values[2][1] == '/' && values[0][1] == values[3][1] && values[1][1] == values[4][1]) {\n    spliceAt = 2;\n  } else if (values.length == 7 && values[3][1] == '/' && values[0][1] == values[4][1] && values[1][1] == values[5][1] && values[2][1] == values[6][1]) {\n    spliceAt = 3;\n  } else if (values.length == 9 && values[4][1] == '/' && values[0][1] == values[5][1] && values[1][1] == values[6][1] && values[2][1] == values[7][1] && values[3][1] == values[8][1]) {\n    spliceAt = 4;\n  }\n\n  if (spliceAt) {\n    property.value.splice(spliceAt);\n    property.dirty = true;\n  }\n}\n\n/**\n * @param {string} name\n * @param {string} value\n * @param {Object} compatibility\n * @return {string}\n */\nfunction optimizeColors(name, value, compatibility) {\n  if (!value.match(/#|rgb|hsl/gi)) {\n    return shortenHex(value);\n  }\n\n  value = value\n    .replace(/(rgb|hsl)a?\\((\\-?\\d+),(\\-?\\d+\\%?),(\\-?\\d+\\%?),(0*[1-9]+[0-9]*(\\.?\\d*)?)\\)/gi, function (match, colorFn, p1, p2, p3, alpha) {\n      return (parseInt(alpha, 10) >= 1 ? colorFn + '(' + [p1,p2,p3].join(',') + ')' : match);\n    })\n    .replace(/rgb\\((\\-?\\d+),(\\-?\\d+),(\\-?\\d+)\\)/gi, function (match, red, green, blue) {\n      return shortenRgb(red, green, blue);\n    })\n    .replace(/hsl\\((-?\\d+),(-?\\d+)%?,(-?\\d+)%?\\)/gi, function (match, hue, saturation, lightness) {\n      return shortenHsl(hue, saturation, lightness);\n    })\n    .replace(/(^|[^='\"])#([0-9a-f]{6})/gi, function (match, prefix, color, at, inputValue) {\n      var suffix = inputValue[at + match.length];\n\n      if (suffix && HEX_VALUE_PATTERN.test(suffix)) {\n        return match;\n      } else if (color[0] == color[1] && color[2] == color[3] && color[4] == color[5]) {\n        return (prefix + '#' + color[0] + color[2] + color[4]).toLowerCase();\n      } else {\n        return (prefix + '#' + color).toLowerCase();\n      }\n    })\n    .replace(/(^|[^='\"])#([0-9a-f]{3})/gi, function (match, prefix, color) {\n      return prefix + '#' + color.toLowerCase();\n    })\n    .replace(/(rgb|rgba|hsl|hsla)\\(([^\\)]+)\\)/gi, function (match, colorFunction, colorDef) {\n      var tokens = colorDef.split(',');\n      var colorFnLowercase = colorFunction && colorFunction.toLowerCase();\n      var applies = (colorFnLowercase == 'hsl' && tokens.length == 3) ||\n        (colorFnLowercase == 'hsla' && tokens.length == 4) ||\n        (colorFnLowercase == 'rgb' && tokens.length === 3 && colorDef.indexOf('%') > 0) ||\n        (colorFnLowercase == 'rgba' && tokens.length == 4 && colorDef.indexOf('%') > 0);\n\n      if (!applies) {\n        return match;\n      }\n\n      if (tokens[1].indexOf('%') == -1) {\n        tokens[1] += '%';\n      }\n\n      if (tokens[2].indexOf('%') == -1) {\n        tokens[2] += '%';\n      }\n\n      return colorFunction + '(' + tokens.join(',') + ')';\n    });\n\n  if (compatibility.colors.opacity && name.indexOf('background') == -1) {\n    value = value.replace(/(?:rgba|hsla)\\(0,0%?,0%?,0\\)/g, function (match) {\n      if (split(value, ',').pop().indexOf('gradient(') > -1) {\n        return match;\n      }\n\n      return 'transparent';\n    });\n  }\n\n  return shortenHex(value);\n}\n\nfunction optimizeFilter(property) {\n  if (property.value.length == 1) {\n    property.value[0][1] = property.value[0][1].replace(/progid:DXImageTransform\\.Microsoft\\.(Alpha|Chroma)(\\W)/, function (match, filter, suffix) {\n      return filter.toLowerCase() + suffix;\n    });\n  }\n\n  property.value[0][1] = property.value[0][1]\n    .replace(/,(\\S)/g, ', $1')\n    .replace(/ ?= ?/g, '=');\n}\n\nfunction optimizeFontWeight(property, atIndex) {\n  var value = property.value[atIndex][1];\n\n  if (value == 'normal') {\n    value = '400';\n  } else if (value == 'bold') {\n    value = '700';\n  }\n\n  property.value[atIndex][1] = value;\n}\n\nfunction optimizeMultipleZeros(property) {\n  var values = property.value;\n  var spliceAt;\n\n  if (values.length == 4 && values[0][1] === '0' && values[1][1] === '0' && values[2][1] === '0' && values[3][1] === '0') {\n    if (property.name.indexOf('box-shadow') > -1) {\n      spliceAt = 2;\n    } else {\n      spliceAt = 1;\n    }\n  }\n\n  if (spliceAt) {\n    property.value.splice(spliceAt);\n    property.dirty = true;\n  }\n}\n\nfunction optimizeOutline(property) {\n  var values = property.value;\n\n  if (values.length == 1 && values[0][1] == 'none') {\n    values[0][1] = '0';\n  }\n}\n\nfunction optimizePixelLengths(_, value, compatibility) {\n  if (!WHOLE_PIXEL_VALUE.test(value)) {\n    return value;\n  }\n\n  return value.replace(WHOLE_PIXEL_VALUE, function (match, val) {\n    var newValue;\n    var intVal = parseInt(val);\n\n    if (intVal === 0) {\n      return match;\n    }\n\n    if (compatibility.properties.shorterLengthUnits && compatibility.units.pt && intVal * 3 % 4 === 0) {\n      newValue = intVal * 3 / 4 + 'pt';\n    }\n\n    if (compatibility.properties.shorterLengthUnits && compatibility.units.pc && intVal % 16 === 0) {\n      newValue = intVal / 16 + 'pc';\n    }\n\n    if (compatibility.properties.shorterLengthUnits && compatibility.units.in && intVal % 96 === 0) {\n      newValue = intVal / 96 + 'in';\n    }\n\n    if (newValue) {\n      newValue = match.substring(0, match.indexOf(val)) + newValue;\n    }\n\n    return newValue && newValue.length < match.length ? newValue : match;\n  });\n}\n\nfunction optimizePrecision(_, value, precisionOptions) {\n  if (!precisionOptions.enabled || value.indexOf('.') === -1) {\n    return value;\n  }\n\n  return value\n    .replace(precisionOptions.decimalPointMatcher, '$1$2$3')\n    .replace(precisionOptions.zeroMatcher, function (match, integerPart, fractionPart, unit) {\n      var multiplier = precisionOptions.units[unit].multiplier;\n      var parsedInteger = parseInt(integerPart);\n      var integer = isNaN(parsedInteger) ? 0 : parsedInteger;\n      var fraction = parseFloat(fractionPart);\n\n      return Math.round((integer + fraction) * multiplier) / multiplier + unit;\n    });\n}\n\nfunction optimizeTimeUnits(_, value) {\n  if (!TIME_VALUE.test(value))\n    return value;\n\n  return value.replace(TIME_VALUE, function (match, val, unit) {\n    var newValue;\n\n    if (unit == 'ms') {\n      newValue = parseInt(val) / 1000 + 's';\n    } else if (unit == 's') {\n      newValue = parseFloat(val) * 1000 + 'ms';\n    }\n\n    return newValue.length < match.length ? newValue : match;\n  });\n}\n\nfunction optimizeUnits(name, value, unitsRegexp) {\n  if (/^(?:\\-moz\\-calc|\\-webkit\\-calc|calc|rgb|hsl|rgba|hsla)\\(/.test(value)) {\n    return value;\n  }\n\n  if (name == 'flex' || name == '-ms-flex' || name == '-webkit-flex' || name == 'flex-basis' || name == '-webkit-flex-basis') {\n    return value;\n  }\n\n  if (value.indexOf('%') > 0 && (name == 'height' || name == 'max-height' || name == 'width' || name == 'max-width')) {\n    return value;\n  }\n\n  return value\n    .replace(unitsRegexp, '$1' + '0' + '$2')\n    .replace(unitsRegexp, '$1' + '0' + '$2');\n}\n\nfunction optimizeWhitespace(name, value) {\n  if (name.indexOf('filter') > -1 || value.indexOf(' ') == -1 || value.indexOf('expression') === 0) {\n    return value;\n  }\n\n  if (value.indexOf(Marker.SINGLE_QUOTE) > -1 || value.indexOf(Marker.DOUBLE_QUOTE) > -1) {\n    return value;\n  }\n\n  value = value.replace(/\\s+/g, ' ');\n\n  if (value.indexOf('calc') > -1) {\n    value = value.replace(/\\) ?\\/ ?/g, ')/ ');\n  }\n\n  return value\n    .replace(/(\\(;?)\\s+/g, '$1')\n    .replace(/\\s+(;?\\))/g, '$1')\n    .replace(/, /g, ',');\n}\n\nfunction optimizeZeroDegUnit(_, value) {\n  if (value.indexOf('0deg') == -1) {\n    return value;\n  }\n\n  return value.replace(/\\(0deg\\)/g, '(0)');\n}\n\nfunction optimizeZeroUnits(name, value) {\n  if (value.indexOf('0') == -1) {\n    return value;\n  }\n\n  if (value.indexOf('-') > -1) {\n    value = value\n      .replace(/([^\\w\\d\\-]|^)\\-0([^\\.]|$)/g, '$10$2')\n      .replace(/([^\\w\\d\\-]|^)\\-0([^\\.]|$)/g, '$10$2');\n  }\n\n  return value\n    .replace(/(^|\\s)0+([1-9])/g, '$1$2')\n    .replace(/(^|\\D)\\.0+(\\D|$)/g, '$10$2')\n    .replace(/(^|\\D)\\.0+(\\D|$)/g, '$10$2')\n    .replace(/\\.([1-9]*)0+(\\D|$)/g, function (match, nonZeroPart, suffix) {\n      return (nonZeroPart.length > 0 ? '.' : '') + nonZeroPart + suffix;\n    })\n    .replace(/(^|\\D)0\\.(\\d)/g, '$1.$2');\n}\n\nfunction removeQuotes(name, value) {\n  if (name == 'content' || name.indexOf('font-variation-settings') > -1 || name.indexOf('font-feature-settings') > -1 || name == 'grid' || name.indexOf('grid-') > -1) {\n    return value;\n  }\n\n  return QUOTED_BUT_SAFE_PATTERN.test(value) ?\n    value.substring(1, value.length - 1) :\n    value;\n}\n\nfunction removeUrlQuotes(value) {\n  return /^url\\(['\"].+['\"]\\)$/.test(value) && !/^url\\(['\"].*[\\*\\s\\(\\)'\"].*['\"]\\)$/.test(value) && !/^url\\(['\"]data:[^;]+;charset/.test(value) ?\n    value.replace(/[\"']/g, '') :\n    value;\n}\n\nfunction transformValue(propertyName, propertyValue, rule, transformCallback) {\n  var selector = serializeRules(rule);\n  var transformedValue = transformCallback(propertyName, propertyValue, selector);\n\n  if (transformedValue === undefined) {\n    return propertyValue;\n  } else if (transformedValue === false) {\n    return IgnoreProperty;\n  } else {\n    return transformedValue;\n  }\n}\n\n//\n\nfunction optimizeBody(rule, properties, context) {\n  var options = context.options;\n  var levelOptions = options.level[OptimizationLevel.One];\n  var property, name, type, value;\n  var valueIsUrl;\n  var propertyToken;\n  var _properties = wrapForOptimizing(properties, true);\n\n  propertyLoop:\n  for (var i = 0, l = _properties.length; i < l; i++) {\n    property = _properties[i];\n    name = property.name;\n\n    if (!PROPERTY_NAME_PATTERN.test(name)) {\n      propertyToken = property.all[property.position];\n      context.warnings.push('Invalid property name \\'' + name + '\\' at ' + formatPosition(propertyToken[1][2][0]) + '. Ignoring.');\n      property.unused = true;\n    }\n\n    if (property.value.length === 0) {\n      propertyToken = property.all[property.position];\n      context.warnings.push('Empty property \\'' + name + '\\' at ' + formatPosition(propertyToken[1][2][0]) + '. Ignoring.');\n      property.unused = true;\n    }\n\n    if (property.hack && (\n        (property.hack[0] == Hack.ASTERISK || property.hack[0] == Hack.UNDERSCORE) && !options.compatibility.properties.iePrefixHack ||\n        property.hack[0] == Hack.BACKSLASH && !options.compatibility.properties.ieSuffixHack ||\n        property.hack[0] == Hack.BANG && !options.compatibility.properties.ieBangHack)) {\n      property.unused = true;\n    }\n\n    if (levelOptions.removeNegativePaddings && name.indexOf('padding') === 0 && (isNegative(property.value[0]) || isNegative(property.value[1]) || isNegative(property.value[2]) || isNegative(property.value[3]))) {\n      property.unused = true;\n    }\n\n    if (!options.compatibility.properties.ieFilters && isLegacyFilter(property)) {\n      property.unused = true;\n    }\n\n    if (property.unused) {\n      continue;\n    }\n\n    if (property.block) {\n      optimizeBody(rule, property.value[0][1], context);\n      continue;\n    }\n\n    if (VARIABLE_NAME_PATTERN.test(name)) {\n      continue;\n    }\n\n    for (var j = 0, m = property.value.length; j < m; j++) {\n      type = property.value[j][0];\n      value = property.value[j][1];\n      valueIsUrl = isUrl(value);\n\n      if (type == Token.PROPERTY_BLOCK) {\n        property.unused = true;\n        context.warnings.push('Invalid value token at ' + formatPosition(value[0][1][2][0]) + '. Ignoring.');\n        break;\n      }\n\n      if (valueIsUrl && !context.validator.isUrl(value)) {\n        property.unused = true;\n        context.warnings.push('Broken URL \\'' + value + '\\' at ' + formatPosition(property.value[j][2][0]) + '. Ignoring.');\n        break;\n      }\n\n      if (valueIsUrl) {\n        value = levelOptions.normalizeUrls ?\n          normalizeUrl(value) :\n          value;\n        value = !options.compatibility.properties.urlQuotes ?\n          removeUrlQuotes(value) :\n          value;\n      } else if (isQuoted(value) || isLocal(value)) {\n        value = levelOptions.removeQuotes ?\n          removeQuotes(name, value) :\n          value;\n      } else {\n        value = levelOptions.removeWhitespace ?\n          optimizeWhitespace(name, value) :\n          value;\n        value = optimizePrecision(name, value, options.precision);\n        value = optimizePixelLengths(name, value, options.compatibility);\n        value = levelOptions.replaceTimeUnits ?\n          optimizeTimeUnits(name, value) :\n          value;\n        value = levelOptions.replaceZeroUnits ?\n          optimizeZeroUnits(name, value) :\n          value;\n\n        if (options.compatibility.properties.zeroUnits) {\n          value = optimizeZeroDegUnit(name, value);\n          value = optimizeUnits(name, value, options.unitsRegexp);\n        }\n\n        if (options.compatibility.properties.colors) {\n          value = optimizeColors(name, value, options.compatibility);\n        }\n      }\n\n      value = transformValue(name, value, rule, levelOptions.transform);\n\n      if (value === IgnoreProperty) {\n        property.unused = true;\n        continue propertyLoop;\n      }\n\n      property.value[j][1] = value;\n    }\n\n    if (levelOptions.replaceMultipleZeros) {\n      optimizeMultipleZeros(property);\n    }\n\n    if (name == 'background' && levelOptions.optimizeBackground) {\n      optimizeBackground(property);\n    } else if (name.indexOf('border') === 0 && name.indexOf('radius') > 0 && levelOptions.optimizeBorderRadius) {\n      optimizeBorderRadius(property);\n    } else if (name == 'filter'&& levelOptions.optimizeFilter && options.compatibility.properties.ieFilters) {\n      optimizeFilter(property);\n    } else if (name == 'font-weight' && levelOptions.optimizeFontWeight) {\n      optimizeFontWeight(property, 0);\n    } else if (name == 'outline' && levelOptions.optimizeOutline) {\n      optimizeOutline(property);\n    }\n  }\n\n  restoreFromOptimizing(_properties);\n  removeUnused(_properties);\n  removeComments(properties, options);\n}\n\nfunction removeComments(tokens, options) {\n  var token;\n  var i;\n\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n\n    if (token[0] != Token.COMMENT) {\n      continue;\n    }\n\n    optimizeComment(token, options);\n\n    if (token[1].length === 0) {\n      tokens.splice(i, 1);\n      i--;\n    }\n  }\n}\n\nfunction optimizeComment(token, options) {\n  if (token[1][2] == Marker.EXCLAMATION && (options.level[OptimizationLevel.One].specialComments == 'all' || options.commentsKept < options.level[OptimizationLevel.One].specialComments)) {\n    options.commentsKept++;\n    return;\n  }\n\n  token[1] = [];\n}\n\nfunction cleanupCharsets(tokens) {\n  var hasCharset = false;\n\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    var token = tokens[i];\n\n    if (token[0] != Token.AT_RULE)\n      continue;\n\n    if (!CHARSET_REGEXP.test(token[1]))\n      continue;\n\n    if (hasCharset || token[1].indexOf(CHARSET_TOKEN) == -1) {\n      tokens.splice(i, 1);\n      i--;\n      l--;\n    } else {\n      hasCharset = true;\n      tokens.splice(i, 1);\n      tokens.unshift([Token.AT_RULE, token[1].replace(CHARSET_REGEXP, CHARSET_TOKEN)]);\n    }\n  }\n}\n\nfunction buildUnitRegexp(options) {\n  var units = ['px', 'em', 'ex', 'cm', 'mm', 'in', 'pt', 'pc', '%'];\n  var otherUnits = ['ch', 'rem', 'vh', 'vm', 'vmax', 'vmin', 'vw'];\n\n  otherUnits.forEach(function (unit) {\n    if (options.compatibility.units[unit]) {\n      units.push(unit);\n    }\n  });\n\n  return new RegExp('(^|\\\\s|\\\\(|,)0(?:' + units.join('|') + ')(\\\\W|$)', 'g');\n}\n\nfunction buildPrecisionOptions(roundingPrecision) {\n  var precisionOptions = {\n    matcher: null,\n    units: {},\n  };\n  var optimizable = [];\n  var unit;\n  var value;\n\n  for (unit in roundingPrecision) {\n    value = roundingPrecision[unit];\n\n    if (value != DEFAULT_ROUNDING_PRECISION) {\n      precisionOptions.units[unit] = {};\n      precisionOptions.units[unit].value = value;\n      precisionOptions.units[unit].multiplier = Math.pow(10, value);\n\n      optimizable.push(unit);\n    }\n  }\n\n  if (optimizable.length > 0) {\n    precisionOptions.enabled = true;\n    precisionOptions.decimalPointMatcher = new RegExp('(\\\\d)\\\\.($|' + optimizable.join('|') + ')($|\\\\W)', 'g');\n    precisionOptions.zeroMatcher = new RegExp('(\\\\d*)(\\\\.\\\\d+)(' + optimizable.join('|') + ')', 'g');\n  }\n\n  return precisionOptions;\n}\n\nfunction isImport(token) {\n  return IMPORT_PREFIX_PATTERN.test(token[1]);\n}\n\nfunction isLegacyFilter(property) {\n  var value;\n\n  if (property.name == 'filter' || property.name == '-ms-filter') {\n    value = property.value[0][1];\n\n    return value.indexOf('progid') > -1 ||\n      value.indexOf('alpha') === 0 ||\n      value.indexOf('chroma') === 0;\n  } else {\n    return false;\n  }\n}\n\nfunction level1Optimize(tokens, context) {\n  var options = context.options;\n  var levelOptions = options.level[OptimizationLevel.One];\n  var ie7Hack = options.compatibility.selectors.ie7Hack;\n  var adjacentSpace = options.compatibility.selectors.adjacentSpace;\n  var spaceAfterClosingBrace = options.compatibility.properties.spaceAfterClosingBrace;\n  var format = options.format;\n  var mayHaveCharset = false;\n  var afterRules = false;\n\n  options.unitsRegexp = options.unitsRegexp || buildUnitRegexp(options);\n  options.precision = options.precision || buildPrecisionOptions(levelOptions.roundingPrecision);\n  options.commentsKept = options.commentsKept || 0;\n\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    var token = tokens[i];\n\n    switch (token[0]) {\n      case Token.AT_RULE:\n        token[1] = isImport(token) && afterRules ? '' : token[1];\n        token[1] = levelOptions.tidyAtRules ? tidyAtRule(token[1]) : token[1];\n        mayHaveCharset = true;\n        break;\n      case Token.AT_RULE_BLOCK:\n        optimizeBody(token[1], token[2], context);\n        afterRules = true;\n        break;\n      case Token.NESTED_BLOCK:\n        token[1] = levelOptions.tidyBlockScopes ? tidyBlock(token[1], spaceAfterClosingBrace) : token[1];\n        level1Optimize(token[2], context);\n        afterRules = true;\n        break;\n      case Token.COMMENT:\n        optimizeComment(token, options);\n        break;\n      case Token.RULE:\n        token[1] = levelOptions.tidySelectors ? tidyRules(token[1], !ie7Hack, adjacentSpace, format, context.warnings) : token[1];\n        token[1] = token[1].length > 1 ? sortSelectors(token[1], levelOptions.selectorsSortingMethod) : token[1];\n        optimizeBody(token[1], token[2], context);\n        afterRules = true;\n        break;\n    }\n\n    if (token[0] == Token.COMMENT && token[1].length === 0 || levelOptions.removeEmpty && (token[1].length === 0 || (token[2] && token[2].length === 0))) {\n      tokens.splice(i, 1);\n      i--;\n      l--;\n    }\n  }\n\n  if (levelOptions.cleanupCharsets && mayHaveCharset) {\n    cleanupCharsets(tokens);\n  }\n\n  return tokens;\n}\n\nmodule.exports = level1Optimize;\n",
    "226": "var COLORS = {\n  aliceblue: '#f0f8ff',\n  antiquewhite: '#faebd7',\n  aqua: '#0ff',\n  aquamarine: '#7fffd4',\n  azure: '#f0ffff',\n  beige: '#f5f5dc',\n  bisque: '#ffe4c4',\n  black: '#000',\n  blanchedalmond: '#ffebcd',\n  blue: '#00f',\n  blueviolet: '#8a2be2',\n  brown: '#a52a2a',\n  burlywood: '#deb887',\n  cadetblue: '#5f9ea0',\n  chartreuse: '#7fff00',\n  chocolate: '#d2691e',\n  coral: '#ff7f50',\n  cornflowerblue: '#6495ed',\n  cornsilk: '#fff8dc',\n  crimson: '#dc143c',\n  cyan: '#0ff',\n  darkblue: '#00008b',\n  darkcyan: '#008b8b',\n  darkgoldenrod: '#b8860b',\n  darkgray: '#a9a9a9',\n  darkgreen: '#006400',\n  darkgrey: '#a9a9a9',\n  darkkhaki: '#bdb76b',\n  darkmagenta: '#8b008b',\n  darkolivegreen: '#556b2f',\n  darkorange: '#ff8c00',\n  darkorchid: '#9932cc',\n  darkred: '#8b0000',\n  darksalmon: '#e9967a',\n  darkseagreen: '#8fbc8f',\n  darkslateblue: '#483d8b',\n  darkslategray: '#2f4f4f',\n  darkslategrey: '#2f4f4f',\n  darkturquoise: '#00ced1',\n  darkviolet: '#9400d3',\n  deeppink: '#ff1493',\n  deepskyblue: '#00bfff',\n  dimgray: '#696969',\n  dimgrey: '#696969',\n  dodgerblue: '#1e90ff',\n  firebrick: '#b22222',\n  floralwhite: '#fffaf0',\n  forestgreen: '#228b22',\n  fuchsia: '#f0f',\n  gainsboro: '#dcdcdc',\n  ghostwhite: '#f8f8ff',\n  gold: '#ffd700',\n  goldenrod: '#daa520',\n  gray: '#808080',\n  green: '#008000',\n  greenyellow: '#adff2f',\n  grey: '#808080',\n  honeydew: '#f0fff0',\n  hotpink: '#ff69b4',\n  indianred: '#cd5c5c',\n  indigo: '#4b0082',\n  ivory: '#fffff0',\n  khaki: '#f0e68c',\n  lavender: '#e6e6fa',\n  lavenderblush: '#fff0f5',\n  lawngreen: '#7cfc00',\n  lemonchiffon: '#fffacd',\n  lightblue: '#add8e6',\n  lightcoral: '#f08080',\n  lightcyan: '#e0ffff',\n  lightgoldenrodyellow: '#fafad2',\n  lightgray: '#d3d3d3',\n  lightgreen: '#90ee90',\n  lightgrey: '#d3d3d3',\n  lightpink: '#ffb6c1',\n  lightsalmon: '#ffa07a',\n  lightseagreen: '#20b2aa',\n  lightskyblue: '#87cefa',\n  lightslategray: '#778899',\n  lightslategrey: '#778899',\n  lightsteelblue: '#b0c4de',\n  lightyellow: '#ffffe0',\n  lime: '#0f0',\n  limegreen: '#32cd32',\n  linen: '#faf0e6',\n  magenta: '#ff00ff',\n  maroon: '#800000',\n  mediumaquamarine: '#66cdaa',\n  mediumblue: '#0000cd',\n  mediumorchid: '#ba55d3',\n  mediumpurple: '#9370db',\n  mediumseagreen: '#3cb371',\n  mediumslateblue: '#7b68ee',\n  mediumspringgreen: '#00fa9a',\n  mediumturquoise: '#48d1cc',\n  mediumvioletred: '#c71585',\n  midnightblue: '#191970',\n  mintcream: '#f5fffa',\n  mistyrose: '#ffe4e1',\n  moccasin: '#ffe4b5',\n  navajowhite: '#ffdead',\n  navy: '#000080',\n  oldlace: '#fdf5e6',\n  olive: '#808000',\n  olivedrab: '#6b8e23',\n  orange: '#ffa500',\n  orangered: '#ff4500',\n  orchid: '#da70d6',\n  palegoldenrod: '#eee8aa',\n  palegreen: '#98fb98',\n  paleturquoise: '#afeeee',\n  palevioletred: '#db7093',\n  papayawhip: '#ffefd5',\n  peachpuff: '#ffdab9',\n  peru: '#cd853f',\n  pink: '#ffc0cb',\n  plum: '#dda0dd',\n  powderblue: '#b0e0e6',\n  purple: '#800080',\n  rebeccapurple: '#663399',\n  red: '#f00',\n  rosybrown: '#bc8f8f',\n  royalblue: '#4169e1',\n  saddlebrown: '#8b4513',\n  salmon: '#fa8072',\n  sandybrown: '#f4a460',\n  seagreen: '#2e8b57',\n  seashell: '#fff5ee',\n  sienna: '#a0522d',\n  silver: '#c0c0c0',\n  skyblue: '#87ceeb',\n  slateblue: '#6a5acd',\n  slategray: '#708090',\n  slategrey: '#708090',\n  snow: '#fffafa',\n  springgreen: '#00ff7f',\n  steelblue: '#4682b4',\n  tan: '#d2b48c',\n  teal: '#008080',\n  thistle: '#d8bfd8',\n  tomato: '#ff6347',\n  turquoise: '#40e0d0',\n  violet: '#ee82ee',\n  wheat: '#f5deb3',\n  white: '#fff',\n  whitesmoke: '#f5f5f5',\n  yellow: '#ff0',\n  yellowgreen: '#9acd32'\n};\n\nvar toHex = {};\nvar toName = {};\n\nfor (var name in COLORS) {\n  var hex = COLORS[name];\n\n  if (name.length < hex.length) {\n    toName[hex] = name;\n  } else {\n    toHex[name] = hex;\n  }\n}\n\nvar toHexPattern = new RegExp('(^| |,|\\\\))(' + Object.keys(toHex).join('|') + ')( |,|\\\\)|$)', 'ig');\nvar toNamePattern = new RegExp('(' + Object.keys(toName).join('|') + ')([^a-f0-9]|$)', 'ig');\n\nfunction hexConverter(match, prefix, colorValue, suffix) {\n  return prefix + toHex[colorValue.toLowerCase()] + suffix;\n}\n\nfunction nameConverter(match, colorValue, suffix) {\n  return toName[colorValue.toLowerCase()] + suffix;\n}\n\nfunction shortenHex(value) {\n  var hasHex = value.indexOf('#') > -1;\n  var shortened = value.replace(toHexPattern, hexConverter);\n\n  if (shortened != value) {\n    shortened = shortened.replace(toHexPattern, hexConverter);\n  }\n\n  return hasHex ?\n    shortened.replace(toNamePattern, nameConverter) :\n    shortened;\n}\n\nmodule.exports = shortenHex;\n",
    "231": "var Spaces = require('../../options/format').Spaces;\nvar Marker = require('../../tokenizer/marker');\nvar formatPosition = require('../../utils/format-position');\n\nvar CASE_ATTRIBUTE_PATTERN = /[\\s\"'][iI]\\s*\\]/;\nvar CASE_RESTORE_PATTERN = /([\\d\\w])([iI])\\]/g;\nvar DOUBLE_QUOTE_CASE_PATTERN = /=\"([a-zA-Z][a-zA-Z\\d\\-_]+)\"([iI])/g;\nvar DOUBLE_QUOTE_PATTERN = /=\"([a-zA-Z][a-zA-Z\\d\\-_]+)\"(\\s|\\])/g;\nvar HTML_COMMENT_PATTERN = /^(?:(?:<!--|-->)\\s*)+/;\nvar SINGLE_QUOTE_CASE_PATTERN = /='([a-zA-Z][a-zA-Z\\d\\-_]+)'([iI])/g;\nvar SINGLE_QUOTE_PATTERN = /='([a-zA-Z][a-zA-Z\\d\\-_]+)'(\\s|\\])/g;\nvar RELATION_PATTERN = /[>\\+~]/;\nvar WHITESPACE_PATTERN = /\\s/;\n\nvar ASTERISK_PLUS_HTML_HACK = '*+html ';\nvar ASTERISK_FIRST_CHILD_PLUS_HTML_HACK = '*:first-child+html ';\nvar LESS_THAN = '<';\n\nfunction hasInvalidCharacters(value) {\n  var isEscaped;\n  var isInvalid = false;\n  var character;\n  var isQuote = false;\n  var i, l;\n\n  for (i = 0, l = value.length; i < l; i++) {\n    character = value[i];\n\n    if (isEscaped) {\n      // continue as always\n    } else if (character == Marker.SINGLE_QUOTE || character == Marker.DOUBLE_QUOTE) {\n      isQuote = !isQuote;\n    } else if (!isQuote && (character == Marker.CLOSE_CURLY_BRACKET || character == Marker.EXCLAMATION || character == LESS_THAN || character == Marker.SEMICOLON)) {\n      isInvalid = true;\n      break;\n    } else if (!isQuote && i === 0 && RELATION_PATTERN.test(character)) {\n      isInvalid = true;\n      break;\n    }\n\n    isEscaped = character == Marker.BACK_SLASH;\n  }\n\n  return isInvalid;\n}\n\nfunction removeWhitespace(value, format) {\n  var stripped = [];\n  var character;\n  var isNewLineNix;\n  var isNewLineWin;\n  var isEscaped;\n  var wasEscaped;\n  var isQuoted;\n  var isSingleQuoted;\n  var isDoubleQuoted;\n  var isAttribute;\n  var isRelation;\n  var isWhitespace;\n  var roundBracketLevel = 0;\n  var wasRelation = false;\n  var wasWhitespace = false;\n  var withCaseAttribute = CASE_ATTRIBUTE_PATTERN.test(value);\n  var spaceAroundRelation = format && format.spaces[Spaces.AroundSelectorRelation];\n  var i, l;\n\n  for (i = 0, l = value.length; i < l; i++) {\n    character = value[i];\n\n    isNewLineNix = character == Marker.NEW_LINE_NIX;\n    isNewLineWin = character == Marker.NEW_LINE_NIX && value[i - 1] == Marker.CARRIAGE_RETURN;\n    isQuoted = isSingleQuoted || isDoubleQuoted;\n    isRelation = !isAttribute && !isEscaped && roundBracketLevel === 0 && RELATION_PATTERN.test(character);\n    isWhitespace = WHITESPACE_PATTERN.test(character);\n\n    if (wasEscaped && isQuoted && isNewLineWin) {\n      // swallow escaped new windows lines in comments\n      stripped.pop();\n      stripped.pop();\n    } else if (isEscaped && isQuoted && isNewLineNix) {\n      // swallow escaped new *nix lines in comments\n      stripped.pop();\n    } else if (isEscaped) {\n      stripped.push(character);\n    } else if (character == Marker.OPEN_SQUARE_BRACKET && !isQuoted) {\n      stripped.push(character);\n      isAttribute = true;\n    } else if (character == Marker.CLOSE_SQUARE_BRACKET && !isQuoted) {\n      stripped.push(character);\n      isAttribute = false;\n    } else if (character == Marker.OPEN_ROUND_BRACKET && !isQuoted) {\n      stripped.push(character);\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && !isQuoted) {\n      stripped.push(character);\n      roundBracketLevel--;\n    } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {\n      stripped.push(character);\n      isSingleQuoted = true;\n    } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {\n      stripped.push(character);\n      isDoubleQuoted = true;\n    } else if (character == Marker.SINGLE_QUOTE && isQuoted) {\n      stripped.push(character);\n      isSingleQuoted = false;\n    } else if (character == Marker.DOUBLE_QUOTE && isQuoted) {\n      stripped.push(character);\n      isDoubleQuoted = false;\n    } else if (isWhitespace && wasRelation && !spaceAroundRelation) {\n      continue;\n    } else if (!isWhitespace && wasRelation && spaceAroundRelation) {\n      stripped.push(Marker.SPACE);\n      stripped.push(character);\n    } else if (isWhitespace && (isAttribute || roundBracketLevel > 0) && !isQuoted) {\n      // skip space\n    } else if (isWhitespace && wasWhitespace && !isQuoted) {\n      // skip extra space\n    } else if ((isNewLineWin || isNewLineNix) && (isAttribute || roundBracketLevel > 0) && isQuoted) {\n      // skip newline\n    } else if (isRelation && wasWhitespace && !spaceAroundRelation) {\n      stripped.pop();\n      stripped.push(character);\n    } else if (isRelation && !wasWhitespace && spaceAroundRelation) {\n      stripped.push(Marker.SPACE);\n      stripped.push(character);\n    } else if (isWhitespace) {\n      stripped.push(Marker.SPACE);\n    } else {\n      stripped.push(character);\n    }\n\n    wasEscaped = isEscaped;\n    isEscaped = character == Marker.BACK_SLASH;\n    wasRelation = isRelation;\n    wasWhitespace = isWhitespace;\n  }\n\n  return withCaseAttribute ?\n    stripped.join('').replace(CASE_RESTORE_PATTERN, '$1 $2]') :\n    stripped.join('');\n}\n\nfunction removeQuotes(value) {\n  if (value.indexOf('\\'') == -1 && value.indexOf('\"') == -1) {\n    return value;\n  }\n\n  return value\n    .replace(SINGLE_QUOTE_CASE_PATTERN, '=$1 $2')\n    .replace(SINGLE_QUOTE_PATTERN, '=$1$2')\n    .replace(DOUBLE_QUOTE_CASE_PATTERN, '=$1 $2')\n    .replace(DOUBLE_QUOTE_PATTERN, '=$1$2');\n}\n\nfunction tidyRules(rules, removeUnsupported, adjacentSpace, format, warnings) {\n  var list = [];\n  var repeated = [];\n\n  function removeHTMLComment(rule, match) {\n    warnings.push('HTML comment \\'' + match + '\\' at ' + formatPosition(rule[2][0]) + '. Removing.');\n    return '';\n  }\n\n  for (var i = 0, l = rules.length; i < l; i++) {\n    var rule = rules[i];\n    var reduced = rule[1];\n\n    reduced = reduced.replace(HTML_COMMENT_PATTERN, removeHTMLComment.bind(null, rule));\n\n    if (hasInvalidCharacters(reduced)) {\n      warnings.push('Invalid selector \\'' + rule[1] + '\\' at ' + formatPosition(rule[2][0]) + '. Ignoring.');\n      continue;\n    }\n\n    reduced = removeWhitespace(reduced, format);\n    reduced = removeQuotes(reduced);\n\n    if (adjacentSpace && reduced.indexOf('nav') > 0) {\n      reduced = reduced.replace(/\\+nav(\\S|$)/, '+ nav$1');\n    }\n\n    if (removeUnsupported && reduced.indexOf(ASTERISK_PLUS_HTML_HACK) > -1) {\n      continue;\n    }\n\n    if (removeUnsupported && reduced.indexOf(ASTERISK_FIRST_CHILD_PLUS_HTML_HACK) > -1) {\n      continue;\n    }\n\n    if (reduced.indexOf('*') > -1) {\n      reduced = reduced\n        .replace(/\\*([:#\\.\\[])/g, '$1')\n        .replace(/^(\\:first\\-child)?\\+html/, '*$1+html');\n    }\n\n    if (repeated.indexOf(reduced) > -1) {\n      continue;\n    }\n\n    rule[1] = reduced;\n    repeated.push(reduced);\n    list.push(rule);\n  }\n\n  if (list.length == 1 && list[0][1].length === 0) {\n    warnings.push('Empty selector \\'' + list[0][1] + '\\' at ' + formatPosition(list[0][2][0]) + '. Ignoring.');\n    list = [];\n  }\n\n  return list;\n}\n\nmodule.exports = tidyRules;\n",
    "233": "function override(source1, source2) {\n  var target = {};\n  var key1;\n  var key2;\n  var item;\n\n  for (key1 in source1) {\n    item = source1[key1];\n\n    if (Array.isArray(item)) {\n      target[key1] = item.slice(0);\n    } else if (typeof item == 'object' && item !== null) {\n      target[key1] = override(item, {});\n    } else {\n      target[key1] = item;\n    }\n  }\n\n  for (key2 in source2) {\n    item = source2[key2];\n\n    if (key2 in target && Array.isArray(item)) {\n      target[key2] = item.slice(0);\n    } else if (key2 in target && typeof item == 'object' && item !== null) {\n      target[key2] = override(target[key2], item);\n    } else {\n      target[key2] = item;\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = override;\n",
    "240": "var Hack = require('./hack');\n\nvar Marker = require('../tokenizer/marker');\n\nvar ASTERISK_HACK = '*';\nvar BACKSLASH_HACK = '\\\\';\nvar IMPORTANT_TOKEN = '!important';\nvar UNDERSCORE_HACK = '_';\nvar BANG_HACK = '!ie';\n\nfunction restoreFromOptimizing(properties, restoreCallback) {\n  var property;\n  var restored;\n  var current;\n  var i;\n\n  for (i = properties.length - 1; i >= 0; i--) {\n    property = properties[i];\n\n    if (property.unused) {\n      continue;\n    }\n\n    if (!property.dirty && !property.important && !property.hack) {\n      continue;\n    }\n\n    if (restoreCallback) {\n      restored = restoreCallback(property);\n      property.value = restored;\n    } else {\n      restored = property.value;\n    }\n\n    if (property.important) {\n      restoreImportant(property);\n    }\n\n    if (property.hack) {\n      restoreHack(property);\n    }\n\n    if ('all' in property) {\n      current = property.all[property.position];\n      current[1][1] = property.name;\n\n      current.splice(2, current.length - 1);\n      Array.prototype.push.apply(current, restored);\n    }\n  }\n}\n\nfunction restoreImportant(property) {\n  property.value[property.value.length - 1][1] += IMPORTANT_TOKEN;\n}\n\nfunction restoreHack(property) {\n  if (property.hack[0] == Hack.UNDERSCORE) {\n    property.name = UNDERSCORE_HACK + property.name;\n  } else if (property.hack[0] == Hack.ASTERISK) {\n    property.name = ASTERISK_HACK + property.name;\n  } else if (property.hack[0] == Hack.BACKSLASH) {\n    property.value[property.value.length - 1][1] += BACKSLASH_HACK + property.hack[1];\n  } else if (property.hack[0] == Hack.BANG) {\n    property.value[property.value.length - 1][1] += Marker.SPACE + BANG_HACK;\n  }\n}\n\nmodule.exports = restoreFromOptimizing;\n",
    "241": "var Hack = require('./hack');\n\nvar Marker = require('../tokenizer/marker');\nvar Token = require('../tokenizer/token');\n\nvar Match = {\n  ASTERISK: '*',\n  BACKSLASH: '\\\\',\n  BANG: '!',\n  BANG_SUFFIX_PATTERN: /!\\w+$/,\n  IMPORTANT_TOKEN: '!important',\n  IMPORTANT_TOKEN_PATTERN: new RegExp('!important$', 'i'),\n  IMPORTANT_WORD: 'important',\n  IMPORTANT_WORD_PATTERN: new RegExp('important$', 'i'),\n  SUFFIX_BANG_PATTERN: /!$/,\n  UNDERSCORE: '_',\n  VARIABLE_REFERENCE_PATTERN: /var\\(--.+\\)$/\n};\n\nfunction wrapAll(properties, includeVariable, skipProperties) {\n  var wrapped = [];\n  var single;\n  var property;\n  var i;\n\n  for (i = properties.length - 1; i >= 0; i--) {\n    property = properties[i];\n\n    if (property[0] != Token.PROPERTY) {\n      continue;\n    }\n\n    if (!includeVariable && someVariableReferences(property)) {\n      continue;\n    }\n\n    if (skipProperties && skipProperties.indexOf(property[1][1]) > -1) {\n      continue;\n    }\n\n    single = wrapSingle(property);\n    single.all = properties;\n    single.position = i;\n    wrapped.unshift(single);\n  }\n\n  return wrapped;\n}\n\nfunction someVariableReferences(property) {\n  var i, l;\n  var value;\n\n  // skipping `property` and property name tokens\n  for (i = 2, l = property.length; i < l; i++) {\n    value = property[i];\n\n    if (value[0] != Token.PROPERTY_VALUE) {\n      continue;\n    }\n\n    if (isVariableReference(value[1])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isVariableReference(value) {\n  return Match.VARIABLE_REFERENCE_PATTERN.test(value);\n}\n\nfunction isMultiplex(property) {\n  var value;\n  var i, l;\n\n  for (i = 3, l = property.length; i < l; i++) {\n    value = property[i];\n\n    if (value[0] == Token.PROPERTY_VALUE && (value[1] == Marker.COMMA || value[1] == Marker.FORWARD_SLASH)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction hackFrom(property) {\n  var match = false;\n  var name = property[1][1];\n  var lastValue = property[property.length - 1];\n\n  if (name[0] == Match.UNDERSCORE) {\n    match = [Hack.UNDERSCORE];\n  } else if (name[0] == Match.ASTERISK) {\n    match = [Hack.ASTERISK];\n  } else if (lastValue[1][0] == Match.BANG && !lastValue[1].match(Match.IMPORTANT_WORD_PATTERN)) {\n    match = [Hack.BANG];\n  } else if (lastValue[1].indexOf(Match.BANG) > 0 && !lastValue[1].match(Match.IMPORTANT_WORD_PATTERN) && Match.BANG_SUFFIX_PATTERN.test(lastValue[1])) {\n    match = [Hack.BANG];\n  } else if (lastValue[1].indexOf(Match.BACKSLASH) > 0 && lastValue[1].indexOf(Match.BACKSLASH) == lastValue[1].length - Match.BACKSLASH.length - 1) {\n    match = [Hack.BACKSLASH, lastValue[1].substring(lastValue[1].indexOf(Match.BACKSLASH) + 1)];\n  } else if (lastValue[1].indexOf(Match.BACKSLASH) === 0 && lastValue[1].length == 2) {\n    match = [Hack.BACKSLASH, lastValue[1].substring(1)];\n  }\n\n  return match;\n}\n\nfunction isImportant(property) {\n  if (property.length < 3)\n    return false;\n\n  var lastValue = property[property.length - 1];\n  if (Match.IMPORTANT_TOKEN_PATTERN.test(lastValue[1])) {\n    return true;\n  } else if (Match.IMPORTANT_WORD_PATTERN.test(lastValue[1]) && Match.SUFFIX_BANG_PATTERN.test(property[property.length - 2][1])) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction stripImportant(property) {\n  var lastValue = property[property.length - 1];\n  var oneButLastValue = property[property.length - 2];\n\n  if (Match.IMPORTANT_TOKEN_PATTERN.test(lastValue[1])) {\n    lastValue[1] = lastValue[1].replace(Match.IMPORTANT_TOKEN_PATTERN, '');\n  } else {\n    lastValue[1] = lastValue[1].replace(Match.IMPORTANT_WORD_PATTERN, '');\n    oneButLastValue[1] = oneButLastValue[1].replace(Match.SUFFIX_BANG_PATTERN, '');\n  }\n\n  if (lastValue[1].length === 0) {\n    property.pop();\n  }\n\n  if (oneButLastValue[1].length === 0) {\n    property.pop();\n  }\n}\n\nfunction stripPrefixHack(property) {\n  property[1][1] = property[1][1].substring(1);\n}\n\nfunction stripSuffixHack(property, hackFrom) {\n  var lastValue = property[property.length - 1];\n  lastValue[1] = lastValue[1]\n    .substring(0, lastValue[1].indexOf(hackFrom[0] == Hack.BACKSLASH ? Match.BACKSLASH : Match.BANG))\n    .trim();\n\n  if (lastValue[1].length === 0) {\n    property.pop();\n  }\n}\n\nfunction wrapSingle(property) {\n  var importantProperty = isImportant(property);\n  if (importantProperty) {\n    stripImportant(property);\n  }\n\n  var whichHack = hackFrom(property);\n  if (whichHack[0] == Hack.ASTERISK || whichHack[0] == Hack.UNDERSCORE) {\n    stripPrefixHack(property);\n  } else if (whichHack[0] == Hack.BACKSLASH || whichHack[0] == Hack.BANG) {\n    stripSuffixHack(property, whichHack);\n  }\n\n  return {\n    block: property[2] && property[2][0] == Token.PROPERTY_BLOCK,\n    components: [],\n    dirty: false,\n    hack: whichHack,\n    important: importantProperty,\n    name: property[1][1],\n    multiplex: property.length > 3 ? isMultiplex(property) : false,\n    position: 0,\n    shorthand: false,\n    unused: false,\n    value: property.slice(2)\n  };\n}\n\nmodule.exports = {\n  all: wrapAll,\n  single: wrapSingle\n};\n",
    "243": "var roundingPrecisionFrom = require('./rounding-precision').roundingPrecisionFrom;\n\nvar override = require('../utils/override');\n\nvar OptimizationLevel = {\n  Zero: '0',\n  One: '1',\n  Two: '2'\n};\n\nvar DEFAULTS = {};\n\nDEFAULTS[OptimizationLevel.Zero] = {};\nDEFAULTS[OptimizationLevel.One] = {\n  cleanupCharsets: true,\n  normalizeUrls: true,\n  optimizeBackground: true,\n  optimizeBorderRadius: true,\n  optimizeFilter: true,\n  optimizeFontWeight: true,\n  optimizeOutline: true,\n  removeEmpty: true,\n  removeNegativePaddings: true,\n  removeQuotes: true,\n  removeWhitespace: true,\n  replaceMultipleZeros: true,\n  replaceTimeUnits: true,\n  replaceZeroUnits: true,\n  roundingPrecision: roundingPrecisionFrom(undefined),\n  selectorsSortingMethod: 'standard',\n  specialComments: 'all',\n  tidyAtRules: true,\n  tidyBlockScopes: true,\n  tidySelectors: true,\n  transform: noop\n};\nDEFAULTS[OptimizationLevel.Two] = {\n  mergeAdjacentRules: true,\n  mergeIntoShorthands: true,\n  mergeMedia: true,\n  mergeNonAdjacentRules: true,\n  mergeSemantically: false,\n  overrideProperties: true,\n  removeEmpty: true,\n  reduceNonAdjacentRules: true,\n  removeDuplicateFontRules: true,\n  removeDuplicateMediaBlocks: true,\n  removeDuplicateRules: true,\n  removeUnusedAtRules: false,\n  restructureRules: false,\n  skipProperties: []\n};\n\nvar ALL_KEYWORD_1 = '*';\nvar ALL_KEYWORD_2 = 'all';\nvar FALSE_KEYWORD_1 = 'false';\nvar FALSE_KEYWORD_2 = 'off';\nvar TRUE_KEYWORD_1 = 'true';\nvar TRUE_KEYWORD_2 = 'on';\n\nvar LIST_VALUE_SEPARATOR = ',';\nvar OPTION_SEPARATOR = ';';\nvar OPTION_VALUE_SEPARATOR = ':';\n\nfunction noop() {}\n\nfunction optimizationLevelFrom(source) {\n  var level = override(DEFAULTS, {});\n  var Zero = OptimizationLevel.Zero;\n  var One = OptimizationLevel.One;\n  var Two = OptimizationLevel.Two;\n\n\n  if (undefined === source) {\n    delete level[Two];\n    return level;\n  }\n\n  if (typeof source == 'string') {\n    source = parseInt(source);\n  }\n\n  if (typeof source == 'number' && source === parseInt(Two)) {\n    return level;\n  }\n\n  if (typeof source == 'number' && source === parseInt(One)) {\n    delete level[Two];\n    return level;\n  }\n\n  if (typeof source == 'number' && source === parseInt(Zero)) {\n    delete level[Two];\n    delete level[One];\n    return level;\n  }\n\n  if (typeof source == 'object') {\n    source = covertValuesToHashes(source);\n  }\n\n  if (One in source && 'roundingPrecision' in source[One]) {\n    source[One].roundingPrecision = roundingPrecisionFrom(source[One].roundingPrecision);\n  }\n\n  if (Two in source && 'skipProperties' in source[Two] && typeof(source[Two].skipProperties) == 'string') {\n    source[Two].skipProperties = source[Two].skipProperties.split(LIST_VALUE_SEPARATOR);\n  }\n\n  if (Zero in source || One in source || Two in source) {\n    level[Zero] = override(level[Zero], source[Zero]);\n  }\n\n  if (One in source && ALL_KEYWORD_1 in source[One]) {\n    level[One] = override(level[One], defaults(One, normalizeValue(source[One][ALL_KEYWORD_1])));\n    delete source[One][ALL_KEYWORD_1];\n  }\n\n  if (One in source && ALL_KEYWORD_2 in source[One]) {\n    level[One] = override(level[One], defaults(One, normalizeValue(source[One][ALL_KEYWORD_2])));\n    delete source[One][ALL_KEYWORD_2];\n  }\n\n  if (One in source || Two in source) {\n    level[One] = override(level[One], source[One]);\n  } else {\n    delete level[One];\n  }\n\n  if (Two in source && ALL_KEYWORD_1 in source[Two]) {\n    level[Two] = override(level[Two], defaults(Two, normalizeValue(source[Two][ALL_KEYWORD_1])));\n    delete source[Two][ALL_KEYWORD_1];\n  }\n\n  if (Two in source && ALL_KEYWORD_2 in source[Two]) {\n    level[Two] = override(level[Two], defaults(Two, normalizeValue(source[Two][ALL_KEYWORD_2])));\n    delete source[Two][ALL_KEYWORD_2];\n  }\n\n  if (Two in source) {\n    level[Two] = override(level[Two], source[Two]);\n  } else {\n    delete level[Two];\n  }\n\n  return level;\n}\n\nfunction defaults(level, value) {\n  var options = override(DEFAULTS[level], {});\n  var key;\n\n  for (key in options) {\n    if (typeof options[key] == 'boolean') {\n      options[key] = value;\n    }\n  }\n\n  return options;\n}\n\nfunction normalizeValue(value) {\n  switch (value) {\n    case FALSE_KEYWORD_1:\n    case FALSE_KEYWORD_2:\n      return false;\n    case TRUE_KEYWORD_1:\n    case TRUE_KEYWORD_2:\n      return true;\n    default:\n      return value;\n  }\n}\n\nfunction covertValuesToHashes(source) {\n  var clonedSource = override(source, {});\n  var level;\n  var i;\n\n  for (i = 0; i <= 2; i++) {\n    level = '' + i;\n\n    if (level in clonedSource && (clonedSource[level] === undefined || clonedSource[level] === false)) {\n      delete clonedSource[level];\n    }\n\n    if (level in clonedSource && clonedSource[level] === true) {\n      clonedSource[level] = {};\n    }\n\n    if (level in clonedSource && typeof clonedSource[level] == 'string') {\n      clonedSource[level] = covertToHash(clonedSource[level], level);\n    }\n  }\n\n  return clonedSource;\n}\n\nfunction covertToHash(asString, level) {\n  return asString\n    .split(OPTION_SEPARATOR)\n    .reduce(function (accumulator, directive) {\n      var parts = directive.split(OPTION_VALUE_SEPARATOR);\n      var name = parts[0];\n      var value = parts[1];\n      var normalizedValue = normalizeValue(value);\n\n      if (ALL_KEYWORD_1 == name || ALL_KEYWORD_2 == name) {\n        accumulator = override(accumulator, defaults(level, normalizedValue));\n      } else {\n        accumulator[name] = normalizedValue;\n      }\n\n      return accumulator;\n    }, {});\n}\n\nmodule.exports = {\n  OptimizationLevel: OptimizationLevel,\n  optimizationLevelFrom: optimizationLevelFrom,\n};\n",
    "246": "var helpers = require('./helpers');\n\nfunction store(serializeContext, token) {\n  serializeContext.output.push(typeof token == 'string' ? token : token[1]);\n}\n\nfunction context() {\n  var newContext = {\n    output: [],\n    store: store\n  };\n\n  return newContext;\n}\n\nfunction all(tokens) {\n  var oneTimeContext = context();\n  helpers.all(oneTimeContext, tokens);\n  return oneTimeContext.output.join('');\n}\n\nfunction body(tokens) {\n  var oneTimeContext = context();\n  helpers.body(oneTimeContext, tokens);\n  return oneTimeContext.output.join('');\n}\n\nfunction property(tokens, position) {\n  var oneTimeContext = context();\n  helpers.property(oneTimeContext, tokens, position, true);\n  return oneTimeContext.output.join('');\n}\n\nfunction rules(tokens) {\n  var oneTimeContext = context();\n  helpers.rules(oneTimeContext, tokens);\n  return oneTimeContext.output.join('');\n}\n\nfunction value(tokens) {\n  var oneTimeContext = context();\n  helpers.value(oneTimeContext, tokens);\n  return oneTimeContext.output.join('');\n}\n\nmodule.exports = {\n  all: all,\n  body: body,\n  property: property,\n  rules: rules,\n  value: value\n};\n",
    "247": "var emptyCharacter = '';\n\nvar Breaks = require('../options/format').Breaks;\nvar Spaces = require('../options/format').Spaces;\n\nvar Marker = require('../tokenizer/marker');\nvar Token = require('../tokenizer/token');\n\nfunction supportsAfterClosingBrace(token) {\n  return token[1][1] == 'background' || token[1][1] == 'transform' || token[1][1] == 'src';\n}\n\nfunction afterClosingBrace(token, valueIndex) {\n  return token[valueIndex][1][token[valueIndex][1].length - 1] == Marker.CLOSE_ROUND_BRACKET;\n}\n\nfunction afterComma(token, valueIndex) {\n  return token[valueIndex][1] == Marker.COMMA;\n}\n\nfunction afterSlash(token, valueIndex) {\n  return token[valueIndex][1] == Marker.FORWARD_SLASH;\n}\n\nfunction beforeComma(token, valueIndex) {\n  return token[valueIndex + 1] && token[valueIndex + 1][1] == Marker.COMMA;\n}\n\nfunction beforeSlash(token, valueIndex) {\n  return token[valueIndex + 1] && token[valueIndex + 1][1] == Marker.FORWARD_SLASH;\n}\n\nfunction inFilter(token) {\n  return token[1][1] == 'filter' || token[1][1] == '-ms-filter';\n}\n\nfunction disallowsSpace(context, token, valueIndex) {\n  return !context.spaceAfterClosingBrace && supportsAfterClosingBrace(token) && afterClosingBrace(token, valueIndex) ||\n    beforeSlash(token, valueIndex) ||\n    afterSlash(token, valueIndex) ||\n    beforeComma(token, valueIndex) ||\n    afterComma(token, valueIndex);\n}\n\nfunction rules(context, tokens) {\n  var store = context.store;\n\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    store(context, tokens[i]);\n\n    if (i < l - 1) {\n      store(context, comma(context));\n    }\n  }\n}\n\nfunction body(context, tokens) {\n  var lastPropertyAt = lastPropertyIndex(tokens);\n\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    property(context, tokens, i, lastPropertyAt);\n  }\n}\n\nfunction lastPropertyIndex(tokens) {\n  var index = tokens.length - 1;\n\n  for (; index >= 0; index--) {\n    if (tokens[index][0] != Token.COMMENT) {\n      break;\n    }\n  }\n\n  return index;\n}\n\nfunction property(context, tokens, position, lastPropertyAt) {\n  var store = context.store;\n  var token = tokens[position];\n\n  var propertyValue = token[2];\n  var isPropertyBlock = propertyValue && propertyValue[0] === Token.PROPERTY_BLOCK;\n\n  var needsSemicolon;\n  if ( context.format ) {\n    if ( context.format.semicolonAfterLastProperty || isPropertyBlock ) {\n      needsSemicolon = true;\n    } else if ( position < lastPropertyAt ) {\n      needsSemicolon = true;\n    } else {\n      needsSemicolon = false;\n    }\n  } else {\n    needsSemicolon = position < lastPropertyAt || isPropertyBlock;\n  }\n\n  var isLast = position === lastPropertyAt;\n\n  switch (token[0]) {\n    case Token.AT_RULE:\n      store(context, token);\n      store(context, semicolon(context, Breaks.AfterProperty, false));\n      break;\n    case Token.AT_RULE_BLOCK:\n      rules(context, token[1]);\n      store(context, openBrace(context, Breaks.AfterRuleBegins, true));\n      body(context, token[2]);\n      store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));\n      break;\n    case Token.COMMENT:\n      store(context, token);\n      break;\n    case Token.PROPERTY:\n      store(context, token[1]);\n      store(context, colon(context));\n      if (propertyValue) {\n        value(context, token);\n      }\n      store(context, needsSemicolon ? semicolon(context, Breaks.AfterProperty, isLast) : emptyCharacter);\n      break;\n    case Token.RAW:\n      store(context, token);\n  }\n}\n\nfunction value(context, token) {\n  var store = context.store;\n  var j, m;\n\n  if (token[2][0] == Token.PROPERTY_BLOCK) {\n    store(context, openBrace(context, Breaks.AfterBlockBegins, false));\n    body(context, token[2][1]);\n    store(context, closeBrace(context, Breaks.AfterBlockEnds, false, true));\n  } else {\n    for (j = 2, m = token.length; j < m; j++) {\n      store(context, token[j]);\n\n      if (j < m - 1 && (inFilter(token) || !disallowsSpace(context, token, j))) {\n        store(context, Marker.SPACE);\n      }\n    }\n  }\n}\n\nfunction allowsBreak(context, where) {\n  return context.format && context.format.breaks[where];\n}\n\nfunction allowsSpace(context, where) {\n  return context.format && context.format.spaces[where];\n}\n\nfunction openBrace(context, where, needsPrefixSpace) {\n  if (context.format) {\n    context.indentBy += context.format.indentBy;\n    context.indentWith = context.format.indentWith.repeat(context.indentBy);\n    return (needsPrefixSpace && allowsSpace(context, Spaces.BeforeBlockBegins) ? Marker.SPACE : emptyCharacter) +\n      Marker.OPEN_CURLY_BRACKET +\n      (allowsBreak(context, where) ? context.format.breakWith : emptyCharacter) +\n      context.indentWith;\n  } else {\n    return Marker.OPEN_CURLY_BRACKET;\n  }\n}\n\nfunction closeBrace(context, where, beforeBlockEnd, isLast) {\n  if (context.format) {\n    context.indentBy -= context.format.indentBy;\n    context.indentWith = context.format.indentWith.repeat(context.indentBy);\n    return (allowsBreak(context, Breaks.AfterProperty) || beforeBlockEnd && allowsBreak(context, Breaks.BeforeBlockEnds) ? context.format.breakWith : emptyCharacter) +\n      context.indentWith +\n      Marker.CLOSE_CURLY_BRACKET +\n      (isLast ? emptyCharacter : (allowsBreak(context, where) ? context.format.breakWith : emptyCharacter) + context.indentWith);\n  } else {\n    return Marker.CLOSE_CURLY_BRACKET;\n  }\n}\n\nfunction colon(context) {\n  return context.format ?\n    Marker.COLON + (allowsSpace(context, Spaces.BeforeValue) ? Marker.SPACE : emptyCharacter) :\n    Marker.COLON;\n}\n\nfunction semicolon(context, where, isLast) {\n  return context.format ?\n    Marker.SEMICOLON + (isLast || !allowsBreak(context, where) ? emptyCharacter : context.format.breakWith + context.indentWith) :\n    Marker.SEMICOLON;\n}\n\nfunction comma(context) {\n  return context.format ?\n    Marker.COMMA + (allowsBreak(context, Breaks.BetweenSelectors) ? context.format.breakWith : emptyCharacter) + context.indentWith :\n    Marker.COMMA;\n}\n\nfunction all(context, tokens) {\n  var store = context.store;\n  var token;\n  var isLast;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n    isLast = i == l - 1;\n\n    switch (token[0]) {\n      case Token.AT_RULE:\n        store(context, token);\n        store(context, semicolon(context, Breaks.AfterAtRule, isLast));\n        break;\n      case Token.AT_RULE_BLOCK:\n        rules(context, token[1]);\n        store(context, openBrace(context, Breaks.AfterRuleBegins, true));\n        body(context, token[2]);\n        store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));\n        break;\n      case Token.NESTED_BLOCK:\n        rules(context, token[1]);\n        store(context, openBrace(context, Breaks.AfterBlockBegins, true));\n        all(context, token[2]);\n        store(context, closeBrace(context, Breaks.AfterBlockEnds, true, isLast));\n        break;\n      case Token.COMMENT:\n        store(context, token);\n        store(context, allowsBreak(context, Breaks.AfterComment) ? context.format.breakWith : emptyCharacter);\n        break;\n      case Token.RAW:\n        store(context, token);\n        break;\n      case Token.RULE:\n        rules(context, token[1]);\n        store(context, openBrace(context, Breaks.AfterRuleBegins, true));\n        body(context, token[2]);\n        store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));\n        break;\n    }\n  }\n}\n\nmodule.exports = {\n  all: all,\n  body: body,\n  property: property,\n  rules: rules,\n  value: value\n};\n",
    "286": "var functionNoVendorRegexStr = '[A-Z]+(\\\\-|[A-Z]|[0-9])+\\\\(.*?\\\\)';\nvar functionVendorRegexStr = '\\\\-(\\\\-|[A-Z]|[0-9])+\\\\(.*?\\\\)';\nvar variableRegexStr = 'var\\\\(\\\\-\\\\-[^\\\\)]+\\\\)';\nvar functionAnyRegexStr = '(' + variableRegexStr + '|' + functionNoVendorRegexStr + '|' + functionVendorRegexStr + ')';\n\nvar calcRegex = new RegExp('^(\\\\-moz\\\\-|\\\\-webkit\\\\-)?calc\\\\([^\\\\)]+\\\\)$', 'i');\nvar decimalRegex = /[0-9]/;\nvar functionAnyRegex = new RegExp('^' + functionAnyRegexStr + '$', 'i');\nvar hslColorRegex = /^hsl\\(\\s{0,31}[\\-\\.]?\\d+\\s{0,31},\\s{0,31}\\.?\\d+%\\s{0,31},\\s{0,31}\\.?\\d+%\\s{0,31}\\)|hsla\\(\\s{0,31}[\\-\\.]?\\d+\\s{0,31},\\s{0,31}\\.?\\d+%\\s{0,31},\\s{0,31}\\.?\\d+%\\s{0,31},\\s{0,31}\\.?\\d+\\s{0,31}\\)$/i;\nvar identifierRegex = /^(\\-[a-z0-9_][a-z0-9\\-_]*|[a-z][a-z0-9\\-_]*)$/i;\nvar namedEntityRegex = /^[a-z]+$/i;\nvar prefixRegex = /^-([a-z0-9]|-)*$/i;\nvar rgbColorRegex = /^rgb\\(\\s{0,31}[\\d]{1,3}\\s{0,31},\\s{0,31}[\\d]{1,3}\\s{0,31},\\s{0,31}[\\d]{1,3}\\s{0,31}\\)|rgba\\(\\s{0,31}[\\d]{1,3}\\s{0,31},\\s{0,31}[\\d]{1,3}\\s{0,31},\\s{0,31}[\\d]{1,3}\\s{0,31},\\s{0,31}[\\.\\d]+\\s{0,31}\\)$/i;\nvar timingFunctionRegex = /^(cubic\\-bezier|steps)\\([^\\)]+\\)$/;\nvar validTimeUnits = ['ms', 's'];\nvar urlRegex = /^url\\([\\s\\S]+\\)$/i;\nvar variableRegex = new RegExp('^' + variableRegexStr + '$', 'i');\n\nvar eightValueColorRegex = /^#[0-9a-f]{8}$/i;\nvar fourValueColorRegex = /^#[0-9a-f]{4}$/i;\nvar sixValueColorRegex = /^#[0-9a-f]{6}$/i;\nvar threeValueColorRegex = /^#[0-9a-f]{3}$/i;\n\nvar DECIMAL_DOT = '.';\nvar MINUS_SIGN = '-';\nvar PLUS_SIGN = '+';\n\nvar Keywords = {\n  '^': [\n    'inherit',\n    'initial',\n    'unset'\n  ],\n  '*-style': [\n    'auto',\n    'dashed',\n    'dotted',\n    'double',\n    'groove',\n    'hidden',\n    'inset',\n    'none',\n    'outset',\n    'ridge',\n    'solid'\n  ],\n  '*-timing-function': [\n    'ease',\n    'ease-in',\n    'ease-in-out',\n    'ease-out',\n    'linear',\n    'step-end',\n    'step-start'\n  ],\n  'animation-direction': [\n    'alternate',\n    'alternate-reverse',\n    'normal',\n    'reverse'\n  ],\n  'animation-fill-mode': [\n    'backwards',\n    'both',\n    'forwards',\n    'none'\n  ],\n  'animation-iteration-count': [\n    'infinite'\n  ],\n  'animation-name': [\n    'none'\n  ],\n  'animation-play-state': [\n    'paused',\n    'running'\n  ],\n  'background-attachment': [\n    'fixed',\n    'inherit',\n    'local',\n    'scroll'\n  ],\n  'background-clip': [\n    'border-box',\n    'content-box',\n    'inherit',\n    'padding-box',\n    'text'\n  ],\n  'background-origin': [\n    'border-box',\n    'content-box',\n    'inherit',\n    'padding-box'\n  ],\n  'background-position': [\n    'bottom',\n    'center',\n    'left',\n    'right',\n    'top'\n  ],\n  'background-repeat': [\n    'no-repeat',\n    'inherit',\n    'repeat',\n    'repeat-x',\n    'repeat-y',\n    'round',\n    'space'\n  ],\n  'background-size': [\n    'auto',\n    'cover',\n    'contain'\n  ],\n  'border-collapse': [\n    'collapse',\n    'inherit',\n    'separate'\n  ],\n  'bottom': [\n    'auto'\n  ],\n  'clear': [\n    'both',\n    'left',\n    'none',\n    'right'\n  ],\n  'color': [\n    'transparent'\n  ],\n  'cursor': [\n    'all-scroll',\n    'auto',\n    'col-resize',\n    'crosshair',\n    'default',\n    'e-resize',\n    'help',\n    'move',\n    'n-resize',\n    'ne-resize',\n    'no-drop',\n    'not-allowed',\n    'nw-resize',\n    'pointer',\n    'progress',\n    'row-resize',\n    's-resize',\n    'se-resize',\n    'sw-resize',\n    'text',\n    'vertical-text',\n    'w-resize',\n    'wait'\n  ],\n  'display': [\n    'block',\n    'inline',\n    'inline-block',\n    'inline-table',\n    'list-item',\n    'none',\n    'table',\n    'table-caption',\n    'table-cell',\n    'table-column',\n    'table-column-group',\n    'table-footer-group',\n    'table-header-group',\n    'table-row',\n    'table-row-group'\n  ],\n  'float': [\n    'left',\n    'none',\n    'right'\n  ],\n  'left': [\n    'auto'\n  ],\n  'font': [\n    'caption',\n    'icon',\n    'menu',\n    'message-box',\n    'small-caption',\n    'status-bar',\n    'unset'\n  ],\n  'font-size': [\n    'large',\n    'larger',\n    'medium',\n    'small',\n    'smaller',\n    'x-large',\n    'x-small',\n    'xx-large',\n    'xx-small'\n  ],\n  'font-stretch': [\n    'condensed',\n    'expanded',\n    'extra-condensed',\n    'extra-expanded',\n    'normal',\n    'semi-condensed',\n    'semi-expanded',\n    'ultra-condensed',\n    'ultra-expanded'\n  ],\n  'font-style': [\n    'italic',\n    'normal',\n    'oblique'\n  ],\n  'font-variant': [\n    'normal',\n    'small-caps'\n  ],\n  'font-weight': [\n    '100',\n    '200',\n    '300',\n    '400',\n    '500',\n    '600',\n    '700',\n    '800',\n    '900',\n    'bold',\n    'bolder',\n    'lighter',\n    'normal'\n  ],\n  'line-height': [\n    'normal'\n  ],\n  'list-style-position': [\n    'inside',\n    'outside'\n  ],\n  'list-style-type': [\n    'armenian',\n    'circle',\n    'decimal',\n    'decimal-leading-zero',\n    'disc',\n    'decimal|disc', // this is the default value of list-style-type, see comment in compactable.js\n    'georgian',\n    'lower-alpha',\n    'lower-greek',\n    'lower-latin',\n    'lower-roman',\n    'none',\n    'square',\n    'upper-alpha',\n    'upper-latin',\n    'upper-roman'\n  ],\n  'overflow': [\n    'auto',\n    'hidden',\n    'scroll',\n    'visible'\n  ],\n  'position': [\n    'absolute',\n    'fixed',\n    'relative',\n    'static'\n  ],\n  'right': [\n    'auto'\n  ],\n  'text-align': [\n    'center',\n    'justify',\n    'left',\n    'left|right', // this is the default value of list-style-type, see comment in compactable.js\n    'right'\n  ],\n  'text-decoration': [\n    'line-through',\n    'none',\n    'overline',\n    'underline'\n  ],\n  'text-overflow': [\n    'clip',\n    'ellipsis'\n  ],\n  'top': [\n    'auto'\n  ],\n  'vertical-align': [\n    'baseline',\n    'bottom',\n    'middle',\n    'sub',\n    'super',\n    'text-bottom',\n    'text-top',\n    'top'\n  ],\n  'visibility': [\n    'collapse',\n    'hidden',\n    'visible'\n  ],\n  'white-space': [\n    'normal',\n    'nowrap',\n    'pre'\n  ],\n  'width': [\n    'inherit',\n    'initial',\n    'medium',\n    'thick',\n    'thin'\n  ]\n};\n\nvar Units = [\n  '%',\n  'ch',\n  'cm',\n  'em',\n  'ex',\n  'in',\n  'mm',\n  'pc',\n  'pt',\n  'px',\n  'rem',\n  'vh',\n  'vm',\n  'vmax',\n  'vmin',\n  'vw'\n];\n\nfunction isColor(value) {\n  return value != 'auto' &&\n    (\n      isKeyword('color')(value) ||\n      isHexColor(value) ||\n      isColorFunction(value) ||\n      isNamedEntity(value)\n    );\n}\n\nfunction isColorFunction(value) {\n  return isRgbColor(value) || isHslColor(value);\n}\n\nfunction isDynamicUnit(value) {\n  return calcRegex.test(value);\n}\n\nfunction isFunction(value) {\n  return functionAnyRegex.test(value);\n}\n\nfunction isHexColor(value) {\n  return threeValueColorRegex.test(value) || fourValueColorRegex.test(value) || sixValueColorRegex.test(value) || eightValueColorRegex.test(value);\n}\n\nfunction isHslColor(value) {\n  return hslColorRegex.test(value);\n}\n\nfunction isIdentifier(value) {\n  return identifierRegex.test(value);\n}\n\nfunction isImage(value) {\n  return value == 'none' || value == 'inherit' || isUrl(value);\n}\n\nfunction isKeyword(propertyName) {\n  return function(value) {\n    return Keywords[propertyName].indexOf(value) > -1;\n  };\n}\n\nfunction isNamedEntity(value) {\n  return namedEntityRegex.test(value);\n}\n\nfunction isNumber(value) {\n  return scanForNumber(value) == value.length;\n}\n\nfunction isRgbColor(value) {\n  return rgbColorRegex.test(value);\n}\n\nfunction isPrefixed(value) {\n  return prefixRegex.test(value);\n}\n\nfunction isPositiveNumber(value) {\n  return isNumber(value) &&\n    parseFloat(value) >= 0;\n}\n\nfunction isVariable(value) {\n  return variableRegex.test(value);\n}\n\nfunction isTime(value) {\n  var numberUpTo = scanForNumber(value);\n\n  return numberUpTo == value.length && parseInt(value) === 0 ||\n    numberUpTo > -1 && validTimeUnits.indexOf(value.slice(numberUpTo + 1)) > -1;\n}\n\nfunction isTimingFunction() {\n  var isTimingFunctionKeyword = isKeyword('*-timing-function');\n\n  return function (value) {\n    return isTimingFunctionKeyword(value) || timingFunctionRegex.test(value);\n  };\n}\n\nfunction isUnit(validUnits, value) {\n  var numberUpTo = scanForNumber(value);\n\n  return numberUpTo == value.length && parseInt(value) === 0 ||\n    numberUpTo > -1 && validUnits.indexOf(value.slice(numberUpTo + 1)) > -1 ||\n    value == 'auto' ||\n    value == 'inherit';\n}\n\nfunction isUrl(value) {\n  return urlRegex.test(value);\n}\n\nfunction isZIndex(value) {\n  return value == 'auto' ||\n    isNumber(value) ||\n    isKeyword('^')(value);\n}\n\nfunction scanForNumber(value) {\n  var hasDot = false;\n  var hasSign = false;\n  var character;\n  var i, l;\n\n  for (i = 0, l = value.length; i < l; i++) {\n    character = value[i];\n\n    if (i === 0 && (character == PLUS_SIGN || character == MINUS_SIGN)) {\n      hasSign = true;\n    } else if (i > 0 && hasSign && (character == PLUS_SIGN || character == MINUS_SIGN)) {\n      return i - 1;\n    } else if (character == DECIMAL_DOT && !hasDot) {\n      hasDot = true;\n    } else if (character == DECIMAL_DOT && hasDot) {\n      return i - 1;\n    } else if (decimalRegex.test(character)) {\n      continue;\n    } else {\n      return i - 1;\n    }\n  }\n\n  return i;\n}\n\nfunction validator(compatibility) {\n  var validUnits = Units.slice(0).filter(function (value) {\n    return !(value in compatibility.units) || compatibility.units[value] === true;\n  });\n\n  return {\n    colorOpacity: compatibility.colors.opacity,\n    isAnimationDirectionKeyword: isKeyword('animation-direction'),\n    isAnimationFillModeKeyword: isKeyword('animation-fill-mode'),\n    isAnimationIterationCountKeyword: isKeyword('animation-iteration-count'),\n    isAnimationNameKeyword: isKeyword('animation-name'),\n    isAnimationPlayStateKeyword: isKeyword('animation-play-state'),\n    isTimingFunction: isTimingFunction(),\n    isBackgroundAttachmentKeyword: isKeyword('background-attachment'),\n    isBackgroundClipKeyword: isKeyword('background-clip'),\n    isBackgroundOriginKeyword: isKeyword('background-origin'),\n    isBackgroundPositionKeyword: isKeyword('background-position'),\n    isBackgroundRepeatKeyword: isKeyword('background-repeat'),\n    isBackgroundSizeKeyword: isKeyword('background-size'),\n    isColor: isColor,\n    isColorFunction: isColorFunction,\n    isDynamicUnit: isDynamicUnit,\n    isFontKeyword: isKeyword('font'),\n    isFontSizeKeyword: isKeyword('font-size'),\n    isFontStretchKeyword: isKeyword('font-stretch'),\n    isFontStyleKeyword: isKeyword('font-style'),\n    isFontVariantKeyword: isKeyword('font-variant'),\n    isFontWeightKeyword: isKeyword('font-weight'),\n    isFunction: isFunction,\n    isGlobal: isKeyword('^'),\n    isHslColor: isHslColor,\n    isIdentifier: isIdentifier,\n    isImage: isImage,\n    isKeyword: isKeyword,\n    isLineHeightKeyword: isKeyword('line-height'),\n    isListStylePositionKeyword: isKeyword('list-style-position'),\n    isListStyleTypeKeyword: isKeyword('list-style-type'),\n    isNumber: isNumber,\n    isPrefixed: isPrefixed,\n    isPositiveNumber: isPositiveNumber,\n    isRgbColor: isRgbColor,\n    isStyleKeyword: isKeyword('*-style'),\n    isTime: isTime,\n    isUnit: isUnit.bind(null, validUnits),\n    isUrl: isUrl,\n    isVariable: isVariable,\n    isWidth: isKeyword('width'),\n    isZIndex: isZIndex\n  };\n}\n\nmodule.exports = validator;\n",
    "287": "var DEFAULTS = {\n  '*': {\n    colors: {\n      opacity: true // rgba / hsla\n    },\n    properties: {\n      backgroundClipMerging: true, // background-clip to shorthand\n      backgroundOriginMerging: true, // background-origin to shorthand\n      backgroundSizeMerging: true, // background-size to shorthand\n      colors: true, // any kind of color transformations, like `#ff00ff` to `#f0f` or `#fff` into `red`\n      ieBangHack: false, // !ie suffix hacks on IE<8\n      ieFilters: false, // whether to preserve `filter` and `-ms-filter` properties\n      iePrefixHack: false, // underscore / asterisk prefix hacks on IE\n      ieSuffixHack: false, // \\9 suffix hacks on IE6-9\n      merging: true, // merging properties into one\n      shorterLengthUnits: false, // optimize pixel units into `pt`, `pc` or `in` units\n      spaceAfterClosingBrace: true, // 'url() no-repeat' to 'url()no-repeat'\n      urlQuotes: false, // whether to wrap content of `url()` into quotes or not\n      zeroUnits: true // 0[unit] -> 0\n    },\n    selectors: {\n      adjacentSpace: false, // div+ nav Android stock browser hack\n      ie7Hack: false, // *+html hack\n      mergeablePseudoClasses: [\n        ':active',\n        ':after',\n        ':before',\n        ':empty',\n        ':checked',\n        ':disabled',\n        ':empty',\n        ':enabled',\n        ':first-child',\n        ':first-letter',\n        ':first-line',\n        ':first-of-type',\n        ':focus',\n        ':hover',\n        ':lang',\n        ':last-child',\n        ':last-of-type',\n        ':link',\n        ':not',\n        ':nth-child',\n        ':nth-last-child',\n        ':nth-last-of-type',\n        ':nth-of-type',\n        ':only-child',\n        ':only-of-type',\n        ':root',\n        ':target',\n        ':visited'\n      ], // selectors with these pseudo-classes can be merged as these are universally supported\n      mergeablePseudoElements: [\n        '::after',\n        '::before',\n        '::first-letter',\n        '::first-line'\n      ], // selectors with these pseudo-elements can be merged as these are universally supported\n      mergeLimit: 8191, // number of rules that can be safely merged together\n      multiplePseudoMerging: true\n    },\n    units: {\n      ch: true,\n      in: true,\n      pc: true,\n      pt: true,\n      rem: true,\n      vh: true,\n      vm: true, // vm is vmin on IE9+ see https://developer.mozilla.org/en-US/docs/Web/CSS/length\n      vmax: true,\n      vmin: true,\n      vw: true\n    }\n  }\n};\n\nDEFAULTS.ie11 = DEFAULTS['*'];\n\nDEFAULTS.ie10 = DEFAULTS['*'];\n\nDEFAULTS.ie9 = merge(DEFAULTS['*'], {\n  properties: {\n    ieFilters: true,\n    ieSuffixHack: true\n  }\n});\n\nDEFAULTS.ie8 = merge(DEFAULTS.ie9, {\n  colors: {\n    opacity: false\n  },\n  properties: {\n    backgroundClipMerging: false,\n    backgroundOriginMerging: false,\n    backgroundSizeMerging: false,\n    iePrefixHack: true,\n    merging: false\n  },\n  selectors: {\n    mergeablePseudoClasses: [\n      ':after',\n      ':before',\n      ':first-child',\n      ':first-letter',\n      ':focus',\n      ':hover',\n      ':visited'\n    ],\n    mergeablePseudoElements: []\n  },\n  units: {\n    ch: false,\n    rem: false,\n    vh: false,\n    vm: false,\n    vmax: false,\n    vmin: false,\n    vw: false\n  }\n});\n\nDEFAULTS.ie7 = merge(DEFAULTS.ie8, {\n  properties: {\n    ieBangHack: true\n  },\n  selectors: {\n    ie7Hack: true,\n    mergeablePseudoClasses: [\n      ':first-child',\n      ':first-letter',\n      ':hover',\n      ':visited'\n    ]\n  },\n});\n\nfunction compatibilityFrom(source) {\n  return merge(DEFAULTS['*'], calculateSource(source));\n}\n\nfunction merge(source, target) {\n  for (var key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      var value = source[key];\n\n      if (Object.prototype.hasOwnProperty.call(target, key) && typeof value === 'object' && !Array.isArray(value)) {\n        target[key] = merge(value, target[key] || {});\n      } else {\n        target[key] = key in target ? target[key] : value;\n      }\n    }\n  }\n\n  return target;\n}\n\nfunction calculateSource(source) {\n  if (typeof source == 'object')\n    return source;\n\n  if (!/[,\\+\\-]/.test(source))\n    return DEFAULTS[source] || DEFAULTS['*'];\n\n  var parts = source.split(',');\n  var template = parts[0] in DEFAULTS ?\n    DEFAULTS[parts.shift()] :\n    DEFAULTS['*'];\n\n  source = {};\n\n  parts.forEach(function (part) {\n    var isAdd = part[0] == '+';\n    var key = part.substring(1).split('.');\n    var group = key[0];\n    var option = key[1];\n\n    source[group] = source[group] || {};\n    source[group][option] = isAdd;\n  });\n\n  return merge(template, source);\n}\n\nmodule.exports = compatibilityFrom;\n",
    "309": "var url = require('url');\n\nvar override = require('../utils/override');\n\nfunction inlineRequestFrom(option) {\n  return override(\n    /* jshint camelcase: false */\n    proxyOptionsFrom(process.env.HTTP_PROXY || process.env.http_proxy),\n    option || {}\n  );\n}\n\nfunction proxyOptionsFrom(httpProxy) {\n  return httpProxy ?\n    {\n      hostname: url.parse(httpProxy).hostname,\n      port: parseInt(url.parse(httpProxy).port)\n    } :\n    {};\n}\n\nmodule.exports = inlineRequestFrom;\n",
    "313": "var SourceMapConsumer = require('source-map').SourceMapConsumer;\n\nfunction inputSourceMapTracker() {\n  var maps = {};\n\n  return {\n    all: all.bind(null, maps),\n    isTracking: isTracking.bind(null, maps),\n    originalPositionFor: originalPositionFor.bind(null, maps),\n    track: track.bind(null, maps)\n  };\n}\n\nfunction all(maps) {\n  return maps;\n}\n\nfunction isTracking(maps, source) {\n  return source in maps;\n}\n\nfunction originalPositionFor(maps, metadata, range, selectorFallbacks) {\n  var line = metadata[0];\n  var column = metadata[1];\n  var source = metadata[2];\n  var position = {\n    line: line,\n    column: column + range\n  };\n  var originalPosition;\n\n  while (!originalPosition && position.column > column) {\n    position.column--;\n    originalPosition = maps[source].originalPositionFor(position);\n  }\n\n  if (!originalPosition || originalPosition.column < 0) {\n    return metadata;\n  }\n\n  if (originalPosition.line === null && line > 1 && selectorFallbacks > 0) {\n    return originalPositionFor(maps, [line - 1, column, source], range, selectorFallbacks - 1);\n  }\n\n  return originalPosition.line !== null ?\n    toMetadata(originalPosition) :\n    metadata;\n}\n\nfunction toMetadata(asHash) {\n  return [asHash.line, asHash.column, asHash.source];\n}\n\nfunction track(maps, source, data) {\n  maps[source] = new SourceMapConsumer(data);\n}\n\nmodule.exports = inputSourceMapTracker;\n",
    "325": "var fs = require('fs');\nvar path = require('path');\n\nvar applySourceMaps = require('./apply-source-maps');\nvar extractImportUrlAndMedia = require('./extract-import-url-and-media');\nvar isAllowedResource = require('./is-allowed-resource');\nvar loadOriginalSources = require('./load-original-sources');\nvar normalizePath = require('./normalize-path');\nvar rebase = require('./rebase');\nvar rebaseLocalMap = require('./rebase-local-map');\nvar rebaseRemoteMap = require('./rebase-remote-map');\nvar restoreImport = require('./restore-import');\n\nvar tokenize = require('../tokenizer/tokenize');\nvar Token = require('../tokenizer/token');\nvar Marker = require('../tokenizer/marker');\nvar hasProtocol = require('../utils/has-protocol');\nvar isImport = require('../utils/is-import');\nvar isRemoteResource = require('../utils/is-remote-resource');\n\nvar UNKNOWN_URI = 'uri:unknown';\n\nfunction readSources(input, context, callback) {\n  return doReadSources(input, context, function (tokens) {\n    return applySourceMaps(tokens, context, function () {\n      return loadOriginalSources(context, function () { return callback(tokens); });\n    });\n  });\n}\n\nfunction doReadSources(input, context, callback) {\n  if (typeof input == 'string') {\n    return fromString(input, context, callback);\n  } else if (Buffer.isBuffer(input)) {\n    return fromString(input.toString(), context, callback);\n  } else if (Array.isArray(input)) {\n    return fromArray(input, context, callback);\n  } else if (typeof input == 'object') {\n    return fromHash(input, context, callback);\n  }\n}\n\nfunction fromString(input, context, callback) {\n  context.source = undefined;\n  context.sourcesContent[undefined] = input;\n  context.stats.originalSize += input.length;\n\n  return fromStyles(input, context, { inline: context.options.inline }, callback);\n}\n\nfunction fromArray(input, context, callback) {\n  var inputAsImports = input.reduce(function (accumulator, uriOrHash) {\n    if (typeof uriOrHash === 'string') {\n      return addStringSource(uriOrHash, accumulator);\n    } else {\n      return addHashSource(uriOrHash, context, accumulator);\n    }\n\n  }, []);\n\n  return fromStyles(inputAsImports.join(''), context, { inline: ['all'] }, callback);\n}\n\nfunction fromHash(input, context, callback) {\n  var inputAsImports = addHashSource(input, context, []);\n  return fromStyles(inputAsImports.join(''), context, { inline: ['all'] }, callback);\n}\n\nfunction addStringSource(input, imports) {\n  imports.push(restoreAsImport(normalizeUri(input)));\n  return imports;\n}\n\nfunction addHashSource(input, context, imports) {\n  var uri;\n  var normalizedUri;\n  var source;\n\n  for (uri in input) {\n    source = input[uri];\n    normalizedUri = normalizeUri(uri);\n\n    imports.push(restoreAsImport(normalizedUri));\n\n    context.sourcesContent[normalizedUri] = source.styles;\n\n    if (source.sourceMap) {\n      trackSourceMap(source.sourceMap, normalizedUri, context);\n    }\n  }\n\n  return imports;\n}\n\nfunction normalizeUri(uri) {\n  var currentPath = path.resolve('');\n  var absoluteUri;\n  var relativeToCurrentPath;\n  var normalizedUri;\n\n  if (isRemoteResource(uri)) {\n    return uri;\n  }\n\n  absoluteUri = path.isAbsolute(uri) ?\n    uri :\n    path.resolve(uri);\n  relativeToCurrentPath = path.relative(currentPath, absoluteUri);\n  normalizedUri = normalizePath(relativeToCurrentPath);\n\n  return normalizedUri;\n}\n\nfunction trackSourceMap(sourceMap, uri, context) {\n  var parsedMap = typeof sourceMap == 'string' ?\n      JSON.parse(sourceMap) :\n      sourceMap;\n  var rebasedMap = isRemoteResource(uri) ?\n    rebaseRemoteMap(parsedMap, uri) :\n    rebaseLocalMap(parsedMap, uri || UNKNOWN_URI, context.options.rebaseTo);\n\n  context.inputSourceMapTracker.track(uri, rebasedMap);\n}\n\nfunction restoreAsImport(uri) {\n  return restoreImport('url(' + uri + ')', '') + Marker.SEMICOLON;\n}\n\nfunction fromStyles(styles, context, parentInlinerContext, callback) {\n  var tokens;\n  var rebaseConfig = {};\n\n  if (!context.source) {\n    rebaseConfig.fromBase = path.resolve('');\n    rebaseConfig.toBase = context.options.rebaseTo;\n  } else if (isRemoteResource(context.source)) {\n    rebaseConfig.fromBase = context.source;\n    rebaseConfig.toBase = context.source;\n  } else if (path.isAbsolute(context.source)) {\n    rebaseConfig.fromBase = path.dirname(context.source);\n    rebaseConfig.toBase = context.options.rebaseTo;\n  } else {\n    rebaseConfig.fromBase = path.dirname(path.resolve(context.source));\n    rebaseConfig.toBase = context.options.rebaseTo;\n  }\n\n  tokens = tokenize(styles, context);\n  tokens = rebase(tokens, context.options.rebase, context.validator, rebaseConfig);\n\n  return allowsAnyImports(parentInlinerContext.inline) ?\n    inline(tokens, context, parentInlinerContext, callback) :\n    callback(tokens);\n}\n\nfunction allowsAnyImports(inline) {\n  return !(inline.length == 1 && inline[0] == 'none');\n}\n\nfunction inline(tokens, externalContext, parentInlinerContext, callback) {\n  var inlinerContext = {\n    afterContent: false,\n    callback: callback,\n    errors: externalContext.errors,\n    externalContext: externalContext,\n    fetch: externalContext.options.fetch,\n    inlinedStylesheets: parentInlinerContext.inlinedStylesheets || externalContext.inlinedStylesheets,\n    inline: parentInlinerContext.inline,\n    inlineRequest: externalContext.options.inlineRequest,\n    inlineTimeout: externalContext.options.inlineTimeout,\n    isRemote: parentInlinerContext.isRemote || false,\n    localOnly: externalContext.localOnly,\n    outputTokens: [],\n    rebaseTo: externalContext.options.rebaseTo,\n    sourceTokens: tokens,\n    warnings: externalContext.warnings\n  };\n\n  return doInlineImports(inlinerContext);\n}\n\nfunction doInlineImports(inlinerContext) {\n  var token;\n  var i, l;\n\n  for (i = 0, l = inlinerContext.sourceTokens.length; i < l; i++) {\n    token = inlinerContext.sourceTokens[i];\n\n    if (token[0] == Token.AT_RULE && isImport(token[1])) {\n      inlinerContext.sourceTokens.splice(0, i);\n      return inlineStylesheet(token, inlinerContext);\n    } else if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT) {\n      inlinerContext.outputTokens.push(token);\n    } else {\n      inlinerContext.outputTokens.push(token);\n      inlinerContext.afterContent = true;\n    }\n  }\n\n  inlinerContext.sourceTokens = [];\n  return inlinerContext.callback(inlinerContext.outputTokens);\n}\n\nfunction inlineStylesheet(token, inlinerContext) {\n  var uriAndMediaQuery = extractImportUrlAndMedia(token[1]);\n  var uri = uriAndMediaQuery[0];\n  var mediaQuery = uriAndMediaQuery[1];\n  var metadata = token[2];\n\n  return isRemoteResource(uri) ?\n    inlineRemoteStylesheet(uri, mediaQuery, metadata, inlinerContext) :\n    inlineLocalStylesheet(uri, mediaQuery, metadata, inlinerContext);\n}\n\nfunction inlineRemoteStylesheet(uri, mediaQuery, metadata, inlinerContext) {\n  var isAllowed = isAllowedResource(uri, true, inlinerContext.inline);\n  var originalUri = uri;\n  var isLoaded = uri in inlinerContext.externalContext.sourcesContent;\n  var isRuntimeResource = !hasProtocol(uri);\n\n  if (inlinerContext.inlinedStylesheets.indexOf(uri) > -1) {\n    inlinerContext.warnings.push('Ignoring remote @import of \"' + uri + '\" as it has already been imported.');\n    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n    return doInlineImports(inlinerContext);\n  } else if (inlinerContext.localOnly && inlinerContext.afterContent) {\n    inlinerContext.warnings.push('Ignoring remote @import of \"' + uri + '\" as no callback given and after other content.');\n    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n    return doInlineImports(inlinerContext);\n  } else if (isRuntimeResource) {\n    inlinerContext.warnings.push('Skipping remote @import of \"' + uri + '\" as no protocol given.');\n    inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));\n    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n    return doInlineImports(inlinerContext);\n  } else if (inlinerContext.localOnly && !isLoaded) {\n    inlinerContext.warnings.push('Skipping remote @import of \"' + uri + '\" as no callback given.');\n    inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));\n    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n    return doInlineImports(inlinerContext);\n  } else if (!isAllowed && inlinerContext.afterContent) {\n    inlinerContext.warnings.push('Ignoring remote @import of \"' + uri + '\" as resource is not allowed and after other content.');\n    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n    return doInlineImports(inlinerContext);\n  } else if (!isAllowed) {\n    inlinerContext.warnings.push('Skipping remote @import of \"' + uri + '\" as resource is not allowed.');\n    inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));\n    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n    return doInlineImports(inlinerContext);\n  }\n\n  inlinerContext.inlinedStylesheets.push(uri);\n\n  function whenLoaded(error, importedStyles) {\n    if (error) {\n      inlinerContext.errors.push('Broken @import declaration of \"' + uri + '\" - ' + error);\n\n      return process.nextTick(function () {\n        inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));\n        inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n        doInlineImports(inlinerContext);\n      });\n    }\n\n    inlinerContext.inline = inlinerContext.externalContext.options.inline;\n    inlinerContext.isRemote = true;\n\n    inlinerContext.externalContext.source = originalUri;\n    inlinerContext.externalContext.sourcesContent[uri] = importedStyles;\n    inlinerContext.externalContext.stats.originalSize += importedStyles.length;\n\n    return fromStyles(importedStyles, inlinerContext.externalContext, inlinerContext, function (importedTokens) {\n      importedTokens = wrapInMedia(importedTokens, mediaQuery, metadata);\n\n      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(importedTokens);\n      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n\n      return doInlineImports(inlinerContext);\n    });\n  }\n\n  return isLoaded ?\n    whenLoaded(null, inlinerContext.externalContext.sourcesContent[uri]) :\n    inlinerContext.fetch(uri, inlinerContext.inlineRequest, inlinerContext.inlineTimeout, whenLoaded);\n}\n\nfunction inlineLocalStylesheet(uri, mediaQuery, metadata, inlinerContext) {\n  var currentPath = path.resolve('');\n  var absoluteUri = path.isAbsolute(uri) ?\n    path.resolve(currentPath, uri[0] == '/' ? uri.substring(1) : uri) :\n    path.resolve(inlinerContext.rebaseTo, uri);\n  var relativeToCurrentPath = path.relative(currentPath, absoluteUri);\n  var importedStyles;\n  var isAllowed = isAllowedResource(uri, false, inlinerContext.inline);\n  var normalizedPath = normalizePath(relativeToCurrentPath);\n  var isLoaded = normalizedPath in inlinerContext.externalContext.sourcesContent;\n\n  if (inlinerContext.inlinedStylesheets.indexOf(absoluteUri) > -1) {\n    inlinerContext.warnings.push('Ignoring local @import of \"' + uri + '\" as it has already been imported.');\n  } else if (!isLoaded && (!fs.existsSync(absoluteUri) || !fs.statSync(absoluteUri).isFile())) {\n    inlinerContext.errors.push('Ignoring local @import of \"' + uri + '\" as resource is missing.');\n  } else if (!isAllowed && inlinerContext.afterContent) {\n    inlinerContext.warnings.push('Ignoring local @import of \"' + uri + '\" as resource is not allowed and after other content.');\n  } else if (inlinerContext.afterContent) {\n    inlinerContext.warnings.push('Ignoring local @import of \"' + uri + '\" as after other content.');\n  } else if (!isAllowed) {\n    inlinerContext.warnings.push('Skipping local @import of \"' + uri + '\" as resource is not allowed.');\n    inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));\n  } else {\n    importedStyles = isLoaded ?\n      inlinerContext.externalContext.sourcesContent[normalizedPath] :\n      fs.readFileSync(absoluteUri, 'utf-8');\n\n    inlinerContext.inlinedStylesheets.push(absoluteUri);\n    inlinerContext.inline = inlinerContext.externalContext.options.inline;\n\n    inlinerContext.externalContext.source = normalizedPath;\n    inlinerContext.externalContext.sourcesContent[normalizedPath] = importedStyles;\n    inlinerContext.externalContext.stats.originalSize += importedStyles.length;\n\n    return fromStyles(importedStyles, inlinerContext.externalContext, inlinerContext, function (importedTokens) {\n      importedTokens = wrapInMedia(importedTokens, mediaQuery, metadata);\n\n      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(importedTokens);\n      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n\n      return doInlineImports(inlinerContext);\n    });\n  }\n\n  inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n\n  return doInlineImports(inlinerContext);\n}\n\nfunction wrapInMedia(tokens, mediaQuery, metadata) {\n  if (mediaQuery) {\n    return [[Token.NESTED_BLOCK, [[Token.NESTED_BLOCK_SCOPE, '@media ' + mediaQuery, metadata]], tokens]];\n  } else {\n    return tokens;\n  }\n}\n\nmodule.exports = readSources;\n",
    "326": "var fs = require('fs');\nvar path = require('path');\n\nvar isAllowedResource = require('./is-allowed-resource');\nvar matchDataUri = require('./match-data-uri');\nvar rebaseLocalMap = require('./rebase-local-map');\nvar rebaseRemoteMap = require('./rebase-remote-map');\n\nvar Token = require('../tokenizer/token');\nvar hasProtocol = require('../utils/has-protocol');\nvar isDataUriResource = require('../utils/is-data-uri-resource');\nvar isRemoteResource = require('../utils/is-remote-resource');\n\nvar MAP_MARKER_PATTERN = /^\\/\\*# sourceMappingURL=(\\S+) \\*\\/$/;\n\nfunction applySourceMaps(tokens, context, callback) {\n  var applyContext = {\n    callback: callback,\n    fetch: context.options.fetch,\n    index: 0,\n    inline: context.options.inline,\n    inlineRequest: context.options.inlineRequest,\n    inlineTimeout: context.options.inlineTimeout,\n    inputSourceMapTracker: context.inputSourceMapTracker,\n    localOnly: context.localOnly,\n    processedTokens: [],\n    rebaseTo: context.options.rebaseTo,\n    sourceTokens: tokens,\n    warnings: context.warnings\n  };\n\n  return context.options.sourceMap && tokens.length > 0 ?\n    doApplySourceMaps(applyContext) :\n    callback(tokens);\n}\n\nfunction doApplySourceMaps(applyContext) {\n  var singleSourceTokens = [];\n  var lastSource = findTokenSource(applyContext.sourceTokens[0]);\n  var source;\n  var token;\n  var l;\n\n  for (l = applyContext.sourceTokens.length; applyContext.index < l; applyContext.index++) {\n    token = applyContext.sourceTokens[applyContext.index];\n    source = findTokenSource(token);\n\n    if (source != lastSource) {\n      singleSourceTokens = [];\n      lastSource = source;\n    }\n\n    singleSourceTokens.push(token);\n    applyContext.processedTokens.push(token);\n\n    if (token[0] == Token.COMMENT && MAP_MARKER_PATTERN.test(token[1])) {\n      return fetchAndApplySourceMap(token[1], source, singleSourceTokens, applyContext);\n    }\n  }\n\n  return applyContext.callback(applyContext.processedTokens);\n}\n\nfunction findTokenSource(token) {\n  var scope;\n  var metadata;\n\n  if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT) {\n    metadata = token[2][0];\n  } else {\n    scope = token[1][0];\n    metadata = scope[2][0];\n  }\n\n  return metadata[2];\n}\n\nfunction fetchAndApplySourceMap(sourceMapComment, source, singleSourceTokens, applyContext) {\n  return extractInputSourceMapFrom(sourceMapComment, applyContext, function (inputSourceMap) {\n    if (inputSourceMap) {\n      applyContext.inputSourceMapTracker.track(source, inputSourceMap);\n      applySourceMapRecursively(singleSourceTokens, applyContext.inputSourceMapTracker);\n    }\n\n    applyContext.index++;\n    return doApplySourceMaps(applyContext);\n  });\n}\n\nfunction extractInputSourceMapFrom(sourceMapComment, applyContext, whenSourceMapReady) {\n  var uri = MAP_MARKER_PATTERN.exec(sourceMapComment)[1];\n  var absoluteUri;\n  var sourceMap;\n  var rebasedMap;\n\n  if (isDataUriResource(uri)) {\n    sourceMap = extractInputSourceMapFromDataUri(uri);\n    return whenSourceMapReady(sourceMap);\n  } else if (isRemoteResource(uri)) {\n    return loadInputSourceMapFromRemoteUri(uri, applyContext, function (sourceMap) {\n      var parsedMap;\n\n      if (sourceMap) {\n        parsedMap = JSON.parse(sourceMap);\n        rebasedMap = rebaseRemoteMap(parsedMap, uri);\n        whenSourceMapReady(rebasedMap);\n      } else {\n        whenSourceMapReady(null);\n      }\n    });\n  } else {\n    // at this point `uri` is already rebased, see lib/reader/rebase.js#rebaseSourceMapComment\n    // it is rebased to be consistent with rebasing other URIs\n    // however here we need to resolve it back to read it from disk\n    absoluteUri = path.resolve(applyContext.rebaseTo, uri);\n    sourceMap = loadInputSourceMapFromLocalUri(absoluteUri, applyContext);\n\n    if (sourceMap) {\n      rebasedMap = rebaseLocalMap(sourceMap, absoluteUri, applyContext.rebaseTo);\n      return whenSourceMapReady(rebasedMap);\n    } else {\n      return whenSourceMapReady(null);\n    }\n  }\n}\n\nfunction extractInputSourceMapFromDataUri(uri) {\n  var dataUriMatch = matchDataUri(uri);\n  var charset = dataUriMatch[2] ? dataUriMatch[2].split(/[=;]/)[2] : 'us-ascii';\n  var encoding = dataUriMatch[3] ? dataUriMatch[3].split(';')[1] : 'utf8';\n  var data = encoding == 'utf8' ? global.unescape(dataUriMatch[4]) : dataUriMatch[4];\n\n  var buffer = new Buffer(data, encoding);\n  buffer.charset = charset;\n\n  return JSON.parse(buffer.toString());\n}\n\nfunction loadInputSourceMapFromRemoteUri(uri, applyContext, whenLoaded) {\n  var isAllowed = isAllowedResource(uri, true, applyContext.inline);\n  var isRuntimeResource = !hasProtocol(uri);\n\n  if (applyContext.localOnly) {\n    applyContext.warnings.push('Cannot fetch remote resource from \"' + uri + '\" as no callback given.');\n    return whenLoaded(null);\n  } else if (isRuntimeResource) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as no protocol given.');\n    return whenLoaded(null);\n  } else if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return whenLoaded(null);\n  }\n\n  applyContext.fetch(uri, applyContext.inlineRequest, applyContext.inlineTimeout, function (error, body) {\n    if (error) {\n      applyContext.warnings.push('Missing source map at \"' + uri + '\" - ' + error);\n      return whenLoaded(null);\n    }\n\n    whenLoaded(body);\n  });\n}\n\nfunction loadInputSourceMapFromLocalUri(uri, applyContext) {\n  var isAllowed = isAllowedResource(uri, false, applyContext.inline);\n  var sourceMap;\n\n  if (!fs.existsSync(uri) || !fs.statSync(uri).isFile()) {\n    applyContext.warnings.push('Ignoring local source map at \"' + uri + '\" as resource is missing.');\n    return null;\n  } else if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return null;\n  }\n\n  sourceMap = fs.readFileSync(uri, 'utf-8');\n  return JSON.parse(sourceMap);\n}\n\nfunction applySourceMapRecursively(tokens, inputSourceMapTracker) {\n  var token;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n\n    switch (token[0]) {\n      case Token.AT_RULE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.AT_RULE_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.AT_RULE_BLOCK_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.NESTED_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.NESTED_BLOCK_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.COMMENT:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY:\n        applySourceMapRecursively(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_NAME:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_VALUE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.RULE:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.RULE_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n    }\n  }\n\n  return tokens;\n}\n\nfunction applySourceMapTo(token, inputSourceMapTracker) {\n  var value = token[1];\n  var metadata = token[2];\n  var newMetadata = [];\n  var i, l;\n\n  for (i = 0, l = metadata.length; i < l; i++) {\n    newMetadata.push(inputSourceMapTracker.originalPositionFor(metadata[i], value.length));\n  }\n\n  token[2] = newMetadata;\n}\n\nmodule.exports = applySourceMaps;\n",
    "335": "var fs = require('fs');\nvar path = require('path');\n\nvar isAllowedResource = require('./is-allowed-resource');\n\nvar hasProtocol = require('../utils/has-protocol');\nvar isRemoteResource = require('../utils/is-remote-resource');\n\nfunction loadOriginalSources(context, callback) {\n  var loadContext = {\n    callback: callback,\n    fetch: context.options.fetch,\n    index: 0,\n    inline: context.options.inline,\n    inlineRequest: context.options.inlineRequest,\n    inlineTimeout: context.options.inlineTimeout,\n    localOnly: context.localOnly,\n    rebaseTo: context.options.rebaseTo,\n    sourcesContent: context.sourcesContent,\n    uriToSource: uriToSourceMapping(context.inputSourceMapTracker.all()),\n    warnings: context.warnings\n  };\n\n  return context.options.sourceMap && context.options.sourceMapInlineSources ?\n    doLoadOriginalSources(loadContext) :\n    callback();\n}\n\nfunction uriToSourceMapping(allSourceMapConsumers) {\n  var mapping = {};\n  var consumer;\n  var uri;\n  var source;\n  var i, l;\n\n  for (source in allSourceMapConsumers) {\n    consumer = allSourceMapConsumers[source];\n\n    for (i = 0, l = consumer.sources.length; i < l; i++) {\n      uri = consumer.sources[i];\n      source = consumer.sourceContentFor(uri, true);\n\n      mapping[uri] = source;\n    }\n  }\n\n  return mapping;\n}\n\nfunction doLoadOriginalSources(loadContext) {\n  var uris = Object.keys(loadContext.uriToSource);\n  var uri;\n  var source;\n  var total;\n\n  for (total = uris.length; loadContext.index < total; loadContext.index++) {\n    uri = uris[loadContext.index];\n    source = loadContext.uriToSource[uri];\n\n    if (source) {\n      loadContext.sourcesContent[uri] = source;\n    } else {\n      return loadOriginalSource(uri, loadContext);\n    }\n  }\n\n  return loadContext.callback();\n}\n\nfunction loadOriginalSource(uri, loadContext) {\n  var content;\n\n  if (isRemoteResource(uri)) {\n    return loadOriginalSourceFromRemoteUri(uri, loadContext, function (content) {\n      loadContext.index++;\n      loadContext.sourcesContent[uri] = content;\n      return doLoadOriginalSources(loadContext);\n    });\n  } else {\n    content = loadOriginalSourceFromLocalUri(uri, loadContext);\n    loadContext.index++;\n    loadContext.sourcesContent[uri] = content;\n    return doLoadOriginalSources(loadContext);\n  }\n}\n\nfunction loadOriginalSourceFromRemoteUri(uri, loadContext, whenLoaded) {\n  var isAllowed = isAllowedResource(uri, true, loadContext.inline);\n  var isRuntimeResource = !hasProtocol(uri);\n\n  if (loadContext.localOnly) {\n    loadContext.warnings.push('Cannot fetch remote resource from \"' + uri + '\" as no callback given.');\n    return whenLoaded(null);\n  } else if (isRuntimeResource) {\n    loadContext.warnings.push('Cannot fetch \"' + uri + '\" as no protocol given.');\n    return whenLoaded(null);\n  } else if (!isAllowed) {\n    loadContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return whenLoaded(null);\n  }\n\n  loadContext.fetch(uri, loadContext.inlineRequest, loadContext.inlineTimeout, function (error, content) {\n    if (error) {\n      loadContext.warnings.push('Missing original source at \"' + uri + '\" - ' + error);\n    }\n\n    whenLoaded(content);\n  });\n}\n\nfunction loadOriginalSourceFromLocalUri(relativeUri, loadContext) {\n  var isAllowed = isAllowedResource(relativeUri, false, loadContext.inline);\n  var absoluteUri = path.resolve(loadContext.rebaseTo, relativeUri);\n\n  if (!fs.existsSync(absoluteUri) || !fs.statSync(absoluteUri).isFile()) {\n    loadContext.warnings.push('Ignoring local source map at \"' + absoluteUri + '\" as resource is missing.');\n    return null;\n  } else if (!isAllowed) {\n    loadContext.warnings.push('Cannot fetch \"' + absoluteUri + '\" as resource is not allowed.');\n    return null;\n  }\n\n  return fs.readFileSync(absoluteUri, 'utf8');\n}\n\nmodule.exports = loadOriginalSources;\n",
    "337": "var extractImportUrlAndMedia = require('./extract-import-url-and-media');\nvar restoreImport = require('./restore-import');\nvar rewriteUrl = require('./rewrite-url');\n\nvar Token = require('../tokenizer/token');\nvar isImport = require('../utils/is-import');\n\nvar SOURCE_MAP_COMMENT_PATTERN = /^\\/\\*# sourceMappingURL=(\\S+) \\*\\/$/;\n\nfunction rebase(tokens, rebaseAll, validator, rebaseConfig) {\n  return rebaseAll ?\n    rebaseEverything(tokens, validator, rebaseConfig) :\n    rebaseAtRules(tokens, validator, rebaseConfig);\n}\n\nfunction rebaseEverything(tokens, validator, rebaseConfig) {\n  var token;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n\n    switch (token[0]) {\n      case Token.AT_RULE:\n        rebaseAtRule(token, validator, rebaseConfig);\n        break;\n      case Token.AT_RULE_BLOCK:\n        rebaseProperties(token[2], validator, rebaseConfig);\n        break;\n      case Token.COMMENT:\n        rebaseSourceMapComment(token, rebaseConfig);\n        break;\n      case Token.NESTED_BLOCK:\n        rebaseEverything(token[2], validator, rebaseConfig);\n        break;\n      case Token.RULE:\n        rebaseProperties(token[2], validator, rebaseConfig);\n        break;\n    }\n  }\n\n  return tokens;\n}\n\nfunction rebaseAtRules(tokens, validator, rebaseConfig) {\n  var token;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n\n    switch (token[0]) {\n      case Token.AT_RULE:\n        rebaseAtRule(token, validator, rebaseConfig);\n        break;\n    }\n  }\n\n  return tokens;\n}\n\nfunction rebaseAtRule(token, validator, rebaseConfig) {\n  if (!isImport(token[1])) {\n    return;\n  }\n\n  var uriAndMediaQuery = extractImportUrlAndMedia(token[1]);\n  var newUrl = rewriteUrl(uriAndMediaQuery[0], rebaseConfig);\n  var mediaQuery = uriAndMediaQuery[1];\n\n  token[1] = restoreImport(newUrl, mediaQuery);\n}\n\nfunction rebaseSourceMapComment(token, rebaseConfig) {\n  var matches = SOURCE_MAP_COMMENT_PATTERN.exec(token[1]);\n\n  if (matches && matches[1].indexOf('data:') === -1) {\n    token[1] = token[1].replace(matches[1], rewriteUrl(matches[1], rebaseConfig, true));\n  }\n}\n\nfunction rebaseProperties(properties, validator, rebaseConfig) {\n  var property;\n  var value;\n  var i, l;\n  var j, m;\n\n  for (i = 0, l = properties.length; i < l; i++) {\n    property = properties[i];\n\n    for (j = 2 /* 0 is Token.PROPERTY, 1 is name */, m = property.length; j < m; j++) {\n      value = property[j][1];\n\n      if (validator.isUrl(value)) {\n        property[j][1] = rewriteUrl(value, rebaseConfig);\n      }\n    }\n  }\n}\n\nmodule.exports = rebase;\n",
    "341": "var Marker = require('./marker');\nvar Token = require('./token');\n\nvar formatPosition = require('../utils/format-position');\n\nvar Level = {\n  BLOCK: 'block',\n  COMMENT: 'comment',\n  DOUBLE_QUOTE: 'double-quote',\n  RULE: 'rule',\n  SINGLE_QUOTE: 'single-quote'\n};\n\nvar AT_RULES = [\n  '@charset',\n  '@import'\n];\n\nvar BLOCK_RULES = [\n  '@-moz-document',\n  '@document',\n  '@-moz-keyframes',\n  '@-ms-keyframes',\n  '@-o-keyframes',\n  '@-webkit-keyframes',\n  '@keyframes',\n  '@media',\n  '@supports'\n];\n\nvar IGNORE_END_COMMENT_PATTERN = /\\/\\* clean\\-css ignore:end \\*\\/$/;\nvar IGNORE_START_COMMENT_PATTERN = /^\\/\\* clean\\-css ignore:start \\*\\//;\n\nvar PAGE_MARGIN_BOXES = [\n  '@bottom-center',\n  '@bottom-left',\n  '@bottom-left-corner',\n  '@bottom-right',\n  '@bottom-right-corner',\n  '@left-bottom',\n  '@left-middle',\n  '@left-top',\n  '@right-bottom',\n  '@right-middle',\n  '@right-top',\n  '@top-center',\n  '@top-left',\n  '@top-left-corner',\n  '@top-right',\n  '@top-right-corner'\n];\n\nvar EXTRA_PAGE_BOXES = [\n  '@footnote',\n  '@footnotes',\n  '@left',\n  '@page-float-bottom',\n  '@page-float-top',\n  '@right'\n];\n\nvar REPEAT_PATTERN = /^\\[\\s{0,31}\\d+\\s{0,31}\\]$/;\nvar RULE_WORD_SEPARATOR_PATTERN = /[\\s\\(]/;\nvar TAIL_BROKEN_VALUE_PATTERN = /[\\s|\\}]*$/;\n\nfunction tokenize(source, externalContext) {\n  var internalContext = {\n    level: Level.BLOCK,\n    position: {\n      source: externalContext.source || undefined,\n      line: 1,\n      column: 0,\n      index: 0\n    }\n  };\n\n  return intoTokens(source, externalContext, internalContext, false);\n}\n\nfunction intoTokens(source, externalContext, internalContext, isNested) {\n  var allTokens = [];\n  var newTokens = allTokens;\n  var lastToken;\n  var ruleToken;\n  var ruleTokens = [];\n  var propertyToken;\n  var metadata;\n  var metadatas = [];\n  var level = internalContext.level;\n  var levels = [];\n  var buffer = [];\n  var buffers = [];\n  var serializedBuffer;\n  var serializedBufferPart;\n  var roundBracketLevel = 0;\n  var isQuoted;\n  var isSpace;\n  var isNewLineNix;\n  var isNewLineWin;\n  var isCarriageReturn;\n  var isCommentStart;\n  var wasCommentStart = false;\n  var isCommentEnd;\n  var wasCommentEnd = false;\n  var isCommentEndMarker;\n  var isEscaped;\n  var wasEscaped = false;\n  var isRaw = false;\n  var seekingValue = false;\n  var seekingPropertyBlockClosing = false;\n  var position = internalContext.position;\n  var lastCommentStartAt;\n\n  for (; position.index < source.length; position.index++) {\n    var character = source[position.index];\n\n    isQuoted = level == Level.SINGLE_QUOTE || level == Level.DOUBLE_QUOTE;\n    isSpace = character == Marker.SPACE || character == Marker.TAB;\n    isNewLineNix = character == Marker.NEW_LINE_NIX;\n    isNewLineWin = character == Marker.NEW_LINE_NIX && source[position.index - 1] == Marker.CARRIAGE_RETURN;\n    isCarriageReturn = character == Marker.CARRIAGE_RETURN && source[position.index + 1] && source[position.index + 1] != Marker.NEW_LINE_NIX;\n    isCommentStart = !wasCommentEnd && level != Level.COMMENT && !isQuoted && character == Marker.ASTERISK && source[position.index - 1] == Marker.FORWARD_SLASH;\n    isCommentEndMarker = !wasCommentStart && !isQuoted && character == Marker.FORWARD_SLASH && source[position.index - 1] == Marker.ASTERISK;\n    isCommentEnd = level == Level.COMMENT && isCommentEndMarker;\n    roundBracketLevel = Math.max(roundBracketLevel, 0);\n\n    metadata = buffer.length === 0 ?\n      [position.line, position.column, position.source] :\n      metadata;\n\n    if (isEscaped) {\n      // previous character was a backslash\n      buffer.push(character);\n    } else if (!isCommentEnd && level == Level.COMMENT) {\n      buffer.push(character);\n    } else if (!isCommentStart && !isCommentEnd && isRaw) {\n      buffer.push(character);\n    } else if (isCommentStart && (level == Level.BLOCK || level == Level.RULE) && buffer.length > 1) {\n      // comment start within block preceded by some content, e.g. div/*<--\n      metadatas.push(metadata);\n      buffer.push(character);\n      buffers.push(buffer.slice(0, buffer.length - 2));\n\n      buffer = buffer.slice(buffer.length - 2);\n      metadata = [position.line, position.column - 1, position.source];\n\n      levels.push(level);\n      level = Level.COMMENT;\n    } else if (isCommentStart) {\n      // comment start, e.g. /*<--\n      levels.push(level);\n      level = Level.COMMENT;\n      buffer.push(character);\n    } else if (isCommentEnd && isIgnoreStartComment(buffer)) {\n      // ignore:start comment end, e.g. /* clean-css ignore:start */<--\n      serializedBuffer = buffer.join('').trim() + character;\n      lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];\n      newTokens.push(lastToken);\n\n      isRaw = true;\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n    } else if (isCommentEnd && isIgnoreEndComment(buffer)) {\n      // ignore:start comment end, e.g. /* clean-css ignore:end */<--\n      serializedBuffer = buffer.join('') + character;\n      lastCommentStartAt = serializedBuffer.lastIndexOf(Marker.FORWARD_SLASH + Marker.ASTERISK);\n\n      serializedBufferPart = serializedBuffer.substring(0, lastCommentStartAt);\n      lastToken = [Token.RAW, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];\n      newTokens.push(lastToken);\n\n      serializedBufferPart = serializedBuffer.substring(lastCommentStartAt);\n      metadata = [position.line, position.column - serializedBufferPart.length + 1, position.source];\n      lastToken = [Token.COMMENT, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];\n      newTokens.push(lastToken);\n\n      isRaw = false;\n      level = levels.pop();\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n    } else if (isCommentEnd) {\n      // comment end, e.g. /* comment */<--\n      serializedBuffer = buffer.join('').trim() + character;\n      lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];\n      newTokens.push(lastToken);\n\n      level = levels.pop();\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n    } else if (isCommentEndMarker && source[position.index + 1] != Marker.ASTERISK) {\n      externalContext.warnings.push('Unexpected \\'*/\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n      buffer = [];\n    } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {\n      // single quotation start, e.g. a[href^='https<--\n      levels.push(level);\n      level = Level.SINGLE_QUOTE;\n      buffer.push(character);\n    } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {\n      // single quotation end, e.g. a[href^='https'<--\n      level = levels.pop();\n      buffer.push(character);\n    } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {\n      // double quotation start, e.g. a[href^=\"<--\n      levels.push(level);\n      level = Level.DOUBLE_QUOTE;\n      buffer.push(character);\n    } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {\n      // double quotation end, e.g. a[href^=\"https\"<--\n      level = levels.pop();\n      buffer.push(character);\n    } else if (!isCommentStart && !isCommentEnd && character != Marker.CLOSE_ROUND_BRACKET && character != Marker.OPEN_ROUND_BRACKET && level != Level.COMMENT && !isQuoted && roundBracketLevel > 0) {\n      // character inside any function, e.g. hsla(.<--\n      buffer.push(character);\n    } else if (character == Marker.OPEN_ROUND_BRACKET && !isQuoted && level != Level.COMMENT && !seekingValue) {\n      // round open bracket, e.g. @import url(<--\n      buffer.push(character);\n\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && !isQuoted && level != Level.COMMENT && !seekingValue) {\n      // round open bracket, e.g. @import url(test.css)<--\n      buffer.push(character);\n\n      roundBracketLevel--;\n    } else if (character == Marker.SEMICOLON && level == Level.BLOCK && buffer[0] == Marker.AT) {\n      // semicolon ending rule at block level, e.g. @import '...';<--\n      serializedBuffer = buffer.join('').trim();\n      allTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n\n      buffer = [];\n    } else if (character == Marker.COMMA && level == Level.BLOCK && ruleToken) {\n      // comma separator at block level, e.g. a,div,<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);\n\n      buffer = [];\n    } else if (character == Marker.COMMA && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.AT_RULE) {\n      // comma separator at block level, e.g. @import url(...) screen,<--\n      // keep iterating as end semicolon will create the token\n      buffer.push(character);\n    } else if (character == Marker.COMMA && level == Level.BLOCK) {\n      // comma separator at block level, e.g. a,<--\n      ruleToken = [tokenTypeFrom(buffer), [], []];\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, 0)]]);\n\n      buffer = [];\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK && ruleToken && ruleToken[0] == Token.NESTED_BLOCK) {\n      // open brace opening at-rule at block level, e.g. @media{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      allTokens.push(ruleToken);\n\n      levels.push(level);\n      position.column++;\n      position.index++;\n      buffer = [];\n\n      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);\n      ruleToken = null;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.NESTED_BLOCK) {\n      // open brace opening at-rule at block level, e.g. @media{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken = ruleToken || [Token.NESTED_BLOCK, [], []];\n      ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      allTokens.push(ruleToken);\n\n      levels.push(level);\n      position.column++;\n      position.index++;\n      buffer = [];\n\n      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);\n      ruleToken = null;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK) {\n      // open brace opening rule at block level, e.g. div{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken = ruleToken || [tokenTypeFrom(buffer), [], []];\n      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);\n      newTokens = ruleToken[2];\n      allTokens.push(ruleToken);\n\n      levels.push(level);\n      level = Level.RULE;\n      buffer = [];\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && seekingValue) {\n      // open brace opening rule at rule level, e.g. div{--variable:{<--\n      ruleTokens.push(ruleToken);\n      ruleToken = [Token.PROPERTY_BLOCK, []];\n      propertyToken.push(ruleToken);\n      newTokens = ruleToken[1];\n\n      levels.push(level);\n      level = Level.RULE;\n      seekingValue = false;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && isPageMarginBox(buffer)) {\n      // open brace opening page-margin box at rule level, e.g. @page{@top-center{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleTokens.push(ruleToken);\n      ruleToken = [Token.AT_RULE_BLOCK, [], []];\n      ruleToken[1].push([Token.AT_RULE_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      newTokens.push(ruleToken);\n      newTokens = ruleToken[2];\n\n      levels.push(level);\n      level = Level.RULE;\n      buffer = [];\n    } else if (character == Marker.COLON && level == Level.RULE && !seekingValue) {\n      // colon at rule level, e.g. a{color:<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken = [Token.PROPERTY, [Token.PROPERTY_NAME, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]];\n      newTokens.push(propertyToken);\n\n      seekingValue = true;\n      buffer = [];\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && ruleTokens.length > 0 && buffer.length > 0 && buffer[0] == Marker.AT) {\n      // semicolon at rule level for at-rule, e.g. a{--color:{@apply(--other-color);<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n\n      buffer = [];\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && buffer.length > 0) {\n      // semicolon at rule level, e.g. a{color:red;<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n\n      propertyToken = null;\n      seekingValue = false;\n      buffer = [];\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && buffer.length === 0) {\n      // semicolon after bracketed value at rule level, e.g. a{color:rgb(...);<--\n      propertyToken = null;\n      seekingValue = false;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && buffer.length > 0 && buffer[0] == Marker.AT) {\n      // semicolon for at-rule at rule level, e.g. a{@apply(--variable);<--\n      serializedBuffer = buffer.join('');\n      newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n\n      seekingValue = false;\n      buffer = [];\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && seekingPropertyBlockClosing) {\n      // close brace after a property block at rule level, e.g. a{--custom:{color:red;};<--\n      seekingPropertyBlockClosing = false;\n      buffer = [];\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && buffer.length === 0) {\n      // stray semicolon at rule level, e.g. a{;<--\n      // noop\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && seekingValue && buffer.length > 0 && ruleTokens.length > 0) {\n      // close brace at rule level, e.g. a{--color:{color:red}<--\n      serializedBuffer = buffer.join('');\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && buffer.length > 0 && buffer[0] == Marker.AT && ruleTokens.length > 0) {\n      // close brace at rule level for at-rule, e.g. a{--color:{@apply(--other-color)}<--\n      serializedBuffer = buffer.join('');\n      ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && ruleTokens.length > 0) {\n      // close brace at rule level after space, e.g. a{--color:{color:red }<--\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n\n      level = levels.pop();\n      seekingValue = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && buffer.length > 0) {\n      // close brace at rule level, e.g. a{color:red}<--\n      serializedBuffer = buffer.join('');\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = allTokens;\n\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && buffer.length > 0 && buffer[0] == Marker.AT) {\n      // close brace after at-rule at rule level, e.g. a{@apply(--variable)}<--\n      propertyToken = null;\n      ruleToken = null;\n      serializedBuffer = buffer.join('').trim();\n      newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      newTokens = allTokens;\n\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && levels[levels.length - 1] == Level.RULE) {\n      // close brace after a property block at rule level, e.g. a{--custom:{color:red;}<--\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n\n      level = levels.pop();\n      seekingValue = false;\n      seekingPropertyBlockClosing = true;\n      buffer = [];\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE) {\n      // close brace after a rule, e.g. a{color:red;}<--\n      propertyToken = null;\n      ruleToken = null;\n      newTokens = allTokens;\n\n      level = levels.pop();\n      seekingValue = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK && !isNested && position.index <= source.length - 1) {\n      // stray close brace at block level, e.g. a{color:red}color:blue}<--\n      externalContext.warnings.push('Unexpected \\'}\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n      buffer.push(character);\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK) {\n      // close brace at block level, e.g. @media screen {...}<--\n      break;\n    } else if (character == Marker.OPEN_ROUND_BRACKET && level == Level.RULE && seekingValue) {\n      // round open bracket, e.g. a{color:hsla(<--\n      buffer.push(character);\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue && roundBracketLevel == 1) {\n      // round close bracket, e.g. a{color:hsla(0,0%,0%)<--\n      buffer.push(character);\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n\n      roundBracketLevel--;\n      buffer = [];\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue) {\n      // round close bracket within other brackets, e.g. a{width:calc((10rem / 2)<--\n      buffer.push(character);\n      roundBracketLevel--;\n    } else if (character == Marker.FORWARD_SLASH && source[position.index + 1] != Marker.ASTERISK && level == Level.RULE && seekingValue && buffer.length > 0) {\n      // forward slash within a property, e.g. a{background:url(image.png) 0 0/<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);\n\n      buffer = [];\n    } else if (character == Marker.FORWARD_SLASH && source[position.index + 1] != Marker.ASTERISK && level == Level.RULE && seekingValue) {\n      // forward slash within a property after space, e.g. a{background:url(image.png) 0 0 /<--\n      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);\n\n      buffer = [];\n    } else if (character == Marker.COMMA && level == Level.RULE && seekingValue && buffer.length > 0) {\n      // comma within a property, e.g. a{background:url(image.png),<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);\n\n      buffer = [];\n    } else if (character == Marker.COMMA && level == Level.RULE && seekingValue) {\n      // comma within a property after space, e.g. a{background:url(image.png) ,<--\n      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);\n\n      buffer = [];\n    } else if (character == Marker.CLOSE_SQUARE_BRACKET && propertyToken && propertyToken.length > 1 && buffer.length > 0 && isRepeatToken(buffer)) {\n      buffer.push(character);\n      serializedBuffer = buffer.join('').trim();\n      propertyToken[propertyToken.length - 1][1] += serializedBuffer;\n\n      buffer = [];\n    } else if ((isSpace || (isNewLineNix && !isNewLineWin)) && level == Level.RULE && seekingValue && propertyToken && buffer.length > 0) {\n      // space or *nix newline within property, e.g. a{margin:0 <--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n\n      buffer = [];\n    } else if (isNewLineWin && level == Level.RULE && seekingValue && propertyToken && buffer.length > 1) {\n      // win newline within property, e.g. a{margin:0\\r\\n<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n\n      buffer = [];\n    } else if (isNewLineWin && level == Level.RULE && seekingValue) {\n      // win newline\n      buffer = [];\n    } else if (buffer.length == 1 && isNewLineWin) {\n      // ignore windows newline which is composed of two characters\n      buffer.pop();\n    } else if (buffer.length > 0 || !isSpace && !isNewLineNix && !isNewLineWin && !isCarriageReturn) {\n      // any character\n      buffer.push(character);\n    }\n\n    wasEscaped = isEscaped;\n    isEscaped = !wasEscaped && character == Marker.BACK_SLASH;\n    wasCommentStart = isCommentStart;\n    wasCommentEnd = isCommentEnd;\n\n    position.line = (isNewLineWin || isNewLineNix || isCarriageReturn) ? position.line + 1 : position.line;\n    position.column = (isNewLineWin || isNewLineNix || isCarriageReturn) ? 0 : position.column + 1;\n  }\n\n  if (seekingValue) {\n    externalContext.warnings.push('Missing \\'}\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n  }\n\n  if (seekingValue && buffer.length > 0) {\n    serializedBuffer = buffer.join('').replace(TAIL_BROKEN_VALUE_PATTERN, '');\n    propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n\n    buffer = [];\n  }\n\n  if (buffer.length > 0) {\n    externalContext.warnings.push('Invalid character(s) \\'' + buffer.join('') + '\\' at ' + formatPosition(metadata) + '. Ignoring.');\n  }\n\n  return allTokens;\n}\n\nfunction isIgnoreStartComment(buffer) {\n  return IGNORE_START_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);\n}\n\nfunction isIgnoreEndComment(buffer) {\n  return IGNORE_END_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);\n}\n\nfunction originalMetadata(metadata, value, externalContext, selectorFallbacks) {\n  var source = metadata[2];\n\n  return externalContext.inputSourceMapTracker.isTracking(source) ?\n    externalContext.inputSourceMapTracker.originalPositionFor(metadata, value.length, selectorFallbacks) :\n    metadata;\n}\n\nfunction tokenTypeFrom(buffer) {\n  var isAtRule = buffer[0] == Marker.AT || buffer[0] == Marker.UNDERSCORE;\n  var ruleWord = buffer.join('').split(RULE_WORD_SEPARATOR_PATTERN)[0];\n\n  if (isAtRule && BLOCK_RULES.indexOf(ruleWord) > -1) {\n    return Token.NESTED_BLOCK;\n  } else if (isAtRule && AT_RULES.indexOf(ruleWord) > -1) {\n    return Token.AT_RULE;\n  } else if (isAtRule) {\n    return Token.AT_RULE_BLOCK;\n  } else {\n    return Token.RULE;\n  }\n}\n\nfunction tokenScopeFrom(tokenType) {\n  if (tokenType == Token.RULE) {\n    return Token.RULE_SCOPE;\n  } else if (tokenType == Token.NESTED_BLOCK) {\n    return Token.NESTED_BLOCK_SCOPE;\n  } else if (tokenType == Token.AT_RULE_BLOCK) {\n    return Token.AT_RULE_BLOCK_SCOPE;\n  }\n}\n\nfunction isPageMarginBox(buffer) {\n  var serializedBuffer = buffer.join('').trim();\n\n  return PAGE_MARGIN_BOXES.indexOf(serializedBuffer) > -1 || EXTRA_PAGE_BOXES.indexOf(serializedBuffer) > -1;\n}\n\nfunction isRepeatToken(buffer) {\n  return REPEAT_PATTERN.test(buffer.join('') + Marker.CLOSE_SQUARE_BRACKET);\n}\n\nmodule.exports = tokenize;\n",
    "342": "var all = require('./helpers').all;\n\nfunction store(serializeContext, token) {\n  var value = typeof token == 'string' ?\n    token :\n    token[1];\n  var wrap = serializeContext.wrap;\n\n  wrap(serializeContext, value);\n  track(serializeContext, value);\n  serializeContext.output.push(value);\n}\n\nfunction wrap(serializeContext, value) {\n  if (serializeContext.column + value.length > serializeContext.format.wrapAt) {\n    track(serializeContext, serializeContext.format.breakWith);\n    serializeContext.output.push(serializeContext.format.breakWith);\n  }\n}\n\nfunction track(serializeContext, value) {\n  var parts = value.split('\\n');\n\n  serializeContext.line += parts.length - 1;\n  serializeContext.column = parts.length > 1 ? 0 : (serializeContext.column + parts.pop().length);\n}\n\nfunction serializeStyles(tokens, context) {\n  var serializeContext = {\n    column: 0,\n    format: context.options.format,\n    indentBy: 0,\n    indentWith: '',\n    line: 1,\n    output: [],\n    spaceAfterClosingBrace: context.options.compatibility.properties.spaceAfterClosingBrace,\n    store: store,\n    wrap: context.options.format.wrapAt ?\n      wrap :\n      function () { /* noop */  }\n  };\n\n  all(serializeContext, tokens);\n\n  return {\n    styles: serializeContext.output.join('')\n  };\n}\n\nmodule.exports = serializeStyles;\n",
    "345": "/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n/*\n * // Use like so:\n * HTMLParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n * // or to get an XML string:\n * HTMLtoXML(htmlString);\n *\n * // or to get an XML DOM Document\n * HTMLtoDOM(htmlString);\n *\n * // or to inject into an existing document/DOM node\n * HTMLtoDOM(htmlString, document);\n * HTMLtoDOM(htmlString, document.body);\n *\n */\n\n/* global ActiveXObject, DOMDocument */\n\n'use strict';\n\nvar createMapFromString = require('./utils').createMapFromString;\n\nfunction makeMap(values) {\n  return createMapFromString(values, true);\n}\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/,\n    singleAttrAssigns = [/=/],\n    singleAttrValues = [\n      // attr value double quotes\n      /\"([^\"]*)\"+/.source,\n      // attr value, single quotes\n      /'([^']*)'+/.source,\n      // attr value, no quotes\n      /([^ \\t\\n\\f\\r\"'`=<>]+)/.source\n    ],\n    // https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n    qnameCapture = (function() {\n      // based on https://www.npmjs.com/package/ncname\n      var combiningChar = '\\\\u0300-\\\\u0345\\\\u0360\\\\u0361\\\\u0483-\\\\u0486\\\\u0591-\\\\u05A1\\\\u05A3-\\\\u05B9\\\\u05BB-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u064B-\\\\u0652\\\\u0670\\\\u06D6-\\\\u06E4\\\\u06E7\\\\u06E8\\\\u06EA-\\\\u06ED\\\\u0901-\\\\u0903\\\\u093C\\\\u093E-\\\\u094D\\\\u0951-\\\\u0954\\\\u0962\\\\u0963\\\\u0981-\\\\u0983\\\\u09BC\\\\u09BE-\\\\u09C4\\\\u09C7\\\\u09C8\\\\u09CB-\\\\u09CD\\\\u09D7\\\\u09E2\\\\u09E3\\\\u0A02\\\\u0A3C\\\\u0A3E-\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A70\\\\u0A71\\\\u0A81-\\\\u0A83\\\\u0ABC\\\\u0ABE-\\\\u0AC5\\\\u0AC7-\\\\u0AC9\\\\u0ACB-\\\\u0ACD\\\\u0B01-\\\\u0B03\\\\u0B3C\\\\u0B3E-\\\\u0B43\\\\u0B47\\\\u0B48\\\\u0B4B-\\\\u0B4D\\\\u0B56\\\\u0B57\\\\u0B82\\\\u0B83\\\\u0BBE-\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCD\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C3E-\\\\u0C44\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C82\\\\u0C83\\\\u0CBE-\\\\u0CC4\\\\u0CC6-\\\\u0CC8\\\\u0CCA-\\\\u0CCD\\\\u0CD5\\\\u0CD6\\\\u0D02\\\\u0D03\\\\u0D3E-\\\\u0D43\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4D\\\\u0D57\\\\u0E31\\\\u0E34-\\\\u0E3A\\\\u0E47-\\\\u0E4E\\\\u0EB1\\\\u0EB4-\\\\u0EB9\\\\u0EBB\\\\u0EBC\\\\u0EC8-\\\\u0ECD\\\\u0F18\\\\u0F19\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F3E\\\\u0F3F\\\\u0F71-\\\\u0F84\\\\u0F86-\\\\u0F8B\\\\u0F90-\\\\u0F95\\\\u0F97\\\\u0F99-\\\\u0FAD\\\\u0FB1-\\\\u0FB7\\\\u0FB9\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u302A-\\\\u302F\\\\u3099\\\\u309A';\n      var digit = '0-9\\\\u0660-\\\\u0669\\\\u06F0-\\\\u06F9\\\\u0966-\\\\u096F\\\\u09E6-\\\\u09EF\\\\u0A66-\\\\u0A6F\\\\u0AE6-\\\\u0AEF\\\\u0B66-\\\\u0B6F\\\\u0BE7-\\\\u0BEF\\\\u0C66-\\\\u0C6F\\\\u0CE6-\\\\u0CEF\\\\u0D66-\\\\u0D6F\\\\u0E50-\\\\u0E59\\\\u0ED0-\\\\u0ED9\\\\u0F20-\\\\u0F29';\n      var extender = '\\\\xB7\\\\u02D0\\\\u02D1\\\\u0387\\\\u0640\\\\u0E46\\\\u0EC6\\\\u3005\\\\u3031-\\\\u3035\\\\u309D\\\\u309E\\\\u30FC-\\\\u30FE';\n      var letter = 'A-Za-z\\\\xC0-\\\\xD6\\\\xD8-\\\\xF6\\\\xF8-\\\\u0131\\\\u0134-\\\\u013E\\\\u0141-\\\\u0148\\\\u014A-\\\\u017E\\\\u0180-\\\\u01C3\\\\u01CD-\\\\u01F0\\\\u01F4\\\\u01F5\\\\u01FA-\\\\u0217\\\\u0250-\\\\u02A8\\\\u02BB-\\\\u02C1\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03CE\\\\u03D0-\\\\u03D6\\\\u03DA\\\\u03DC\\\\u03DE\\\\u03E0\\\\u03E2-\\\\u03F3\\\\u0401-\\\\u040C\\\\u040E-\\\\u044F\\\\u0451-\\\\u045C\\\\u045E-\\\\u0481\\\\u0490-\\\\u04C4\\\\u04C7\\\\u04C8\\\\u04CB\\\\u04CC\\\\u04D0-\\\\u04EB\\\\u04EE-\\\\u04F5\\\\u04F8\\\\u04F9\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0586\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0621-\\\\u063A\\\\u0641-\\\\u064A\\\\u0671-\\\\u06B7\\\\u06BA-\\\\u06BE\\\\u06C0-\\\\u06CE\\\\u06D0-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u0905-\\\\u0939\\\\u093D\\\\u0958-\\\\u0961\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8B\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AE0\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B36-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB5\\\\u0BB7-\\\\u0BB9\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C33\\\\u0C35-\\\\u0C39\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D28\\\\u0D2A-\\\\u0D39\\\\u0D60\\\\u0D61\\\\u0E01-\\\\u0E2E\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E45\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD\\\\u0EAE\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F69\\\\u10A0-\\\\u10C5\\\\u10D0-\\\\u10F6\\\\u1100\\\\u1102\\\\u1103\\\\u1105-\\\\u1107\\\\u1109\\\\u110B\\\\u110C\\\\u110E-\\\\u1112\\\\u113C\\\\u113E\\\\u1140\\\\u114C\\\\u114E\\\\u1150\\\\u1154\\\\u1155\\\\u1159\\\\u115F-\\\\u1161\\\\u1163\\\\u1165\\\\u1167\\\\u1169\\\\u116D\\\\u116E\\\\u1172\\\\u1173\\\\u1175\\\\u119E\\\\u11A8\\\\u11AB\\\\u11AE\\\\u11AF\\\\u11B7\\\\u11B8\\\\u11BA\\\\u11BC-\\\\u11C2\\\\u11EB\\\\u11F0\\\\u11F9\\\\u1E00-\\\\u1E9B\\\\u1EA0-\\\\u1EF9\\\\u1F00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2126\\\\u212A\\\\u212B\\\\u212E\\\\u2180-\\\\u2182\\\\u3007\\\\u3021-\\\\u3029\\\\u3041-\\\\u3094\\\\u30A1-\\\\u30FA\\\\u3105-\\\\u312C\\\\u4E00-\\\\u9FA5\\\\uAC00-\\\\uD7A3';\n      var ncname = '[' + letter + '_][' + letter + digit + '\\\\.\\\\-_' + combiningChar + extender + ']*';\n      return '((?:' + ncname + '\\\\:)?' + ncname + ')';\n    })(),\n    startTagOpen = new RegExp('^<' + qnameCapture),\n    startTagClose = /^\\s*(\\/?)>/,\n    endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>'),\n    doctype = /^<!DOCTYPE\\s?[^>]+>/i;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function(m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Empty Elements\nvar empty = makeMap('area,base,basefont,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr');\n\n// Inline Elements\nvar inline = makeMap('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,noscript,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,svg,textarea,tt,u,var');\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar closeSelf = makeMap('colgroup,dd,dt,li,option,p,td,tfoot,th,thead,tr,source');\n\n// Attributes that have their values filled in disabled='disabled'\nvar fillAttrs = makeMap('checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected');\n\n// Special Elements (can contain anything)\nvar special = makeMap('script,style');\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar nonPhrasing = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,ol,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track,ul');\n\nvar reCache = {};\n\nfunction attrForHandler(handler) {\n  var pattern = singleAttrIdentifier.source +\n                '(?:\\\\s*(' + joinSingleAttrAssigns(handler) + ')' +\n                '[ \\\\t\\\\n\\\\f\\\\r]*(?:' + singleAttrValues.join('|') + '))?';\n  if (handler.customAttrSurround) {\n    var attrClauses = [];\n    for (var i = handler.customAttrSurround.length - 1; i >= 0; i--) {\n      attrClauses[i] = '(?:' +\n                       '(' + handler.customAttrSurround[i][0].source + ')\\\\s*' +\n                       pattern +\n                       '\\\\s*(' + handler.customAttrSurround[i][1].source + ')' +\n                       ')';\n    }\n    attrClauses.push('(?:' + pattern + ')');\n    pattern = '(?:' + attrClauses.join('|') + ')';\n  }\n  return new RegExp('^\\\\s*' + pattern);\n}\n\nfunction joinSingleAttrAssigns(handler) {\n  return singleAttrAssigns.concat(\n    handler.customAttrAssign || []\n  ).map(function(assign) {\n    return '(?:' + assign.source + ')';\n  }).join('|');\n}\n\nfunction HTMLParser(html, handler) {\n  var stack = [], lastTag;\n  var attribute = attrForHandler(handler);\n  var last, prevTag, nextTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a script or style element\n    if (!lastTag || !special(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (/^<!--/.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (handler.comment) {\n              handler.comment(html.substring(4, commentEnd));\n            }\n            html = html.substring(commentEnd + 3);\n            prevTag = '';\n            continue;\n          }\n        }\n\n        // https://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (/^<!\\[/.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            if (handler.comment) {\n              handler.comment(html.substring(2, conditionalEnd + 1), true /* non-standard */);\n            }\n            html = html.substring(conditionalEnd + 2);\n            prevTag = '';\n            continue;\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          if (handler.doctype) {\n            handler.doctype(doctypeMatch[0]);\n          }\n          html = html.substring(doctypeMatch[0].length);\n          prevTag = '';\n          continue;\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          html = html.substring(endTagMatch[0].length);\n          endTagMatch[0].replace(endTag, parseEndTag);\n          prevTag = '/' + endTagMatch[1].toLowerCase();\n          continue;\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag(html);\n        if (startTagMatch) {\n          html = startTagMatch.rest;\n          handleStartTag(startTagMatch);\n          prevTag = startTagMatch.tagName.toLowerCase();\n          continue;\n        }\n\n        // Treat `<` as text\n        if (handler.continueOnParseError) {\n          textEnd = html.indexOf('<', 1);\n        }\n      }\n\n      var text;\n      if (textEnd >= 0) {\n        text = html.substring(0, textEnd);\n        html = html.substring(textEnd);\n      }\n      else {\n        text = html;\n        html = '';\n      }\n\n      // next tag\n      var nextTagMatch = parseStartTag(html);\n      if (nextTagMatch) {\n        nextTag = nextTagMatch.tagName;\n      }\n      else {\n        nextTagMatch = html.match(endTag);\n        if (nextTagMatch) {\n          nextTag = '/' + nextTagMatch[1];\n        }\n        else {\n          nextTag = '';\n        }\n      }\n\n      if (handler.chars) {\n        handler.chars(text, prevTag, nextTag);\n      }\n      prevTag = '';\n    }\n    else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)</' + stackedTag + '[^>]*>', 'i'));\n\n      html = html.replace(reStackedTag, function(all, text) {\n        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n\n        if (handler.chars) {\n          handler.chars(text);\n        }\n\n        return '';\n      });\n\n      parseEndTag('</' + stackedTag + '>', stackedTag);\n    }\n\n    if (html === last) {\n      throw new Error('Parse Error: ' + html);\n    }\n  }\n\n  if (!handler.partialMarkup) {\n    // Clean up any remaining tags\n    parseEndTag();\n  }\n\n  function parseStartTag(input) {\n    var start = input.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: []\n      };\n      input = input.slice(start[0].length);\n      var end, attr;\n      while (!(end = input.match(startTagClose)) && (attr = input.match(attribute))) {\n        input = input.slice(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        match.rest = input.slice(end[0].length);\n        return match;\n      }\n    }\n  }\n\n  function closeIfFound(tagName) {\n    if (findTag(tagName) >= 0) {\n      parseEndTag('', tagName);\n      return true;\n    }\n  }\n\n  function handleStartTag(match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (handler.html5) {\n      if (lastTag === 'p' && nonPhrasing(tagName)) {\n        parseEndTag('', lastTag);\n      }\n      else if (tagName === 'tbody') {\n        closeIfFound('thead');\n      }\n      else if (tagName === 'tfoot') {\n        if (!closeIfFound('tbody')) {\n          closeIfFound('thead');\n        }\n      }\n      if (tagName === 'col' && findTag('colgroup') < 0) {\n        lastTag = 'colgroup';\n        stack.push({ tag: lastTag, attrs: [] });\n        if (handler.start) {\n          handler.start(lastTag, [], false, '');\n        }\n      }\n    }\n\n    if (!handler.html5 && !inline(tagName)) {\n      while (lastTag && inline(lastTag)) {\n        parseEndTag('', lastTag);\n      }\n    }\n\n    if (closeSelf(tagName) && lastTag === tagName) {\n      parseEndTag('', tagName);\n    }\n\n    var unary = empty(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var attrs = match.attrs.map(function(args) {\n      var name, value, customOpen, customClose, customAssign, quote;\n      var ncp = 7; // number of captured parts, scalar\n\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n\n      function populate(index) {\n        customAssign = args[index];\n        value = args[index + 1];\n        if (typeof value !== 'undefined') {\n          return '\"';\n        }\n        value = args[index + 2];\n        if (typeof value !== 'undefined') {\n          return '\\'';\n        }\n        value = args[index + 3];\n        if (typeof value === 'undefined' && fillAttrs(name)) {\n          value = name;\n        }\n        return '';\n      }\n\n      var j = 1;\n      if (handler.customAttrSurround) {\n        for (var i = 0, l = handler.customAttrSurround.length; i < l; i++, j += ncp) {\n          name = args[j + 1];\n          if (name) {\n            quote = populate(j + 2);\n            customOpen = args[j];\n            customClose = args[j + 6];\n            break;\n          }\n        }\n      }\n\n      if (!name && (name = args[j])) {\n        quote = populate(j + 1);\n      }\n\n      return {\n        name: name,\n        value: value,\n        customAssign: customAssign || '=',\n        customOpen: customOpen || '',\n        customClose: customClose || '',\n        quote: quote || ''\n      };\n    });\n\n    if (!unary) {\n      stack.push({ tag: tagName, attrs: attrs });\n      lastTag = tagName;\n      unarySlash = '';\n    }\n\n    if (handler.start) {\n      handler.start(tagName, attrs, unary, unarySlash);\n    }\n  }\n\n  function findTag(tagName) {\n    var pos;\n    var needle = tagName.toLowerCase();\n    for (pos = stack.length - 1; pos >= 0; pos--) {\n      if (stack[pos].tag.toLowerCase() === needle) {\n        break;\n      }\n    }\n    return pos;\n  }\n\n  function parseEndTag(tag, tagName) {\n    var pos;\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      pos = findTag(tagName);\n    }\n    // If no tag name is provided, clean shop\n    else {\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (handler.end) {\n          handler.end(stack[i].tag, stack[i].attrs, i > pos || !tag);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    }\n    else if (tagName.toLowerCase() === 'br') {\n      if (handler.start) {\n        handler.start(tagName, [], true, '');\n      }\n    }\n    else if (tagName.toLowerCase() === 'p') {\n      if (handler.start) {\n        handler.start(tagName, [], false, '', true);\n      }\n      if (handler.end) {\n        handler.end(tagName, []);\n      }\n    }\n  }\n}\n\nexports.HTMLParser = HTMLParser;\nexports.HTMLtoXML = function(html) {\n  var results = '';\n\n  new HTMLParser(html, {\n    start: function(tag, attrs, unary) {\n      results += '<' + tag;\n\n      for (var i = 0, len = attrs.length; i < len; i++) {\n        results += ' ' + attrs[i].name + '=\"' + (attrs[i].value || '').replace(/\"/g, '&#34;') + '\"';\n      }\n\n      results += (unary ? '/' : '') + '>';\n    },\n    end: function(tag) {\n      results += '</' + tag + '>';\n    },\n    chars: function(text) {\n      results += text;\n    },\n    comment: function(text) {\n      results += '<!--' + text + '-->';\n    },\n    ignore: function(text) {\n      results += text;\n    }\n  });\n\n  return results;\n};\n\nexports.HTMLtoDOM = function(html, doc) {\n  // There can be only one of these elements\n  var one = {\n    html: true,\n    head: true,\n    body: true,\n    title: true\n  };\n\n  // Enforce a structure for the document\n  var structure = {\n    link: 'head',\n    base: 'head'\n  };\n\n  if (doc) {\n    doc = doc.ownerDocument || doc.getOwnerDocument && doc.getOwnerDocument() || doc;\n  }\n  else if (typeof DOMDocument !== 'undefined') {\n    doc = new DOMDocument();\n  }\n  else if (typeof document !== 'undefined' && document.implementation && document.implementation.createDocument) {\n    doc = document.implementation.createDocument('', '', null);\n  }\n  else if (typeof ActiveX !== 'undefined') {\n    doc = new ActiveXObject('Msxml.DOMDocument');\n  }\n\n  var elems = [],\n      documentElement = doc.documentElement ||\n        doc.getDocumentElement && doc.getDocumentElement();\n\n  // If we're dealing with an empty document then we\n  // need to pre-populate it with the HTML document structure\n  if (!documentElement && doc.createElement) {\n    (function() {\n      var html = doc.createElement('html');\n      var head = doc.createElement('head');\n      head.appendChild(doc.createElement('title'));\n      html.appendChild(head);\n      html.appendChild(doc.createElement('body'));\n      doc.appendChild(html);\n    })();\n  }\n\n  // Find all the unique elements\n  if (doc.getElementsByTagName) {\n    for (var i in one) {\n      one[i] = doc.getElementsByTagName(i)[0];\n    }\n  }\n\n  // If we're working with a document, inject contents into\n  // the body element\n  var curParentNode = one.body;\n\n  new HTMLParser(html, {\n    start: function(tagName, attrs, unary) {\n      // If it's a pre-built element, then we can ignore\n      // its construction\n      if (one[tagName]) {\n        curParentNode = one[tagName];\n        return;\n      }\n\n      var elem = doc.createElement(tagName);\n\n      for (var attr in attrs) {\n        elem.setAttribute(attrs[attr].name, attrs[attr].value);\n      }\n\n      if (structure[tagName] && typeof one[structure[tagName]] !== 'boolean') {\n        one[structure[tagName]].appendChild(elem);\n      }\n      else if (curParentNode && curParentNode.appendChild) {\n        curParentNode.appendChild(elem);\n      }\n\n      if (!unary) {\n        elems.push(elem);\n        curParentNode = elem;\n      }\n    },\n    end: function(/* tag */) {\n      elems.length -= 1;\n\n      // Init the new parentNode\n      curParentNode = elems[elems.length - 1];\n    },\n    chars: function(text) {\n      curParentNode.appendChild(doc.createTextNode(text));\n    },\n    comment: function(/* text */) {\n      // create comment node\n    },\n    ignore: function(/* text */) {\n      // What to do here?\n    }\n  });\n\n  return doc;\n};\n",
    "670": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {\n    if (k2 === undefined)\n        k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = { enumerable: true, get: function () { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function (o, m, k, k2) {\n    if (k2 === undefined)\n        k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function (o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule)\n        return mod;\n    var result = {};\n    if (mod != null)\n        for (var k in mod)\n            if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k))\n                __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathUtils = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst path = __importStar(require(\"path\"));\nconst pathCollator = new Intl.Collator(undefined, {\n    numeric: true,\n    sensitivity: 'base'\n});\nclass PathUtils {\n    static sortFilePathArray(filePathArray) {\n        filePathArray.sort(pathCollator.compare);\n    }\n    static getPathRelativeTo(from, to) {\n        return path.relative(from, to);\n    }\n    static makeAbsolute(startDir, relativeFilePath) {\n        if (PathUtils.isAbsolute(relativeFilePath)) {\n            return relativeFilePath;\n        }\n        return path.normalize(path.join(startDir, relativeFilePath));\n    }\n    static isAbsolute(pathString) {\n        return path.isAbsolute(pathString) || /^(?:[a-zA-Z]:)?\\\\?\\\\(?:[^\\\\/:*?\"<>|\\r\\n]+\\\\)*[^\\\\/:*?\"<>|\\r\\n]*$/.test(pathString);\n    }\n    static unifyPath(pathString) {\n        if (pathString === '' || pathString === '.' || pathString === './') {\n            return './';\n        }\n        if (pathString === '/') {\n            return '/';\n        }\n        if (pathString === '../') {\n            return '../';\n        }\n        const isAbsolute = PathUtils.isAbsolute(pathString);\n        pathString = pathString.replace(/\\\\/g, '/');\n        pathString = pathString.replace(/\\/+$/g, '');\n        if (!isAbsolute) {\n            if (pathString.slice(0, 2) !== './' && pathString.slice(0, 3) !== '../') {\n                return './' + pathString;\n            }\n        }\n        return pathString;\n    }\n    static findUp(filename, startDir) {\n        const { root } = path.parse(startDir);\n        let tmpDir = startDir;\n        while (tmpDir !== root) {\n            let list;\n            try {\n                list = fs.readdirSync(tmpDir);\n            }\n            catch (e) {\n                break;\n            }\n            if (list.includes(filename) && fs.statSync(path.join(tmpDir, filename)).isFile()) {\n                // found\n                return path.join(tmpDir, filename);\n            }\n            else {\n                tmpDir = path.normalize(path.join(tmpDir, '..'));\n            }\n        }\n        return undefined;\n    }\n}\nexports.PathUtils = PathUtils;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2theW1ha293c2t5L0RvY3VtZW50cy9IaXRhYmlzL0N1cnJlbnQtV29ya3NwYWNlcy9HcmVlbklUL09ha2xlYW4vcGFja2FnZXMvcHJvZmlsZXItY29yZS9kaXN0L3NyYy9oZWxwZXIvUGF0aFV0aWxzLmpzIiwic291cmNlcyI6WyIvVXNlcnMva2F5bWFrb3dza3kvRG9jdW1lbnRzL0hpdGFiaXMvQ3VycmVudC1Xb3Jrc3BhY2VzL0dyZWVuSVQvT2FrbGVhbi9wYWNrYWdlcy9wcm9maWxlci1jb3JlL2Rpc3Qvc3JjL2hlbHBlci9QYXRoVXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxDQUFDO0FBQ2IsSUFBSSxlQUFlLEdBQUcsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFTLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7SUFDMUYsSUFBSSxFQUFFLEtBQUssU0FBUztRQUFFLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDN0IsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLHdCQUF3QixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNqRCxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDO1FBQ2xGLElBQUksR0FBRyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLGNBQWEsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUNoRSxDQUFDO0lBQ0QsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQyxD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Q3RDLElBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQztRQUN0QixPQUFPLE1BQU0sS0FBSyxJQUFJLEVBQUUsQ0FBQztZQUNyQixJQUFJLElBQUksQ0FBQztZQUNULElBQUksQ0FBQztnQkFDRCxJQUFJLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNsQyxDQUFDO1lBQ0QsT0FBTyxDQUFDLEVBQUUsQ0FBQztnQkFDUCxNQUFNO1lBQ1YsQ0FBQztZQUNELElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQztnQkFDL0UsUUFBUTtnQkFDUixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ3ZDLENBQUM7aUJBQ0ksQ0FBQztnQkFDRixNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ3JELENBQUM7UUFDTCxDQUFDO1FBQ0QsT0FBTyxTQUFTLENBQUM7SUFDckIsQ0FBQztDQUNKO0FBQ0QsT0FBTyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXRoVXRpbHMgPSB2b2lkIDA7XG5jb25zdCBmcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZnNcIikpO1xuY29uc3QgcGF0aCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicGF0aFwiKSk7XG5jb25zdCBwYXRoQ29sbGF0b3IgPSBuZXcgSW50bC5Db2xsYXRvcih1bmRlZmluZWQsIHtcbiAgICBudW1lcmljOiB0cnVlLFxuICAgIHNlbnNpdGl2aXR5OiAnYmFzZSdcbn0pO1xuY2xhc3MgUGF0aFV0aWxzIHtcbiAgICBzdGF0aWMgc29ydEZpbGVQYXRoQXJyYXkoZmlsZVBhdGhBcnJheSkge1xuICAgICAgICBmaWxlUGF0aEFycmF5LnNvcnQocGF0aENvbGxhdG9yLmNvbXBhcmUpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0UGF0aFJlbGF0aXZlVG8oZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZUFic29sdXRlKHN0YXJ0RGlyLCByZWxhdGl2ZUZpbGVQYXRoKSB7XG4gICAgICAgIGlmIChQYXRoVXRpbHMuaXNBYnNvbHV0ZShyZWxhdGl2ZUZpbGVQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlRmlsZVBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGgubm9ybWFsaXplKHBhdGguam9pbihzdGFydERpciwgcmVsYXRpdmVGaWxlUGF0aCkpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNBYnNvbHV0ZShwYXRoU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBwYXRoLmlzQWJzb2x1dGUocGF0aFN0cmluZykgfHwgL14oPzpbYS16QS1aXTopP1xcXFw/XFxcXCg/OlteXFxcXC86Kj9cIjw+fFxcclxcbl0rXFxcXCkqW15cXFxcLzoqP1wiPD58XFxyXFxuXSokLy50ZXN0KHBhdGhTdHJpbmcpO1xuICAgIH1cbiAgICBzdGF0aWMgdW5pZnlQYXRoKHBhdGhTdHJpbmcpIHtcbiAgICAgICAgaWYgKHBhdGhTdHJpbmcgPT09ICcnIHx8IHBhdGhTdHJpbmcgPT09ICcuJyB8fCBwYXRoU3RyaW5nID09PSAnLi8nKSB7XG4gICAgICAgICAgICByZXR1cm4gJy4vJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aFN0cmluZyA9PT0gJy8nKSB7XG4gICAgICAgICAgICByZXR1cm4gJy8nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoU3RyaW5nID09PSAnLi4vJykge1xuICAgICAgICAgICAgcmV0dXJuICcuLi8nO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQWJzb2x1dGUgPSBQYXRoVXRpbHMuaXNBYnNvbHV0ZShwYXRoU3RyaW5nKTtcbiAgICAgICAgcGF0aFN0cmluZyA9IHBhdGhTdHJpbmcucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgICBwYXRoU3RyaW5nID0gcGF0aFN0cmluZy5yZXBsYWNlKC9cXC8rJC9nLCAnJyk7XG4gICAgICAgIGlmICghaXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgaWYgKHBhdGhTdHJpbmcuc2xpY2UoMCwgMikgIT09ICcuLycgJiYgcGF0aFN0cmluZy5zbGljZSgwLCAzKSAhPT0gJy4uLycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJy4vJyArIHBhdGhTdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGhTdHJpbmc7XG4gICAgfVxuICAgIHN0YXRpYyBmaW5kVXAoZmlsZW5hbWUsIHN0YXJ0RGlyKSB7XG4gICAgICAgIGNvbnN0IHsgcm9vdCB9ID0gcGF0aC5wYXJzZShzdGFydERpcik7XG4gICAgICAgIGxldCB0bXBEaXIgPSBzdGFydERpcjtcbiAgICAgICAgd2hpbGUgKHRtcERpciAhPT0gcm9vdCkge1xuICAgICAgICAgICAgbGV0IGxpc3Q7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxpc3QgPSBmcy5yZWFkZGlyU3luYyh0bXBEaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaXN0LmluY2x1ZGVzKGZpbGVuYW1lKSAmJiBmcy5zdGF0U3luYyhwYXRoLmpvaW4odG1wRGlyLCBmaWxlbmFtZSkpLmlzRmlsZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gZm91bmRcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aC5qb2luKHRtcERpciwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG1wRGlyID0gcGF0aC5ub3JtYWxpemUocGF0aC5qb2luKHRtcERpciwgJy4uJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5QYXRoVXRpbHMgPSBQYXRoVXRpbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lVR0YwYUZWMGFXeHpMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dmMzSmpMMmhsYkhCbGNpOVFZWFJvVlhScGJITXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdRVUZCUVN4MVEwRkJkMEk3UVVGRGVFSXNNa05CUVRSQ08wRkJSVFZDTEUxQlFVMHNXVUZCV1N4SFFVRkhMRWxCUVVrc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eFRRVUZUTEVWQlFVVTdTVUZEYWtRc1QwRkJUeXhGUVVGRkxFbEJRVWs3U1VGRFlpeFhRVUZYTEVWQlFVVXNUVUZCVFR0RFFVTnVRaXhEUVVGRExFTkJRVUU3UVVGRlJpeE5RVUZoTEZOQlFWTTdTVUZEY2tJc1RVRkJUU3hEUVVGRExHbENRVUZwUWl4RFFVRkRMR0ZCUVhWQ08xRkJReTlETEdGQlFXRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZCTzBsQlEzcERMRU5CUVVNN1NVRkZSQ3hOUVVGTkxFTkJRVU1zYVVKQlFXbENMRU5CUVVNc1NVRkJXU3hGUVVGRkxFVkJRVlU3VVVGRGFFUXNUMEZCVHl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUVR0SlFVTXZRaXhEUVVGRE8wbEJSVVFzVFVGQlRTeERRVUZETEZsQlFWa3NRMEZCUXl4UlFVRm5RaXhGUVVGRkxHZENRVUYzUWp0UlFVTTNSQ3hKUVVGSkxGTkJRVk1zUTBGQlF5eFZRVUZWTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zUlVGQlJTeERRVUZETzFsQlF6VkRMRTlCUVU4c1owSkJRV2RDTEVOQlFVRTdVVUZEZUVJc1EwRkJRenRSUVVORUxFOUJRVThzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUlVGQlJTeG5Ra0ZCWjBJc1EwRkJReXhEUVVGRExFTkJRVUU3U1VGRE4wUXNRMEZCUXp0SlFVVkVMRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zVlVGQmEwSTdVVUZEYmtNc1QwRkJUeXhKUVVGSkxFTkJRVU1zVlVGQlZTeERRVUZETEZWQlFWVXNRMEZCUXl4SlFVRkpMR3RGUVVGclJTeERRVUZETEVsQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJRVHRKUVVNeFNDeERRVUZETzBsQlJVUXNUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJReXhWUVVGclFqdFJRVU5zUXl4SlFVRkpMRlZCUVZVc1MwRkJTeXhGUVVGRkxFbEJRVWtzVlVGQlZTeExRVUZMTEVkQlFVY3NTVUZCU1N4VlFVRlZMRXRCUVVzc1NVRkJTU3hGUVVGRkxFTkJRVU03V1VGRGNFVXNUMEZCVHl4SlFVRkpMRU5CUVVFN1VVRkRXaXhEUVVGRE8xRkJRMFFzU1VGQlNTeFZRVUZWTEV0QlFVc3NSMEZCUnl4RlFVRkZMRU5CUVVNN1dVRkRlRUlzVDBGQlR5eEhRVUZITEVOQlFVRTdVVUZEV0N4RFFVRkRPMUZCUTBRc1NVRkJTU3hWUVVGVkxFdEJRVXNzUzBGQlN5eEZRVUZGTEVOQlFVTTdXVUZETVVJc1QwRkJUeXhMUVVGTExFTkJRVUU3VVVGRFlpeERRVUZETzFGQlEwUXNUVUZCVFN4VlFVRlZMRWRCUVVjc1UwRkJVeXhEUVVGRExGVkJRVlVzUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUVR0UlFVTnVSQ3hWUVVGVkxFZEJRVWNzVlVGQlZTeERRVUZETEU5QlFVOHNRMEZCUXl4TFFVRkxMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVUU3VVVGRE0wTXNWVUZCVlN4SFFVRkhMRlZCUVZVc1EwRkJReXhQUVVGUExFTkJRVU1zVDBGQlR5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkJPMUZCUXpWRExFbEJRVWtzUTBGQlF5eFZRVUZWTEVWQlFVVXNRMEZCUXp0WlFVTnFRaXhKUVVGSkxGVkJRVlVzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFbEJRVWtzU1VGQlNTeFZRVUZWTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eExRVUZMTEVWQlFVVXNRMEZCUXp0blFrRkRla1VzVDBGQlR5eEpRVUZKTEVkQlFVY3NWVUZCVlN4RFFVRkJPMWxCUTNwQ0xFTkJRVU03VVVGRFJpeERRVUZETzFGQlEwUXNUMEZCVHl4VlFVRlZMRU5CUVVFN1NVRkRiRUlzUTBGQlF6dEpRVVZFTEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUTFvc1VVRkJaMElzUlVGRGFFSXNVVUZCWjBJN1VVRkZhRUlzVFVGQlRTeEZRVUZGTEVsQlFVa3NSVUZCUlN4SFFVRkhMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVRTdVVUZGY2tNc1NVRkJTU3hOUVVGTkxFZEJRVWNzVVVGQlVTeERRVUZCTzFGQlJYSkNMRTlCUVU4c1RVRkJUU3hMUVVGTExFbEJRVWtzUlVGQlJTeERRVUZETzFsQlEzaENMRWxCUVVrc1NVRkJZeXhEUVVGQk8xbEJRMnhDTEVsQlFVa3NRMEZCUXp0blFrRkRTaXhKUVVGSkxFZEJRVWNzUlVGQlJTeERRVUZETEZkQlFWY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRVHRaUVVNNVFpeERRVUZETzFsQlFVTXNUMEZCVHl4RFFVRk5MRVZCUVVVc1EwRkJRenRuUWtGRGFrSXNUVUZCU3p0WlFVTk9MRU5CUVVNN1dVRkRSQ3hKUVVGSkxFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExGRkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEUxQlFVMHNSVUZCUlN4RlFVRkZMRU5CUVVNN1owSkJRMnhHTEZGQlFWRTdaMEpCUTFJc1QwRkJUeXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNSVUZCUlN4UlFVRlJMRU5CUVVNc1EwRkJRVHRaUVVOdVF5eERRVUZETzJsQ1FVRk5MRU5CUVVNN1owSkJRMUFzVFVGQlRTeEhRVUZITEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJRVHRaUVVOcVJDeERRVUZETzFGQlEwWXNRMEZCUXp0UlFVTkVMRTlCUVU4c1UwRkJVeXhEUVVGQk8wbEJRMnBDTEVOQlFVTTdRMEZEUkR0QlFXcEZSQ3c0UWtGcFJVTWlmUT09Il19",
    "671": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {\n    if (k2 === undefined)\n        k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = { enumerable: true, get: function () { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function (o, m, k, k2) {\n    if (k2 === undefined)\n        k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function (o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule)\n        return mod;\n    var result = {};\n    if (mod != null)\n        for (var k in mod)\n            if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k))\n                __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnifiedPath = void 0;\nconst path = __importStar(require(\"path\"));\nconst PathUtils_1 = require(\"../helper/PathUtils\");\nclass UnifiedPath {\n    constructor(...args) {\n        if (args.length === 0 || args.length === 1) {\n            this._unifiedPath = PathUtils_1.PathUtils.unifyPath(args[0] || '');\n        }\n        else {\n            this._unifiedPath = PathUtils_1.PathUtils.unifyPath(args.join('/'));\n        }\n    }\n    static fromPathParts(parts) {\n        return new UnifiedPath(parts[0]).join(...parts.slice(1));\n    }\n    copy() {\n        return new UnifiedPath(this._unifiedPath);\n    }\n    /**\n     * String representation of a UnifiedPath\n     *\n     * @returns\n     */\n    toString() {\n        return this._unifiedPath;\n    }\n    /**\n     * Returns UnifiedPath as a string for the current platform\n     *\n     * @returns\n     */\n    toPlatformString() {\n        return this._unifiedPath.split('/').join(path.sep);\n    }\n    /**\n     * JSON representation of a UnifiedPath\n     *\n     * @returns\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Returns the directory name of a path\n     *\n     * @returns\n     */\n    dirName() {\n        return new UnifiedPath(path.dirname(this.toString()));\n    }\n    /**\n     * Returns the basename name of a path\n     *\n     * @returns The basename of the path (path/to/index.coffee.md -> index.coffee.md)\n     */\n    basename() {\n        return path.basename(this.toString());\n    }\n    /**\n     * Returns the extension of a path\n     *\n     * @returns The extension of the path (path/to/index.coffee.md -> .md)\n     */\n    extname() {\n        return path.extname(this.basename());\n    }\n    isRelative() {\n        return this._unifiedPath === '' || (this._unifiedPath[0] !== '/' && !this.isAbsoluteWindowsPath());\n    }\n    isAbsoluteWindowsPath() {\n        return /^[A-Za-z]:/.test(this._unifiedPath);\n    }\n    /**\n     * Gives the relative UnifiedPath that points from this to the other path\n     *\n     * @param other\n     * @returns\n     */\n    pathTo(other) {\n        if (typeof other === 'string') {\n            other = new UnifiedPath(other);\n        }\n        return new UnifiedPath(PathUtils_1.PathUtils.getPathRelativeTo(this.toString(), other.toString()));\n    }\n    /**\n     * Splits the path into an array of it's components\n     *\n     * @returns\n     */\n    split() {\n        if (!this._parts) {\n            const parts = this._unifiedPath.split('/');\n            if (parts[0] === '' && parts.length > 1) {\n                parts[0] = '/';\n            }\n            if (parts[0] === '.' && parts.length > 1) {\n                parts.splice(0, 1);\n            }\n            this._parts = parts;\n        }\n        return this._parts;\n    }\n    join(...args) {\n        if (args.length === 0) {\n            return new UnifiedPath(this._unifiedPath);\n        }\n        const parts = [];\n        for (const part of args) {\n            if (typeof part === 'string') {\n                parts.push(new UnifiedPath(part).toString());\n            }\n            else {\n                parts.push(part.toString());\n            }\n        }\n        return new UnifiedPath(path.posix.join(this._unifiedPath, ...parts));\n    }\n    /**\n     * Returns the unified path from the root of the path to the first occurrence of the given directory\n     * and the remainder\n     *\n     * /path/to/node_modules/node_module_name/file -> /path/to/node_modules\n     *\n     * @param dirName\n     * @returns\n     */\n    pathUntilSubDir(dirName) {\n        const pathParts = this.split();\n        const firstMatch = pathParts.indexOf(dirName);\n        if (firstMatch !== -1) {\n            return {\n                match: new UnifiedPath(path.posix.join(...pathParts.slice(0, firstMatch + 1))),\n                remainder: new UnifiedPath(path.posix.join(...pathParts.slice(firstMatch + 1))),\n            };\n        }\n        return undefined;\n    }\n}\nexports.UnifiedPath = UnifiedPath;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2theW1ha293c2t5L0RvY3VtZW50cy9IaXRhYmlzL0N1cnJlbnQtV29ya3NwYWNlcy9HcmVlbklUL09ha2xlYW4vcGFja2FnZXMvcHJvZmlsZXItY29yZS9kaXN0L3NyYy9zeXN0ZW0vVW5pZmllZFBhdGguanMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYXltYWtvd3NreS9Eb2N1bWVudHMvSGl0YWJpcy9DdXJyZW50LVdvcmtzcGFjZXMvR3JlZW5JVC9PYWtsZWFuL3BhY2thZ2VzL3Byb2ZpbGVyLWNvcmUvZGlzdC9zcmMvc3lzdGVtL1VuaWZpZWRQYXRoLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQztBQUNiLElBQUksZUFBZSxHQUFHLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBUyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0lBQzFGLElBQUksRUFBRSxLQUFLLFNBQVM7UUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzdCLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDakQsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQztRQUNsRixJQUFJLEdBQUcsRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxjQUFhLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDaEUsQ0FBQztJQUNELE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxJQUFJLENB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V0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDakQsQ0FBQztpQkFDSSxDQUFDO2dCQUNGLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDaEMsQ0FBQztRQUNMLENBQUM7UUFDRCxPQUFPLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFDRDs7Ozs7Ozs7T0FRRztJQUNILGVBQWUsQ0FBQyxPQUFPO1FBQ25CLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUMvQixNQUFNLFVBQVUsR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzlDLElBQUksVUFBVSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDcEIsT0FBTztnQkFDSCxLQUFLLEVBQUUsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxVQUFVLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDOUUsU0FBUyxFQUFFLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNsRixDQUFDO1FBQ04sQ0FBQztRQUNELE9BQU8sU0FBUyxDQUFDO0lBQ3JCLENBQUM7Q0FDSjtBQUNELE9BQU8sQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5pZmllZFBhdGggPSB2b2lkIDA7XG5jb25zdCBwYXRoID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJwYXRoXCIpKTtcbmNvbnN0IFBhdGhVdGlsc18xID0gcmVxdWlyZShcIi4uL2hlbHBlci9QYXRoVXRpbHNcIik7XG5jbGFzcyBVbmlmaWVkUGF0aCB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDAgfHwgYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3VuaWZpZWRQYXRoID0gUGF0aFV0aWxzXzEuUGF0aFV0aWxzLnVuaWZ5UGF0aChhcmdzWzBdIHx8ICcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3VuaWZpZWRQYXRoID0gUGF0aFV0aWxzXzEuUGF0aFV0aWxzLnVuaWZ5UGF0aChhcmdzLmpvaW4oJy8nKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb21QYXRoUGFydHMocGFydHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVbmlmaWVkUGF0aChwYXJ0c1swXSkuam9pbiguLi5wYXJ0cy5zbGljZSgxKSk7XG4gICAgfVxuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVW5pZmllZFBhdGgodGhpcy5fdW5pZmllZFBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBVbmlmaWVkUGF0aFxuICAgICAqXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VuaWZpZWRQYXRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFVuaWZpZWRQYXRoIGFzIGEgc3RyaW5nIGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybVxuICAgICAqXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICB0b1BsYXRmb3JtU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5pZmllZFBhdGguc3BsaXQoJy8nKS5qb2luKHBhdGguc2VwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIFVuaWZpZWRQYXRoXG4gICAgICpcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlyZWN0b3J5IG5hbWUgb2YgYSBwYXRoXG4gICAgICpcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGRpck5hbWUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVW5pZmllZFBhdGgocGF0aC5kaXJuYW1lKHRoaXMudG9TdHJpbmcoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiYXNlbmFtZSBuYW1lIG9mIGEgcGF0aFxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJhc2VuYW1lIG9mIHRoZSBwYXRoIChwYXRoL3RvL2luZGV4LmNvZmZlZS5tZCAtPiBpbmRleC5jb2ZmZWUubWQpXG4gICAgICovXG4gICAgYmFzZW5hbWUoKSB7XG4gICAgICAgIHJldHVybiBwYXRoLmJhc2VuYW1lKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBvZiBhIHBhdGhcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBleHRlbnNpb24gb2YgdGhlIHBhdGggKHBhdGgvdG8vaW5kZXguY29mZmVlLm1kIC0+IC5tZClcbiAgICAgKi9cbiAgICBleHRuYW1lKCkge1xuICAgICAgICByZXR1cm4gcGF0aC5leHRuYW1lKHRoaXMuYmFzZW5hbWUoKSk7XG4gICAgfVxuICAgIGlzUmVsYXRpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bmlmaWVkUGF0aCA9PT0gJycgfHwgKHRoaXMuX3VuaWZpZWRQYXRoWzBdICE9PSAnLycgJiYgIXRoaXMuaXNBYnNvbHV0ZVdpbmRvd3NQYXRoKCkpO1xuICAgIH1cbiAgICBpc0Fic29sdXRlV2luZG93c1BhdGgoKSB7XG4gICAgICAgIHJldHVybiAvXltBLVphLXpdOi8udGVzdCh0aGlzLl91bmlmaWVkUGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVzIHRoZSByZWxhdGl2ZSBVbmlmaWVkUGF0aCB0aGF0IHBvaW50cyBmcm9tIHRoaXMgdG8gdGhlIG90aGVyIHBhdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdGhlclxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcGF0aFRvKG90aGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3RoZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvdGhlciA9IG5ldyBVbmlmaWVkUGF0aChvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVbmlmaWVkUGF0aChQYXRoVXRpbHNfMS5QYXRoVXRpbHMuZ2V0UGF0aFJlbGF0aXZlVG8odGhpcy50b1N0cmluZygpLCBvdGhlci50b1N0cmluZygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwbGl0cyB0aGUgcGF0aCBpbnRvIGFuIGFycmF5IG9mIGl0J3MgY29tcG9uZW50c1xuICAgICAqXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzcGxpdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wYXJ0cykge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLl91bmlmaWVkUGF0aC5zcGxpdCgnLycpO1xuICAgICAgICAgICAgaWYgKHBhcnRzWzBdID09PSAnJyAmJiBwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcGFydHNbMF0gPSAnLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydHNbMF0gPT09ICcuJyAmJiBwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKDAsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGFydHMgPSBwYXJ0cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGFydHM7XG4gICAgfVxuICAgIGpvaW4oLi4uYXJncykge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5pZmllZFBhdGgodGhpcy5fdW5pZmllZFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBhcmdzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChuZXcgVW5pZmllZFBhdGgocGFydCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVbmlmaWVkUGF0aChwYXRoLnBvc2l4LmpvaW4odGhpcy5fdW5pZmllZFBhdGgsIC4uLnBhcnRzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVuaWZpZWQgcGF0aCBmcm9tIHRoZSByb290IG9mIHRoZSBwYXRoIHRvIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIHRoZSBnaXZlbiBkaXJlY3RvcnlcbiAgICAgKiBhbmQgdGhlIHJlbWFpbmRlclxuICAgICAqXG4gICAgICogL3BhdGgvdG8vbm9kZV9tb2R1bGVzL25vZGVfbW9kdWxlX25hbWUvZmlsZSAtPiAvcGF0aC90by9ub2RlX21vZHVsZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXJOYW1lXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBwYXRoVW50aWxTdWJEaXIoZGlyTmFtZSkge1xuICAgICAgICBjb25zdCBwYXRoUGFydHMgPSB0aGlzLnNwbGl0KCk7XG4gICAgICAgIGNvbnN0IGZpcnN0TWF0Y2ggPSBwYXRoUGFydHMuaW5kZXhPZihkaXJOYW1lKTtcbiAgICAgICAgaWYgKGZpcnN0TWF0Y2ggIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1hdGNoOiBuZXcgVW5pZmllZFBhdGgocGF0aC5wb3NpeC5qb2luKC4uLnBhdGhQYXJ0cy5zbGljZSgwLCBmaXJzdE1hdGNoICsgMSkpKSxcbiAgICAgICAgICAgICAgICByZW1haW5kZXI6IG5ldyBVbmlmaWVkUGF0aChwYXRoLnBvc2l4LmpvaW4oLi4ucGF0aFBhcnRzLnNsaWNlKGZpcnN0TWF0Y2ggKyAxKSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5pZmllZFBhdGggPSBVbmlmaWVkUGF0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVZXNXBabWxsWkZCaGRHZ3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk5emNtTXZjM2x6ZEdWdEwxVnVhV1pwWldSUVlYUm9MblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPMEZCUVVFc01rTkJRVFJDTzBGQlJUVkNMRzFFUVVFclF6dEJRVTh2UXl4TlFVRmhMRmRCUVZjN1NVRkpka0lzV1VGQldTeEhRVUZITEVsQlFXTTdVVUZETlVJc1NVRkJTU3hKUVVGSkxFTkJRVU1zVFVGQlRTeExRVUZMTEVOQlFVTXNTVUZCU1N4SlFVRkpMRU5CUVVNc1RVRkJUU3hMUVVGTExFTkJRVU1zUlVGQlJTeERRVUZETzFsQlF6VkRMRWxCUVVrc1EwRkJReXhaUVVGWkxFZEJRVWNzY1VKQlFWTXNRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4RFFVRkJPMUZCUTNaRUxFTkJRVU03WVVGQlRTeERRVUZETzFsQlExQXNTVUZCU1N4RFFVRkRMRmxCUVZrc1IwRkJSeXh4UWtGQlV5eERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVRTdVVUZEZUVRc1EwRkJRenRKUVVOR0xFTkJRVU03U1VGRlJDeE5RVUZOTEVOQlFVTXNZVUZCWVN4RFFVRkRMRXRCUVdVN1VVRkRia01zVDBGQlR5eEpRVUZKTEZkQlFWY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVRTdTVUZEZWtRc1EwRkJRenRKUVVWRUxFbEJRVWs3VVVGRFNDeFBRVUZQTEVsQlFVa3NWMEZCVnl4RFFVRkRMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlFUdEpRVU14UXl4RFFVRkRPMGxCUlVRN096czdUMEZKUnp0SlFVTklMRkZCUVZFN1VVRkRVQ3hQUVVGUExFbEJRVWtzUTBGQlF5eFpRVUZyUXl4RFFVRkJPMGxCUXk5RExFTkJRVU03U1VGRlJEczdPenRQUVVsSE8wbEJRMGdzWjBKQlFXZENPMUZCUTJZc1QwRkJUeXhKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkJPMGxCUTI1RUxFTkJRVU03U1VGRlJEczdPenRQUVVsSE8wbEJRMGdzVFVGQlRUdFJRVU5NTEU5QlFVOHNTVUZCU1N4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGQk8wbEJRM1pDTEVOQlFVTTdTVUZGUkRzN096dFBRVWxITzBsQlEwZ3NUMEZCVHp0UlFVTk9MRTlCUVU4c1NVRkJTU3hYUVVGWExFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZCTzBsQlEzUkVMRU5CUVVNN1NVRkZSRHM3T3p0UFFVbEhPMGxCUTBnc1VVRkJVVHRSUVVOUUxFOUJRVThzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zUTBGQlFUdEpRVU4wUXl4RFFVRkRPMGxCUlVRN096czdUMEZKUnp0SlFVTklMRTlCUVU4N1VVRkRUaXhQUVVGUExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVUU3U1VGRGNrTXNRMEZCUXp0SlFVVkVMRlZCUVZVN1VVRkRWQ3hQUVVGUExFbEJRVWtzUTBGQlF5eFpRVUZaTEV0QlFVc3NSVUZCUlN4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4SFFVRkhMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zY1VKQlFYRkNMRVZCUVVVc1EwRkJReXhEUVVGQk8wbEJRMjVITEVOQlFVTTdTVUZGUkN4eFFrRkJjVUk3VVVGRGNFSXNUMEZCVHl4WlFVRlpMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUVR0SlFVTTFReXhEUVVGRE8wbEJSVVE3T3pzN08wOUJTMGM3U1VGRFNDeE5RVUZOTEVOQlFVTXNTMEZCTWtJN1VVRkRha01zU1VGQlNTeFBRVUZQTEV0QlFVc3NTMEZCU3l4UlFVRlJMRVZCUVVVc1EwRkJRenRaUVVNdlFpeExRVUZMTEVkQlFVY3NTVUZCU1N4WFFVRlhMRU5CUVVNc1MwRkJaU3hEUVVGRExFTkJRVUU3VVVGRGVrTXNRMEZCUXp0UlFVTkVMRTlCUVU4c1NVRkJTU3hYUVVGWExFTkJRVU1zY1VKQlFWTXNRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RlFVRkZMRVZCUVVVc1MwRkJTeXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUVR0SlFVTjJSaXhEUVVGRE8wbEJSVVE3T3pzN1QwRkpSenRKUVVOSUxFdEJRVXM3VVVGRFNpeEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRE8xbEJRMnhDTEUxQlFVMHNTMEZCU3l4SFFVRkhMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zUzBGQlN5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkJPMWxCUXpGRExFbEJRVWtzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRVZCUVVVc1NVRkJTU3hMUVVGTExFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRPMmRDUVVONlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhEUVVGQk8xbEJRMllzUTBGQlF6dFpRVU5FTEVsQlFVa3NTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFZEJRVWNzU1VGQlNTeExRVUZMTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRE8yZENRVU14UXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUVR0WlFVTnVRaXhEUVVGRE8xbEJRMFFzU1VGQlNTeERRVUZETEUxQlFVMHNSMEZCUnl4TFFVRnBReXhEUVVGQk8xRkJRMmhFTEVOQlFVTTdVVUZEUkN4UFFVRlBMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVUU3U1VGRGJrSXNRMEZCUXp0SlFVVkVMRWxCUVVrc1EwRkJReXhIUVVGSExFbEJRV2xETzFGQlEzaERMRWxCUVVrc1NVRkJTU3hEUVVGRExFMUJRVTBzUzBGQlN5eERRVUZETEVWQlFVVXNRMEZCUXp0WlFVTjJRaXhQUVVGUExFbEJRVWtzVjBGQlZ5eERRVUZETEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJRVHRSUVVNeFF5eERRVUZETzFGQlEwUXNUVUZCVFN4TFFVRkxMRWRCUVdFc1JVRkJSU3hEUVVGQk8xRkJRekZDTEV0QlFVc3NUVUZCVFN4SlFVRkpMRWxCUVVrc1NVRkJTU3hGUVVGRkxFTkJRVU03V1VGRGVrSXNTVUZCU1N4UFFVRlBMRWxCUVVrc1MwRkJTeXhSUVVGUkxFVkJRVVVzUTBGQlF6dG5Ra0ZET1VJc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEZkQlFWY3NRMEZCUXl4SlFVRmpMRU5CUVVNc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eERRVUZCTzFsQlEzWkVMRU5CUVVNN2FVSkJRVTBzUTBGQlF6dG5Ra0ZEVUN4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RFFVRkJPMWxCUXpWQ0xFTkJRVU03VVVGRFJpeERRVUZETzFGQlEwUXNUMEZCVHl4SlFVRkpMRmRCUVZjc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1dVRkJXU3hGUVVGRkxFZEJRVWNzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUVR0SlFVTnlSU3hEUVVGRE8wbEJSVVE3T3pzN096czdPMDlCVVVjN1NVRkRTQ3hsUVVGbExFTkJRVU1zVDBGQkswSTdVVUZET1VNc1RVRkJUU3hUUVVGVExFZEJRVWNzU1VGQlNTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkJPMUZCUXpsQ0xFMUJRVTBzVlVGQlZTeEhRVUZITEZOQlFWTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVUU3VVVGRk4wTXNTVUZCU1N4VlFVRlZMRXRCUVVzc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF6dFpRVU4yUWl4UFFVRlBPMmRDUVVOT0xFdEJRVXNzUlVGQlJTeEpRVUZKTEZkQlFWY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEZOQlFWTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhGUVVGRkxGVkJRVlVzUjBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNMVJTeFRRVUZUTEVWQlFVVXNTVUZCU1N4WFFVRlhMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4VFFVRlRMRU5CUVVNc1MwRkJTeXhEUVVGRExGVkJRVlVzUjBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMkZCUXpkRkxFTkJRVUU3VVVGRFJpeERRVUZETzFGQlEwUXNUMEZCVHl4VFFVRlRMRU5CUVVFN1NVRkRha0lzUTBGQlF6dERRVU5FTzBGQmRFcEVMR3REUVhOS1F5SjkiXX0=",
    "736": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {\n    if (k2 === undefined)\n        k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = { enumerable: true, get: function () { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function (o, m, k, k2) {\n    if (k2 === undefined)\n        k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function (o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule)\n        return mod;\n    var result = {};\n    if (mod != null)\n        for (var k in mod)\n            if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k))\n                __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InspectorHelper = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst inspector_1 = __importDefault(require(\"inspector\"));\nconst LoggerHelper_1 = require(\"./LoggerHelper\");\nconst PermissionHelper_1 = require(\"./PermissionHelper\");\nconst TypescriptParser_1 = require(\"./TypescriptParser\");\nconst SourceMap_1 = require(\"../model/SourceMap\");\nconst UnifiedPath_1 = require(\"../system/UnifiedPath\");\nclass InspectorHelper {\n    constructor() {\n        this._session = new inspector_1.default.Session();\n        this.sourceCodeMap = new Map();\n        this.sourceMapMap = new Map();\n        this.loadedFiles = new Map();\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._session.connect();\n            // wait for debugger to be enabled\n            yield new Promise((resolve) => {\n                this._session.post('Debugger.enable', resolve);\n            });\n        });\n    }\n    storeToFile(filePath, kind) {\n        if (!fs.existsSync(filePath.dirName().toPlatformString())) {\n            PermissionHelper_1.PermissionHelper.mkdirRecursivelyWithUserPermission(filePath.dirName().toPlatformString());\n        }\n        switch (kind) {\n            case 'pretty-json':\n                PermissionHelper_1.PermissionHelper.writeFileWithUserPermission(filePath.toPlatformString(), JSON.stringify(this, null, 2));\n                break;\n            case 'json':\n                PermissionHelper_1.PermissionHelper.writeFileWithUserPermission(filePath.toPlatformString(), JSON.stringify(this));\n                break;\n            default:\n                break;\n        }\n    }\n    static loadFromFile(filePath) {\n        if (!fs.existsSync(filePath.toPlatformString())) {\n            return undefined;\n        }\n        return InspectorHelper.fromJSON(fs.readFileSync(filePath.toPlatformString()).toString());\n    }\n    toJSON() {\n        return {\n            sourceCodeMap: Object.fromEntries(this.sourceCodeMap),\n            loadedFiles: Object.fromEntries(this.loadedFiles)\n        };\n    }\n    static fromJSON(json) {\n        let data;\n        if (typeof json === 'string') {\n            data = JSON.parse(json);\n        }\n        else {\n            data = json;\n        }\n        const result = new InspectorHelper();\n        for (const [key, value] of Object.entries(data.sourceCodeMap)) {\n            result.sourceCodeMap.set(key, value);\n        }\n        for (const [key, value] of Object.entries(data.loadedFiles)) {\n            result.loadedFiles.set(key, value);\n        }\n        return result;\n    }\n    listen() {\n        this._session.on('inspectorNotification', (message) => __awaiter(this, void 0, void 0, function* () {\n            if (message.method === 'Debugger.scriptParsed') {\n                const params = message.params;\n                yield this.sourceCodeFromId(params.scriptId);\n            }\n        }));\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield new Promise((resolve) => {\n                this._session.post('Debugger.disable', resolve);\n            });\n            this._session.disconnect();\n        });\n    }\n    fillSourceMapsFromCPUModel(cpuModel) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const scriptMap = new Map();\n            for (const location of cpuModel.ILocations) {\n                const scriptId = location.callFrame.scriptId.toString();\n                if (scriptMap.has(scriptId)) {\n                    continue;\n                }\n                scriptMap.set(scriptId, location.callFrame.url);\n            }\n            const promises = [];\n            for (const [scriptId, filePath] of scriptMap) {\n                promises.push(this.sourceMapFromId(new UnifiedPath_1.UnifiedPath(filePath), scriptId));\n            }\n            yield Promise.all(promises);\n        });\n    }\n    loadFile(relativePath, filePath) {\n        let source = this.loadedFiles.get(relativePath.toString());\n        if (source !== undefined) {\n            return source;\n        }\n        source = fs.readFileSync(filePath.toPlatformString()).toString();\n        this.loadedFiles.set(relativePath.toString(), source);\n        return source;\n    }\n    parseFile(relativePath, filePath) {\n        const source = this.loadFile(relativePath, filePath);\n        return TypescriptParser_1.TypescriptParser.parseSource(filePath, source);\n    }\n    sourceCodeFromId(scriptId, filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (scriptId === '0') {\n                return null;\n            }\n            let source = this.sourceCodeMap.get(scriptId);\n            if (source !== undefined) {\n                return source;\n            }\n            const result = yield (new Promise((resolve) => {\n                this._session.post('Debugger.getScriptSource', { scriptId }, (err, args) => {\n                    if (err) {\n                        resolve({ source: '', err });\n                    }\n                    else {\n                        resolve({ source: args.scriptSource });\n                    }\n                });\n            }));\n            if (result.err) {\n                LoggerHelper_1.LoggerHelper.error('Error getting script source', result.err, { scriptId, filePath });\n                throw result.err;\n            }\n            source = result.source;\n            this.sourceCodeMap.set(scriptId, source);\n            return source;\n        });\n    }\n    sourceMapFromId(filePath, scriptId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (scriptId === '0') {\n                return null;\n            }\n            let sourceMap = this.sourceMapMap.get(scriptId);\n            if (sourceMap !== undefined) {\n                return sourceMap;\n            }\n            const sourceCode = yield this.sourceCodeFromId(scriptId, filePath);\n            if (sourceCode === null) {\n                throw new Error(`No source map found for scriptId ${filePath.toPlatformString()} ${scriptId}`);\n            }\n            sourceMap = SourceMap_1.SourceMap.fromCompiledJSString(filePath, sourceCode);\n            this.sourceMapMap.set(scriptId, sourceMap);\n            return sourceMap;\n        });\n    }\n}\nexports.InspectorHelper = InspectorHelper;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2theW1ha293c2t5L0RvY3VtZW50cy9IaXRhYmlzL0N1cnJlbnQtV29ya3NwYWNlcy9HcmVlbklUL09ha2xlYW4vcGFja2FnZXMvcHJvZmlsZXItY29yZS9kaXN0L3NyYy9oZWxwZXIvSW5zcGVjdG9ySGVscGVyLmpzIiwic291cmNlcyI6WyIvVXNlcnMva2F5bWFrb3dza3kvRG9jdW1lbnRzL0hpdGFiaXMvQ3VycmVudC1Xb3Jrc3BhY2VzL0dyZWVuSVQvT2FrbGVhbi9wYWNrYWdlcy9wcm9maWxlci1jb3JlL2Rpc3Qvc3JjL2hlbHBlci9JbnNwZWN0b3JIZWxwZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxDQUFDO0FBQ2IsSUFBSSxlQUFlLEdBQUcsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFTLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7SUFDMUYsSUFBSSxFQUFFLEtBQUssU0FBUztRQUFFLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDN0IsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLHdCQUF3QixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNqRCxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDO1FBQ2xGLElBQUksR0FBRyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLGNBQWEsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUNoRSxDQUFDO0lBQ0QsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFF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QUMsQ0FBQztZQUNuRSxJQUFJLFVBQVUsS0FBSyxJQUFJLEVBQUUsQ0FBQztnQkFDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsUUFBUSxDQUFDLGdCQUFnQixFQUFFLElBQUksUUFBUSxFQUFFLENBQUMsQ0FBQztZQUNuRyxDQUFDO1lBQ0QsU0FBUyxHQUFHLFdBQVcsQ0FBQyxTQUFTLENBQUMsb0JBQW9CLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1lBQzdFLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUMzQyxPQUFPLFNBQVMsQ0FBQztRQUNyQixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7Q0FDSjtBQUNELE9BQU8sQ0FBQyxlQUFlLEdBQUcsZUFBZSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnNwZWN0b3JIZWxwZXIgPSB2b2lkIDA7XG5jb25zdCBmcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZnNcIikpO1xuY29uc3QgaW5zcGVjdG9yXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImluc3BlY3RvclwiKSk7XG5jb25zdCBMb2dnZXJIZWxwZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlckhlbHBlclwiKTtcbmNvbnN0IFBlcm1pc3Npb25IZWxwZXJfMSA9IHJlcXVpcmUoXCIuL1Blcm1pc3Npb25IZWxwZXJcIik7XG5jb25zdCBUeXBlc2NyaXB0UGFyc2VyXzEgPSByZXF1aXJlKFwiLi9UeXBlc2NyaXB0UGFyc2VyXCIpO1xuY29uc3QgU291cmNlTWFwXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvU291cmNlTWFwXCIpO1xuY29uc3QgVW5pZmllZFBhdGhfMSA9IHJlcXVpcmUoXCIuLi9zeXN0ZW0vVW5pZmllZFBhdGhcIik7XG5jbGFzcyBJbnNwZWN0b3JIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9zZXNzaW9uID0gbmV3IGluc3BlY3Rvcl8xLmRlZmF1bHQuU2Vzc2lvbigpO1xuICAgICAgICB0aGlzLnNvdXJjZUNvZGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc291cmNlTWFwTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxvYWRlZEZpbGVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fc2Vzc2lvbi5jb25uZWN0KCk7XG4gICAgICAgICAgICAvLyB3YWl0IGZvciBkZWJ1Z2dlciB0byBiZSBlbmFibGVkXG4gICAgICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nlc3Npb24ucG9zdCgnRGVidWdnZXIuZW5hYmxlJywgcmVzb2x2ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3JlVG9GaWxlKGZpbGVQYXRoLCBraW5kKSB7XG4gICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhmaWxlUGF0aC5kaXJOYW1lKCkudG9QbGF0Zm9ybVN0cmluZygpKSkge1xuICAgICAgICAgICAgUGVybWlzc2lvbkhlbHBlcl8xLlBlcm1pc3Npb25IZWxwZXIubWtkaXJSZWN1cnNpdmVseVdpdGhVc2VyUGVybWlzc2lvbihmaWxlUGF0aC5kaXJOYW1lKCkudG9QbGF0Zm9ybVN0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3ByZXR0eS1qc29uJzpcbiAgICAgICAgICAgICAgICBQZXJtaXNzaW9uSGVscGVyXzEuUGVybWlzc2lvbkhlbHBlci53cml0ZUZpbGVXaXRoVXNlclBlcm1pc3Npb24oZmlsZVBhdGgudG9QbGF0Zm9ybVN0cmluZygpLCBKU09OLnN0cmluZ2lmeSh0aGlzLCBudWxsLCAyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICBQZXJtaXNzaW9uSGVscGVyXzEuUGVybWlzc2lvbkhlbHBlci53cml0ZUZpbGVXaXRoVXNlclBlcm1pc3Npb24oZmlsZVBhdGgudG9QbGF0Zm9ybVN0cmluZygpLCBKU09OLnN0cmluZ2lmeSh0aGlzKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBsb2FkRnJvbUZpbGUoZmlsZVBhdGgpIHtcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGZpbGVQYXRoLnRvUGxhdGZvcm1TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEluc3BlY3RvckhlbHBlci5mcm9tSlNPTihmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgudG9QbGF0Zm9ybVN0cmluZygpKS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlQ29kZU1hcDogT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuc291cmNlQ29kZU1hcCksXG4gICAgICAgICAgICBsb2FkZWRGaWxlczogT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMubG9hZGVkRmlsZXMpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBpZiAodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBqc29uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBJbnNwZWN0b3JIZWxwZXIoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YS5zb3VyY2VDb2RlTWFwKSkge1xuICAgICAgICAgICAgcmVzdWx0LnNvdXJjZUNvZGVNYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEubG9hZGVkRmlsZXMpKSB7XG4gICAgICAgICAgICByZXN1bHQubG9hZGVkRmlsZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxpc3RlbigpIHtcbiAgICAgICAgdGhpcy5fc2Vzc2lvbi5vbignaW5zcGVjdG9yTm90aWZpY2F0aW9uJywgKG1lc3NhZ2UpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gJ0RlYnVnZ2VyLnNjcmlwdFBhcnNlZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBtZXNzYWdlLnBhcmFtcztcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnNvdXJjZUNvZGVGcm9tSWQocGFyYW1zLnNjcmlwdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXNzaW9uLnBvc3QoJ0RlYnVnZ2VyLmRpc2FibGUnLCByZXNvbHZlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fc2Vzc2lvbi5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaWxsU291cmNlTWFwc0Zyb21DUFVNb2RlbChjcHVNb2RlbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc2NyaXB0TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsb2NhdGlvbiBvZiBjcHVNb2RlbC5JTG9jYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0SWQgPSBsb2NhdGlvbi5jYWxsRnJhbWUuc2NyaXB0SWQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2NyaXB0TWFwLmhhcyhzY3JpcHRJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjcmlwdE1hcC5zZXQoc2NyaXB0SWQsIGxvY2F0aW9uLmNhbGxGcmFtZS51cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3NjcmlwdElkLCBmaWxlUGF0aF0gb2Ygc2NyaXB0TWFwKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnNvdXJjZU1hcEZyb21JZChuZXcgVW5pZmllZFBhdGhfMS5VbmlmaWVkUGF0aChmaWxlUGF0aCksIHNjcmlwdElkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb2FkRmlsZShyZWxhdGl2ZVBhdGgsIGZpbGVQYXRoKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSB0aGlzLmxvYWRlZEZpbGVzLmdldChyZWxhdGl2ZVBhdGgudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgudG9QbGF0Zm9ybVN0cmluZygpKS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLmxvYWRlZEZpbGVzLnNldChyZWxhdGl2ZVBhdGgudG9TdHJpbmcoKSwgc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG4gICAgcGFyc2VGaWxlKHJlbGF0aXZlUGF0aCwgZmlsZVBhdGgpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5sb2FkRmlsZShyZWxhdGl2ZVBhdGgsIGZpbGVQYXRoKTtcbiAgICAgICAgcmV0dXJuIFR5cGVzY3JpcHRQYXJzZXJfMS5UeXBlc2NyaXB0UGFyc2VyLnBhcnNlU291cmNlKGZpbGVQYXRoLCBzb3VyY2UpO1xuICAgIH1cbiAgICBzb3VyY2VDb2RlRnJvbUlkKHNjcmlwdElkLCBmaWxlUGF0aCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHNjcmlwdElkID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzb3VyY2UgPSB0aGlzLnNvdXJjZUNvZGVNYXAuZ2V0KHNjcmlwdElkKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCAobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXNzaW9uLnBvc3QoJ0RlYnVnZ2VyLmdldFNjcmlwdFNvdXJjZScsIHsgc2NyaXB0SWQgfSwgKGVyciwgYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgc291cmNlOiAnJywgZXJyIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHNvdXJjZTogYXJncy5zY3JpcHRTb3VyY2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VySGVscGVyXzEuTG9nZ2VySGVscGVyLmVycm9yKCdFcnJvciBnZXR0aW5nIHNjcmlwdCBzb3VyY2UnLCByZXN1bHQuZXJyLCB7IHNjcmlwdElkLCBmaWxlUGF0aCB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQuZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlID0gcmVzdWx0LnNvdXJjZTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlQ29kZU1hcC5zZXQoc2NyaXB0SWQsIHNvdXJjZSk7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc291cmNlTWFwRnJvbUlkKGZpbGVQYXRoLCBzY3JpcHRJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHNjcmlwdElkID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzb3VyY2VNYXAgPSB0aGlzLnNvdXJjZU1hcE1hcC5nZXQoc2NyaXB0SWQpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZU1hcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZU1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUNvZGUgPSB5aWVsZCB0aGlzLnNvdXJjZUNvZGVGcm9tSWQoc2NyaXB0SWQsIGZpbGVQYXRoKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VDb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzb3VyY2UgbWFwIGZvdW5kIGZvciBzY3JpcHRJZCAke2ZpbGVQYXRoLnRvUGxhdGZvcm1TdHJpbmcoKX0gJHtzY3JpcHRJZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZU1hcCA9IFNvdXJjZU1hcF8xLlNvdXJjZU1hcC5mcm9tQ29tcGlsZWRKU1N0cmluZyhmaWxlUGF0aCwgc291cmNlQ29kZSk7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZU1hcE1hcC5zZXQoc2NyaXB0SWQsIHNvdXJjZU1hcCk7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlTWFwO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkluc3BlY3RvckhlbHBlciA9IEluc3BlY3RvckhlbHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVNXNXpjR1ZqZEc5eVNHVnNjR1Z5TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dkxpNHZjM0pqTDJobGJIQmxjaTlKYm5Od1pXTjBiM0pJWld4d1pYSXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3UVVGQlFTeDFRMEZCZDBJN1FVRkRlRUlzTUVSQlFXbERPMEZCUldwRExHbEVRVUUyUXp0QlFVVTNReXg1UkVGQmNVUTdRVUZEY2tRc2VVUkJRWEZFTzBGQlJYSkVMR3RFUVVFNFF6dEJRVU01UXl4MVJFRkJiVVE3UVVGTGJrUXNUVUZCWVN4bFFVRmxPMGxCVlROQ08xRkJRME1zU1VGQlNTeERRVUZETEZGQlFWRXNSMEZCUnl4SlFVRkpMRzFDUVVGVExFTkJRVU1zVDBGQlR5eEZRVUZGTEVOQlFVRTdVVUZEZGtNc1NVRkJTU3hEUVVGRExHRkJRV0VzUjBGQlJ5eEpRVUZKTEVkQlFVY3NSVUZCUlN4RFFVRkJPMUZCUXpsQ0xFbEJRVWtzUTBGQlF5eFpRVUZaTEVkQlFVY3NTVUZCU1N4SFFVRkhMRVZCUVVVc1EwRkJRVHRSUVVNM1FpeEpRVUZKTEVOQlFVTXNWMEZCVnl4SFFVRkhMRWxCUVVrc1IwRkJSeXhGUVVGRkxFTkJRVUU3U1VGRE4wSXNRMEZCUXp0SlFVVkxMRTlCUVU4N08xbEJRMW9zU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4UFFVRlBMRVZCUVVVc1EwRkJRVHRaUVVOMlFpeHJRMEZCYTBNN1dVRkRiRU1zVFVGQlRTeEpRVUZKTEU5QlFVOHNRMEZCUXl4RFFVRkRMRTlCUVU4c1JVRkJSU3hGUVVGRk8yZENRVU0zUWl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUTBGQlF5eHBRa0ZCYVVJc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlFUdFpRVU12UXl4RFFVRkRMRU5CUVVNc1EwRkJRVHRSUVVOSUxFTkJRVU03UzBGQlFUdEpRVVZFTEZkQlFWY3NRMEZEVml4UlFVRnhRaXhGUVVOeVFpeEpRVUUwUWp0UlFVVTFRaXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEZWQlFWVXNRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJUeXhGUVVGRkxFTkJRVU1zWjBKQlFXZENMRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU03V1VGRE0wUXNiVU5CUVdkQ0xFTkJRVU1zYTBOQlFXdERMRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUlVGQlJTeERRVUZETEdkQ1FVRm5RaXhGUVVGRkxFTkJRVU1zUTBGQlFUdFJRVU16Uml4RFFVRkRPMUZCUlVRc1VVRkJVU3hKUVVGSkxFVkJRVVVzUTBGQlF6dFpRVU5rTEV0QlFVc3NZVUZCWVR0blFrRkRha0lzYlVOQlFXZENMRU5CUVVNc01rSkJRVEpDTEVOQlF6TkRMRkZCUVZFc1EwRkJReXhuUWtGQlowSXNSVUZCUlN4RlFVTXpRaXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NSVUZCUlN4SlFVRkpMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRemRDTEVOQlFVRTdaMEpCUTBRc1RVRkJTenRaUVVOT0xFdEJRVXNzVFVGQlRUdG5Ra0ZEVml4dFEwRkJaMElzUTBGQlF5d3lRa0ZCTWtJc1EwRkRNME1zVVVGQlVTeERRVUZETEdkQ1FVRm5RaXhGUVVGRkxFVkJRek5DTEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRM0JDTEVOQlFVRTdaMEpCUTBRc1RVRkJTenRaUVVOT08yZENRVU5ETEUxQlFVczdVVUZEVUN4RFFVRkRPMGxCUTBZc1EwRkJRenRKUVVWRUxFMUJRVTBzUTBGQlF5eFpRVUZaTEVOQlEyeENMRkZCUVhGQ08xRkJSWEpDTEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1ZVRkJWU3hEUVVGRExGRkJRVkVzUTBGQlF5eG5Ra0ZCWjBJc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF6dFpRVU5xUkN4UFFVRlBMRk5CUVZNc1EwRkJRVHRSUVVOcVFpeERRVUZETzFGQlEwUXNUMEZCVHl4bFFVRmxMRU5CUVVNc1VVRkJVU3hEUVVNNVFpeEZRVUZGTEVOQlFVTXNXVUZCV1N4RFFVRkRMRkZCUVZFc1EwRkJReXhuUWtGQlowSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRM1pFTEVOQlFVRTdTVUZEUml4RFFVRkRPMGxCUlVRc1RVRkJUVHRSUVVOTUxFOUJRVTg3V1VGRFRpeGhRVUZoTEVWQlFVVXNUVUZCVFN4RFFVRkRMRmRCUVZjc1EwRkJReXhKUVVGSkxFTkJRVU1zWVVGQllTeERRVUZETzFsQlEzSkVMRmRCUVZjc1JVRkJSU3hOUVVGTkxFTkJRVU1zVjBGQlZ5eERRVUZETEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNN1UwRkRha1FzUTBGQlFUdEpRVU5HTEVOQlFVTTdTVUZGUkN4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVOa0xFbEJRU3RDTzFGQlJTOUNMRWxCUVVrc1NVRkJjMElzUTBGQlFUdFJRVU14UWl4SlFVRkpMRTlCUVU4c1NVRkJTU3hMUVVGTExGRkJRVkVzUlVGQlJTeERRVUZETzFsQlF6bENMRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkJPMUZCUTNoQ0xFTkJRVU03WVVGQlRTeERRVUZETzFsQlExQXNTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJRVHRSUVVOYUxFTkJRVU03VVVGRFJDeE5RVUZOTEUxQlFVMHNSMEZCUnl4SlFVRkpMR1ZCUVdVc1JVRkJSU3hEUVVGQk8xRkJRM0JETEV0QlFVc3NUVUZCVFN4RFFVRkRMRWRCUVVjc1JVRkJSU3hMUVVGTExFTkJRVU1zU1VGQlNTeE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXhoUVVGaExFTkJRVU1zUlVGQlJTeERRVUZETzFsQlF5OUVMRTFCUVUwc1EwRkJReXhoUVVGaExFTkJRVU1zUjBGQlJ5eERRVUZETEVkQlFVY3NSVUZCUlN4TFFVRkxMRU5CUVVNc1EwRkJRVHRSUVVOeVF5eERRVUZETzFGQlJVUXNTMEZCU3l4TlFVRk5MRU5CUVVNc1IwRkJSeXhGUVVGRkxFdEJRVXNzUTBGQlF5eEpRVUZKTEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eEZRVUZGTEVOQlFVTTdXVUZETjBRc1RVRkJUU3hEUVVGRExGZEJRVmNzUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCZVVJc1JVRkJSU3hMUVVGTExFTkJRVU1zUTBGQlFUdFJRVU42UkN4RFFVRkRPMUZCUlVRc1QwRkJUeXhOUVVGTkxFTkJRVUU3U1VGRFpDeERRVUZETzBsQlJVUXNUVUZCVFR0UlFVTk1MRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUlVGQlJTeERRVUZETEhWQ1FVRjFRaXhGUVVGRkxFTkJRVThzVDBGQlR5eEZRVUZGTEVWQlFVVTdXVUZETTBRc1NVRkJTU3hQUVVGUExFTkJRVU1zVFVGQlRTeExRVUZMTEhWQ1FVRjFRaXhGUVVGRkxFTkJRVU03WjBKQlEyaEVMRTFCUVUwc1RVRkJUU3hIUVVGSExFOUJRVThzUTBGQlF5eE5RVWQwUWl4RFFVRkJPMmRDUVVORUxFMUJRVTBzU1VGQlNTeERRVUZETEdkQ1FVRm5RaXhEUVVGRExFMUJRVTBzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUVR0WlFVTTNReXhEUVVGRE8xRkJRMFlzUTBGQlF5eERRVUZCTEVOQlFVTXNRMEZCUVR0SlFVTklMRU5CUVVNN1NVRkZTeXhWUVVGVk96dFpRVU5tTEUxQlFVMHNTVUZCU1N4UFFVRlBMRU5CUVVNc1EwRkJReXhQUVVGUExFVkJRVVVzUlVGQlJUdG5Ra0ZETjBJc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTXNhMEpCUVd0Q0xFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVRTdXVUZEYUVRc1EwRkJReXhEUVVGRExFTkJRVUU3V1VGRFJpeEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRlZCUVZVc1JVRkJSU3hEUVVGQk8xRkJRek5DTEVOQlFVTTdTMEZCUVR0SlFVVkxMREJDUVVFd1FpeERRVUZETEZGQlFXdENPenRaUVVOc1JDeE5RVUZOTEZOQlFWTXNSMEZCUnl4SlFVRkpMRWRCUVVjc1JVRkJhMElzUTBGQlFUdFpRVVV6UXl4TFFVRkxMRTFCUVUwc1VVRkJVU3hKUVVGSkxGRkJRVkVzUTBGQlF5eFZRVUZWTEVWQlFVVXNRMEZCUXp0blFrRkROVU1zVFVGQlRTeFJRVUZSTEVkQlFVY3NVVUZCVVN4RFFVRkRMRk5CUVZNc1EwRkJReXhSUVVGUkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVRTdaMEpCUTNaRUxFbEJRVWtzVTBGQlV5eERRVUZETEVkQlFVY3NRMEZCUXl4UlFVRlJMRU5CUVVNc1JVRkJSU3hEUVVGRE8yOUNRVU0zUWl4VFFVRlJPMmRDUVVOVUxFTkJRVU03WjBKQlEwUXNVMEZCVXl4RFFVRkRMRWRCUVVjc1EwRkJReXhSUVVGUkxFVkJRVVVzVVVGQlVTeERRVUZETEZOQlFWTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJRVHRaUVVOb1JDeERRVUZETzFsQlJVUXNUVUZCVFN4UlFVRlJMRWRCUVVjc1JVRkJSU3hEUVVGQk8xbEJRMjVDTEV0QlFVc3NUVUZCVFN4RFFVRkRMRkZCUVZFc1JVRkJSU3hSUVVGUkxFTkJRVU1zU1VGQlNTeFRRVUZUTEVWQlFVVXNRMEZCUXp0blFrRkRPVU1zVVVGQlVTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1pVRkJaU3hEUVVGRExFbEJRVWtzZVVKQlFWY3NRMEZCUXl4UlFVRlJMRU5CUVVNc1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZCTzFsQlEzcEZMRU5CUVVNN1dVRkZSQ3hOUVVGTkxFOUJRVThzUTBGQlF5eEhRVUZITEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVFN1VVRkROVUlzUTBGQlF6dExRVUZCTzBsQlJVUXNVVUZCVVN4RFFVRkRMRmxCUVhsQ0xFVkJRVVVzVVVGQmNVSTdVVUZEZUVRc1NVRkJTU3hOUVVGTkxFZEJRVWNzU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4SFFVRkhMRU5CUVVNc1dVRkJXU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVRTdVVUZETVVRc1NVRkJTU3hOUVVGTkxFdEJRVXNzVTBGQlV5eEZRVUZGTEVOQlFVTTdXVUZETVVJc1QwRkJUeXhOUVVGTkxFTkJRVUU3VVVGRFpDeERRVUZETzFGQlEwUXNUVUZCVFN4SFFVRkhMRVZCUVVVc1EwRkJReXhaUVVGWkxFTkJRVU1zVVVGQlVTeERRVUZETEdkQ1FVRm5RaXhGUVVGRkxFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUVR0UlFVTm9SU3hKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEVkQlFVY3NRMEZCUXl4WlFVRlpMRU5CUVVNc1VVRkJVU3hGUVVGRkxFVkJRVVVzVFVGQlRTeERRVUZETEVOQlFVRTdVVUZEY2tRc1QwRkJUeXhOUVVGTkxFTkJRVUU3U1VGRFpDeERRVUZETzBsQlJVUXNVMEZCVXl4RFFVRkRMRmxCUVhsQ0xFVkJRVVVzVVVGQmNVSTdVVUZEZWtRc1RVRkJUU3hOUVVGTkxFZEJRVWNzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4WlFVRlpMRVZCUVVVc1VVRkJVU3hEUVVGRExFTkJRVUU3VVVGRGNFUXNUMEZCVHl4dFEwRkJaMElzUTBGQlF5eFhRVUZYTEVOQlFVTXNVVUZCVVN4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGQk8wbEJRM1JFTEVOQlFVTTdTVUZGU3l4blFrRkJaMElzUTBGRGNrSXNVVUZCWjBJc1JVRkRhRUlzVVVGQmMwSTdPMWxCUlhSQ0xFbEJRVWtzVVVGQlVTeExRVUZMTEVkQlFVY3NSVUZCUlN4RFFVRkRPMmRDUVVOMFFpeFBRVUZQTEVsQlFVa3NRMEZCUVR0WlFVTmFMRU5CUVVNN1dVRkRSQ3hKUVVGSkxFMUJRVTBzUjBGQlJ5eEpRVUZKTEVOQlFVTXNZVUZCWVN4RFFVRkRMRWRCUVVjc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlFUdFpRVU0zUXl4SlFVRkpMRTFCUVUwc1MwRkJTeXhUUVVGVExFVkJRVVVzUTBGQlF6dG5Ra0ZETVVJc1QwRkJUeXhOUVVGTkxFTkJRVUU3V1VGRFpDeERRVUZETzFsQlJVUXNUVUZCVFN4TlFVRk5MRWRCUVVjc1RVRkJUU3hEUVVGRExFbEJRVWtzVDBGQlR5eERRVXN2UWl4RFFVRkRMRTlCUVU4c1JVRkJSU3hGUVVGRk8yZENRVU5pTEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1NVRkJTU3hEUVVGRExEQkNRVUV3UWl4RlFVRkZMRVZCUVVVc1VVRkJVU3hGUVVGRkxFVkJRVVVzUTBGQlF5eEhRVUZITEVWQlFVVXNTVUZCU1N4RlFVRkZMRVZCUVVVN2IwSkJRekZGTEVsQlFVa3NSMEZCUnl4RlFVRkZMRU5CUVVNN2QwSkJRMVFzVDBGQlR5eERRVUZETEVWQlFVVXNUVUZCVFN4RlFVRkZMRVZCUVVVc1JVRkJSU3hIUVVGSExFVkJRVVVzUTBGQlF5eERRVUZCTzI5Q1FVTTNRaXhEUVVGRE8zbENRVUZOTEVOQlFVTTdkMEpCUTFBc1QwRkJUeXhEUVVGRExFVkJRVVVzVFVGQlRTeEZRVUZGTEVsQlFVa3NRMEZCUXl4WlFVRlpMRVZCUVVVc1EwRkJReXhEUVVGQk8yOUNRVU4yUXl4RFFVRkRPMmRDUVVOR0xFTkJRVU1zUTBGQlF5eERRVUZCTzFsQlEwZ3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRVHRaUVVOSUxFbEJRVWtzVFVGQlRTeERRVUZETEVkQlFVY3NSVUZCUlN4RFFVRkRPMmRDUVVOb1Fpd3lRa0ZCV1N4RFFVRkRMRXRCUVVzc1EwRkJReXcyUWtGQk5rSXNSVUZCUlN4TlFVRk5MRU5CUVVNc1IwRkJSeXhGUVVGRkxFVkJRVVVzVVVGQlVTeEZRVUZGTEZGQlFWRXNSVUZCUlN4RFFVRkRMRU5CUVVFN1owSkJRM0pHTEUxQlFVMHNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJRVHRaUVVOcVFpeERRVUZETzFsQlEwUXNUVUZCVFN4SFFVRkhMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVUU3V1VGRGRFSXNTVUZCU1N4RFFVRkRMR0ZCUVdFc1EwRkJReXhIUVVGSExFTkJRVU1zVVVGQlVTeEZRVUZGTEUxQlFVMHNRMEZCUXl4RFFVRkJPMWxCUTNoRExFOUJRVThzVFVGQlRTeERRVUZCTzFGQlEyUXNRMEZCUXp0TFFVRkJPMGxCUlVzc1pVRkJaU3hEUVVOd1FpeFJRVUZ4UWl4RlFVTnlRaXhSUVVGblFqczdXVUZGYUVJc1NVRkJTU3hSUVVGUkxFdEJRVXNzUjBGQlJ5eEZRVUZGTEVOQlFVTTdaMEpCUTNSQ0xFOUJRVThzU1VGQlNTeERRVUZCTzFsQlExb3NRMEZCUXp0WlFVTkVMRWxCUVVrc1UwRkJVeXhIUVVGSExFbEJRVWtzUTBGQlF5eFpRVUZaTEVOQlFVTXNSMEZCUnl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGQk8xbEJReTlETEVsQlFVa3NVMEZCVXl4TFFVRkxMRk5CUVZNc1JVRkJSU3hEUVVGRE8yZENRVU0zUWl4UFFVRlBMRk5CUVZNc1EwRkJRVHRaUVVOcVFpeERRVUZETzFsQlEwUXNUVUZCVFN4VlFVRlZMRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1VVRkJVU3hGUVVGRkxGRkJRVkVzUTBGQlF5eERRVUZCTzFsQlEyeEZMRWxCUVVrc1ZVRkJWU3hMUVVGTExFbEJRVWtzUlVGQlJTeERRVUZETzJkQ1FVTjZRaXhOUVVGTkxFbEJRVWtzUzBGQlN5eERRVUZETEc5RFFVRnZReXhSUVVGUkxFTkJRVU1zWjBKQlFXZENMRVZCUVVVc1NVRkJTU3hSUVVGUkxFVkJRVVVzUTBGQlF5eERRVUZCTzFsQlF5OUdMRU5CUVVNN1dVRkRSQ3hUUVVGVExFZEJRVWNzY1VKQlFWTXNRMEZCUXl4dlFrRkJiMElzUTBGQlF5eFJRVUZSTEVWQlFVVXNWVUZCVlN4RFFVRkRMRU5CUVVFN1dVRkRhRVVzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1VVRkJVU3hGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZCTzFsQlF6RkRMRTlCUVU4c1UwRkJVeXhEUVVGQk8xRkJSV3BDTEVOQlFVTTdTMEZCUVR0RFFVTkVPMEZCZEUxRUxEQkRRWE5OUXlKOSJdfQ==",
    "737": "'use strict';\n\nconst {\n  JSONParse,\n  JSONStringify,\n  SafeMap,\n  SymbolDispose,\n} = primordials;\n\nconst {\n  ERR_INSPECTOR_ALREADY_ACTIVATED,\n  ERR_INSPECTOR_ALREADY_CONNECTED,\n  ERR_INSPECTOR_CLOSED,\n  ERR_INSPECTOR_COMMAND,\n  ERR_INSPECTOR_NOT_AVAILABLE,\n  ERR_INSPECTOR_NOT_CONNECTED,\n  ERR_INSPECTOR_NOT_ACTIVE,\n  ERR_INSPECTOR_NOT_WORKER,\n} = require('internal/errors').codes;\n\nconst { hasInspector } = internalBinding('config');\nif (!hasInspector)\n  throw new ERR_INSPECTOR_NOT_AVAILABLE();\n\nconst EventEmitter = require('events');\nconst { queueMicrotask } = require('internal/process/task_queues');\nconst {\n  isUint32,\n  validateFunction,\n  validateInt32,\n  validateObject,\n  validateString,\n} = require('internal/validators');\nconst { isMainThread } = require('worker_threads');\nconst { _debugEnd } = internalBinding('process_methods');\n\nconst {\n  Connection,\n  MainThreadConnection,\n  open,\n  url,\n  isEnabled,\n  waitForDebugger,\n  console,\n} = internalBinding('inspector');\n\nclass Session extends EventEmitter {\n  #connection = null;\n  #nextId = 1;\n  #messageCallbacks = new SafeMap();\n\n  /**\n   * Connects the session to the inspector back-end.\n   * @returns {void}\n   */\n  connect() {\n    if (this.#connection)\n      throw new ERR_INSPECTOR_ALREADY_CONNECTED('The inspector session');\n    this.#connection = new Connection((message) => this.#onMessage(message));\n  }\n\n  /**\n   * Connects the session to the main thread\n   * inspector back-end.\n   * @returns {void}\n   */\n  connectToMainThread() {\n    if (isMainThread)\n      throw new ERR_INSPECTOR_NOT_WORKER();\n    if (this.#connection)\n      throw new ERR_INSPECTOR_ALREADY_CONNECTED('The inspector session');\n    this.#connection =\n      new MainThreadConnection(\n        (message) => queueMicrotask(() => this.#onMessage(message)));\n  }\n\n  #onMessage(message) {\n    const parsed = JSONParse(message);\n    try {\n      if (parsed.id) {\n        const callback = this.#messageCallbacks.get(parsed.id);\n        this.#messageCallbacks.delete(parsed.id);\n        if (callback) {\n          if (parsed.error) {\n            return callback(\n              new ERR_INSPECTOR_COMMAND(parsed.error.code, parsed.error.message),\n            );\n          }\n\n          callback(null, parsed.result);\n        }\n      } else {\n        this.emit(parsed.method, parsed);\n        this.emit('inspectorNotification', parsed);\n      }\n    } catch (error) {\n      process.emitWarning(error);\n    }\n  }\n\n  /**\n   * Posts a message to the inspector back-end.\n   * @param {string} method\n   * @param {Record<unknown, unknown>} [params]\n   * @param {Function} [callback]\n   * @returns {void}\n   */\n  post(method, params, callback) {\n    validateString(method, 'method');\n    if (!callback && typeof params === 'function') {\n      callback = params;\n      params = null;\n    }\n    if (params) {\n      validateObject(params, 'params');\n    }\n    if (callback) {\n      validateFunction(callback, 'callback');\n    }\n\n    if (!this.#connection) {\n      throw new ERR_INSPECTOR_NOT_CONNECTED();\n    }\n    const id = this.#nextId++;\n    const message = { id, method };\n    if (params) {\n      message.params = params;\n    }\n    if (callback) {\n      this.#messageCallbacks.set(id, callback);\n    }\n    this.#connection.dispatch(JSONStringify(message));\n  }\n\n  /**\n   * Immediately closes the session, all pending\n   * message callbacks will be called with an\n   * error.\n   * @returns {void}\n   */\n  disconnect() {\n    if (!this.#connection)\n      return;\n    this.#connection.disconnect();\n    this.#connection = null;\n    const remainingCallbacks = this.#messageCallbacks.values();\n    for (const callback of remainingCallbacks) {\n      process.nextTick(callback, new ERR_INSPECTOR_CLOSED());\n    }\n    this.#messageCallbacks.clear();\n    this.#nextId = 1;\n  }\n}\n\n/**\n * Activates inspector on host and port.\n * @param {number} [port]\n * @param {string} [host]\n * @param {boolean} [wait]\n * @returns {void}\n */\nfunction inspectorOpen(port, host, wait) {\n  if (isEnabled()) {\n    throw new ERR_INSPECTOR_ALREADY_ACTIVATED();\n  }\n  // inspectorOpen() currently does not typecheck its arguments and adding\n  // such checks would be a potentially breaking change. However, the native\n  // open() function requires the port to fit into a 16-bit unsigned integer,\n  // causing an integer overflow otherwise, so we at least need to prevent that.\n  if (isUint32(port)) {\n    validateInt32(port, 'port', 0, 65535);\n  }\n  open(port, host);\n  if (wait)\n    waitForDebugger();\n\n  return { __proto__: null, [SymbolDispose]() { _debugEnd(); } };\n}\n\n/**\n * Blocks until a client (existing or connected later)\n * has sent the `Runtime.runIfWaitingForDebugger`\n * command.\n * @returns {void}\n */\nfunction inspectorWaitForDebugger() {\n  if (!waitForDebugger())\n    throw new ERR_INSPECTOR_NOT_ACTIVE();\n}\n\nmodule.exports = {\n  open: inspectorOpen,\n  close: _debugEnd,\n  url,\n  waitForDebugger: inspectorWaitForDebugger,\n  console,\n  Session,\n};\n",
    "741": "\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PerformanceHelper = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst TimeHelper_1 = require(\"./TimeHelper\");\nconst PermissionHelper_1 = require(\"./PermissionHelper\");\nconst ENABLE_PERFORMANCE_TRACKING = process.env.OAKLEAN_ENABLE_PERFORMANCE_TRACKING !== undefined;\nclass PerformanceHelper {\n    constructor() {\n        this._measures = new Map();\n        this._firstMeasure = BigInt(0);\n        this._lastMeasure = BigInt(0);\n    }\n    static loadFromFile(path) {\n        if (fs_1.default.existsSync(path.toPlatformString())) {\n            const jsonString = fs_1.default.readFileSync(path.toPlatformString(), 'utf8').toString();\n            return JSON.parse(jsonString);\n        }\n        return { measures: {} };\n    }\n    static storeToFile(path, data) {\n        const dir = path.dirName();\n        if (!fs_1.default.existsSync(dir.toPlatformString())) {\n            PermissionHelper_1.PermissionHelper.mkdirRecursivelyWithUserPermission(dir);\n        }\n        fs_1.default.writeFileSync(path.toPlatformString(), JSON.stringify(data, null, 2));\n    }\n    exportAndSum(path) {\n        if (!ENABLE_PERFORMANCE_TRACKING) {\n            return;\n        }\n        const report = PerformanceHelper.loadFromFile(path);\n        for (const [name, measure] of this._measures) {\n            if (measure.end) {\n                const diff = Number(measure.end - measure.start);\n                report.measures[name] = (report.measures[name] || 0) + diff;\n            }\n        }\n        PerformanceHelper.storeToFile(path, report);\n    }\n    start(name) {\n        if (!ENABLE_PERFORMANCE_TRACKING) {\n            return;\n        }\n        const time = TimeHelper_1.TimeHelper.getCurrentHighResolutionTime();\n        if (!this._firstMeasure) {\n            this._firstMeasure = time;\n        }\n        this._measures.set(name, {\n            start: time,\n            end: null\n        });\n    }\n    stop(name) {\n        if (!ENABLE_PERFORMANCE_TRACKING) {\n            return;\n        }\n        const time = TimeHelper_1.TimeHelper.getCurrentHighResolutionTime();\n        this._lastMeasure = time;\n        const measure = this._measures.get(name);\n        if (measure) {\n            measure.end = time;\n        }\n    }\n    static printAccumulatedReport(path) {\n        const loadedReport = PerformanceHelper.loadFromFile(path);\n        console.log('Accumulated performance report:');\n        const report = {};\n        for (const name of Object.keys(loadedReport.measures)) {\n            report[name] = {\n                'Duration': `${(loadedReport.measures[name] / 1e9).toFixed(3)} s`\n            };\n        }\n        console.table(report, ['Duration']);\n    }\n    printReport(title) {\n        if (!ENABLE_PERFORMANCE_TRACKING) {\n            return;\n        }\n        const report = {};\n        const total = Number(this._lastMeasure - this._firstMeasure);\n        for (const [name, measure] of this._measures) {\n            if (measure.end) {\n                const diff = Number(measure.end - measure.start);\n                report[name] = {\n                    'Duration': `${(diff / 1e9).toFixed(3)} s`,\n                    'Percentage': `${((diff / total) * 100).toFixed(2)} %`\n                };\n            }\n            else {\n                report[name] = {\n                    'Duration': 'N/A',\n                    'Percentage': 'N/A'\n                };\n            }\n        }\n        console.log(`Performance report (${title}):`, (total / 1e9).toFixed(3), 's');\n        console.table(report, ['Duration', 'Percentage']);\n    }\n}\nexports.PerformanceHelper = PerformanceHelper;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2theW1ha293c2t5L0RvY3VtZW50cy9IaXRhYmlzL0N1cnJlbnQtV29ya3NwYWNlcy9HcmVlbklUL09ha2xlYW4vcGFja2FnZXMvcHJvZmlsZXItY29yZS9kaXN0L3NyYy9oZWxwZXIvUGVyZm9ybWFuY2VIZWxwZXIuanMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYXltYWtvd3NreS9Eb2N1bWVudHMvSGl0YWJpcy9DdXJyZW50LVdvcmtzcGFjZXMvR3JlZW5JVC9PYWtsZWFuL3BhY2thZ2VzL3Byb2ZpbGVyLWNvcmUvZGlzdC9zcmMvaGVscGVyL1BlcmZvcm1hbmNlSGVscGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQztBQUNiLElBQUksZUFBZSxHQUFHLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxVQUFVLEdBQUc7SUFDakUsT0FBTyxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFDOUQsQ0FBQyxDQUFDO0FBQ0YsTUFBTSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsWUFBWSxFQUFFLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7QUFDOUQsT0FBTyxDQUFDLGlCQUFpQixHQUFHLEtBQUssQ0FBQyxDQUFDO0FBQ25DLE1BQU0sSUFBSSxHQUFHLGVBQWUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUM1QyxNQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDN0MsTUFBTSxrQkFBa0IsR0FBRyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUN6RCxNQUFNLDJCQUEyQixHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUNBQW1DLEtBQUssU0FBUyxDQUFDO0FBQ2xHLE1BQU0saUJBQWlCO0lB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QyxTQUFTLEVBQUUsQ0FBQztZQUMzQyxJQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDZCxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ2pELE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRztvQkFDWCxVQUFVLEVBQUUsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUk7b0JBQzFDLFlBQVksRUFBRSxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJO2lCQUN6RCxDQUFDO1lBQ04sQ0FBQztpQkFDSSxDQUFDO2dCQUNGLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRztvQkFDWCxVQUFVLEVBQUUsS0FBSztvQkFDakIsWUFBWSxFQUFFLEtBQUs7aUJBQ3RCLENBQUM7WUFDTixDQUFDO1FBQ0wsQ0FBQztRQUNELE9BQU8sQ0FBQyxHQUFHLENBQUMsdUJBQXVCLEtBQUssSUFBSSxFQUFFLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUM3RSxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLFVBQVUsRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQ3RELENBQUM7Q0FDSjtBQUNELE9BQU8sQ0FBQyxpQkFBaUIsR0FBRyxpQkFBaUIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QZXJmb3JtYW5jZUhlbHBlciA9IHZvaWQgMDtcbmNvbnN0IGZzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImZzXCIpKTtcbmNvbnN0IFRpbWVIZWxwZXJfMSA9IHJlcXVpcmUoXCIuL1RpbWVIZWxwZXJcIik7XG5jb25zdCBQZXJtaXNzaW9uSGVscGVyXzEgPSByZXF1aXJlKFwiLi9QZXJtaXNzaW9uSGVscGVyXCIpO1xuY29uc3QgRU5BQkxFX1BFUkZPUk1BTkNFX1RSQUNLSU5HID0gcHJvY2Vzcy5lbnYuT0FLTEVBTl9FTkFCTEVfUEVSRk9STUFOQ0VfVFJBQ0tJTkcgIT09IHVuZGVmaW5lZDtcbmNsYXNzIFBlcmZvcm1hbmNlSGVscGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbWVhc3VyZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2ZpcnN0TWVhc3VyZSA9IEJpZ0ludCgwKTtcbiAgICAgICAgdGhpcy5fbGFzdE1lYXN1cmUgPSBCaWdJbnQoMCk7XG4gICAgfVxuICAgIHN0YXRpYyBsb2FkRnJvbUZpbGUocGF0aCkge1xuICAgICAgICBpZiAoZnNfMS5kZWZhdWx0LmV4aXN0c1N5bmMocGF0aC50b1BsYXRmb3JtU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gZnNfMS5kZWZhdWx0LnJlYWRGaWxlU3luYyhwYXRoLnRvUGxhdGZvcm1TdHJpbmcoKSwgJ3V0ZjgnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWVhc3VyZXM6IHt9IH07XG4gICAgfVxuICAgIHN0YXRpYyBzdG9yZVRvRmlsZShwYXRoLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGRpciA9IHBhdGguZGlyTmFtZSgpO1xuICAgICAgICBpZiAoIWZzXzEuZGVmYXVsdC5leGlzdHNTeW5jKGRpci50b1BsYXRmb3JtU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICBQZXJtaXNzaW9uSGVscGVyXzEuUGVybWlzc2lvbkhlbHBlci5ta2RpclJlY3Vyc2l2ZWx5V2l0aFVzZXJQZXJtaXNzaW9uKGRpcik7XG4gICAgICAgIH1cbiAgICAgICAgZnNfMS5kZWZhdWx0LndyaXRlRmlsZVN5bmMocGF0aC50b1BsYXRmb3JtU3RyaW5nKCksIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpKTtcbiAgICB9XG4gICAgZXhwb3J0QW5kU3VtKHBhdGgpIHtcbiAgICAgICAgaWYgKCFFTkFCTEVfUEVSRk9STUFOQ0VfVFJBQ0tJTkcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXBvcnQgPSBQZXJmb3JtYW5jZUhlbHBlci5sb2FkRnJvbUZpbGUocGF0aCk7XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIG1lYXN1cmVdIG9mIHRoaXMuX21lYXN1cmVzKSB7XG4gICAgICAgICAgICBpZiAobWVhc3VyZS5lbmQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gTnVtYmVyKG1lYXN1cmUuZW5kIC0gbWVhc3VyZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgcmVwb3J0Lm1lYXN1cmVzW25hbWVdID0gKHJlcG9ydC5tZWFzdXJlc1tuYW1lXSB8fCAwKSArIGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUGVyZm9ybWFuY2VIZWxwZXIuc3RvcmVUb0ZpbGUocGF0aCwgcmVwb3J0KTtcbiAgICB9XG4gICAgc3RhcnQobmFtZSkge1xuICAgICAgICBpZiAoIUVOQUJMRV9QRVJGT1JNQU5DRV9UUkFDS0lORykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWUgPSBUaW1lSGVscGVyXzEuVGltZUhlbHBlci5nZXRDdXJyZW50SGlnaFJlc29sdXRpb25UaW1lKCk7XG4gICAgICAgIGlmICghdGhpcy5fZmlyc3RNZWFzdXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9maXJzdE1lYXN1cmUgPSB0aW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21lYXN1cmVzLnNldChuYW1lLCB7XG4gICAgICAgICAgICBzdGFydDogdGltZSxcbiAgICAgICAgICAgIGVuZDogbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RvcChuYW1lKSB7XG4gICAgICAgIGlmICghRU5BQkxFX1BFUkZPUk1BTkNFX1RSQUNLSU5HKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZSA9IFRpbWVIZWxwZXJfMS5UaW1lSGVscGVyLmdldEN1cnJlbnRIaWdoUmVzb2x1dGlvblRpbWUoKTtcbiAgICAgICAgdGhpcy5fbGFzdE1lYXN1cmUgPSB0aW1lO1xuICAgICAgICBjb25zdCBtZWFzdXJlID0gdGhpcy5fbWVhc3VyZXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAobWVhc3VyZSkge1xuICAgICAgICAgICAgbWVhc3VyZS5lbmQgPSB0aW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwcmludEFjY3VtdWxhdGVkUmVwb3J0KHBhdGgpIHtcbiAgICAgICAgY29uc3QgbG9hZGVkUmVwb3J0ID0gUGVyZm9ybWFuY2VIZWxwZXIubG9hZEZyb21GaWxlKHBhdGgpO1xuICAgICAgICBjb25zb2xlLmxvZygnQWNjdW11bGF0ZWQgcGVyZm9ybWFuY2UgcmVwb3J0OicpO1xuICAgICAgICBjb25zdCByZXBvcnQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGxvYWRlZFJlcG9ydC5tZWFzdXJlcykpIHtcbiAgICAgICAgICAgIHJlcG9ydFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAnRHVyYXRpb24nOiBgJHsobG9hZGVkUmVwb3J0Lm1lYXN1cmVzW25hbWVdIC8gMWU5KS50b0ZpeGVkKDMpfSBzYFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLnRhYmxlKHJlcG9ydCwgWydEdXJhdGlvbiddKTtcbiAgICB9XG4gICAgcHJpbnRSZXBvcnQodGl0bGUpIHtcbiAgICAgICAgaWYgKCFFTkFCTEVfUEVSRk9STUFOQ0VfVFJBQ0tJTkcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXBvcnQgPSB7fTtcbiAgICAgICAgY29uc3QgdG90YWwgPSBOdW1iZXIodGhpcy5fbGFzdE1lYXN1cmUgLSB0aGlzLl9maXJzdE1lYXN1cmUpO1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBtZWFzdXJlXSBvZiB0aGlzLl9tZWFzdXJlcykge1xuICAgICAgICAgICAgaWYgKG1lYXN1cmUuZW5kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZiA9IE51bWJlcihtZWFzdXJlLmVuZCAtIG1lYXN1cmUuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHJlcG9ydFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ0R1cmF0aW9uJzogYCR7KGRpZmYgLyAxZTkpLnRvRml4ZWQoMyl9IHNgLFxuICAgICAgICAgICAgICAgICAgICAnUGVyY2VudGFnZSc6IGAkeygoZGlmZiAvIHRvdGFsKSAqIDEwMCkudG9GaXhlZCgyKX0gJWBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAnRHVyYXRpb24nOiAnTi9BJyxcbiAgICAgICAgICAgICAgICAgICAgJ1BlcmNlbnRhZ2UnOiAnTi9BJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coYFBlcmZvcm1hbmNlIHJlcG9ydCAoJHt0aXRsZX0pOmAsICh0b3RhbCAvIDFlOSkudG9GaXhlZCgzKSwgJ3MnKTtcbiAgICAgICAgY29uc29sZS50YWJsZShyZXBvcnQsIFsnRHVyYXRpb24nLCAnUGVyY2VudGFnZSddKTtcbiAgICB9XG59XG5leHBvcnRzLlBlcmZvcm1hbmNlSGVscGVyID0gUGVyZm9ybWFuY2VIZWxwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lVR1Z5Wm05eWJXRnVZMlZJWld4d1pYSXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk5emNtTXZhR1ZzY0dWeUwxQmxjbVp2Y20xaGJtTmxTR1ZzY0dWeUxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPenM3T3p0QlFVRkJMRFJEUVVGdFFqdEJRVVZ1UWl3MlEwRkJlVU03UVVGRGVrTXNlVVJCUVhGRU8wRkJWWEpFTEUxQlFVMHNNa0pCUVRKQ0xFZEJRVWNzVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXl4dFEwRkJiVU1zUzBGQlN5eFRRVUZUTEVOQlFVRTdRVUZGYWtjc1RVRkJZU3hwUWtGQmFVSTdTVUZMTjBJN1VVRkRReXhKUVVGSkxFTkJRVU1zVTBGQlV5eEhRVUZITEVsQlFVa3NSMEZCUnl4RlFVRm5ReXhEUVVGQk8xRkJRM2hFTEVsQlFVa3NRMEZCUXl4aFFVRmhMRWRCUVVjc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQmRVSXNRMEZCUVR0UlFVTndSQ3hKUVVGSkxFTkJRVU1zV1VGQldTeEhRVUZITEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVhWQ0xFTkJRVUU3U1VGRGNFUXNRMEZCUXp0SlFVVkVMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zU1VGQmFVSTdVVUZEY0VNc1NVRkJTU3haUVVGRkxFTkJRVU1zVlVGQlZTeERRVUZETEVsQlFVa3NRMEZCUXl4blFrRkJaMElzUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXp0WlFVTTFReXhOUVVGTkxGVkJRVlVzUjBGQlJ5eFpRVUZGTEVOQlFVTXNXVUZCV1N4RFFVRkRMRWxCUVVrc1EwRkJReXhuUWtGQlowSXNSVUZCUlN4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZCTzFsQlF6bEZMRTlCUVU4c1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFZRVUZWTEVOQlFYVkNMRU5CUVVFN1VVRkRjRVFzUTBGQlF6dFJRVU5FTEU5QlFVOHNSVUZCUlN4UlFVRlJMRVZCUVVVc1JVRkJSU3hGUVVGRkxFTkJRVUU3U1VGRGVFSXNRMEZCUXp0SlFVVkVMRTFCUVUwc1EwRkJReXhYUVVGWExFTkJRVU1zU1VGQmFVSXNSVUZCUlN4SlFVRjNRanRSUVVNM1JDeE5RVUZOTEVkQlFVY3NSMEZCUnl4SlFVRkpMRU5CUVVNc1QwRkJUeXhGUVVGRkxFTkJRVUU3VVVGRE1VSXNTVUZCU1N4RFFVRkRMRmxCUVVVc1EwRkJReXhWUVVGVkxFTkJRVU1zUjBGQlJ5eERRVUZETEdkQ1FVRm5RaXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETzFsQlF6VkRMRzFEUVVGblFpeERRVUZETEd0RFFVRnJReXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZCTzFGQlEzcEVMRU5CUVVNN1VVRkRSQ3haUVVGRkxFTkJRVU1zWVVGQllTeERRVUZETEVsQlFVa3NRMEZCUXl4blFrRkJaMElzUlVGQlJTeEZRVUZGTEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hGUVVGRkxFbEJRVWtzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkJPMGxCUTNwRkxFTkJRVU03U1VGRlJDeFpRVUZaTEVOQlFVTXNTVUZCYVVJN1VVRkROMElzU1VGQlNTeERRVUZETERKQ1FVRXlRaXhGUVVGRkxFTkJRVU03V1VGRGJFTXNUMEZCVFR0UlFVTlFMRU5CUVVNN1VVRkRSQ3hOUVVGTkxFMUJRVTBzUjBGQlJ5eHBRa0ZCYVVJc1EwRkJReXhaUVVGWkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVRTdVVUZGYmtRc1MwRkJTeXhOUVVGTkxFTkJRVU1zU1VGQlNTeEZRVUZGTEU5QlFVOHNRMEZCUXl4SlFVRkpMRWxCUVVrc1EwRkJReXhUUVVGVExFVkJRVVVzUTBGQlF6dFpRVU01UXl4SlFVRkpMRTlCUVU4c1EwRkJReXhIUVVGSExFVkJRVVVzUTBGQlF6dG5Ra0ZEYWtJc1RVRkJUU3hKUVVGSkxFZEJRVWNzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMRWRCUVVjc1QwRkJUeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZCTzJkQ1FVTm9SQ3hOUVVGTkxFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVUU3V1VGRE5VUXNRMEZCUXp0UlFVTkdMRU5CUVVNN1VVRkRSQ3hwUWtGQmFVSXNRMEZCUXl4WFFVRlhMRU5CUVVNc1NVRkJTU3hGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZCTzBsQlF6VkRMRU5CUVVNN1NVRkZSQ3hMUVVGTExFTkJRVU1zU1VGQldUdFJRVU5xUWl4SlFVRkpMRU5CUVVNc01rSkJRVEpDTEVWQlFVVXNRMEZCUXp0WlFVTnNReXhQUVVGTk8xRkJRMUFzUTBGQlF6dFJRVU5FTEUxQlFVMHNTVUZCU1N4SFFVRkhMSFZDUVVGVkxFTkJRVU1zTkVKQlFUUkNMRVZCUVVVc1EwRkJRVHRSUVVOMFJDeEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMR0ZCUVdFc1JVRkJSU3hEUVVGRE8xbEJRM3BDTEVsQlFVa3NRMEZCUXl4aFFVRmhMRWRCUVVjc1NVRkJTU3hEUVVGQk8xRkJRekZDTEVOQlFVTTdVVUZEUkN4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFZEJRVWNzUTBGQlF5eEpRVUZKTEVWQlFVVTdXVUZEZUVJc1MwRkJTeXhGUVVGRkxFbEJRVWs3V1VGRFdDeEhRVUZITEVWQlFVVXNTVUZCU1R0VFFVTlVMRU5CUVVNc1EwRkJRVHRKUVVOSUxFTkJRVU03U1VGRlJDeEpRVUZKTEVOQlFVTXNTVUZCV1R0UlFVTm9RaXhKUVVGSkxFTkJRVU1zTWtKQlFUSkNMRVZCUVVVc1EwRkJRenRaUVVOc1F5eFBRVUZOTzFGQlExQXNRMEZCUXp0UlFVTkVMRTFCUVUwc1NVRkJTU3hIUVVGSExIVkNRVUZWTEVOQlFVTXNORUpCUVRSQ0xFVkJRVVVzUTBGQlFUdFJRVU4wUkN4SlFVRkpMRU5CUVVNc1dVRkJXU3hIUVVGSExFbEJRVWtzUTBGQlFUdFJRVU40UWl4TlFVRk5MRTlCUVU4c1IwRkJSeXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRVHRSUVVONFF5eEpRVUZKTEU5QlFVOHNSVUZCUlN4RFFVRkRPMWxCUTJJc1QwRkJUeXhEUVVGRExFZEJRVWNzUjBGQlJ5eEpRVUZKTEVOQlFVRTdVVUZEYmtJc1EwRkJRenRKUVVOR0xFTkJRVU03U1VGRlJDeE5RVUZOTEVOQlFVTXNjMEpCUVhOQ0xFTkJRVU1zU1VGQmFVSTdVVUZET1VNc1RVRkJUU3haUVVGWkxFZEJRVWNzYVVKQlFXbENMRU5CUVVNc1dVRkJXU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZCTzFGQlEzcEVMRTlCUVU4c1EwRkJReXhIUVVGSExFTkJRVU1zYVVOQlFXbERMRU5CUVVNc1EwRkJRVHRSUVVNNVF5eE5RVUZOTEUxQlFVMHNSMEZCT0VNc1JVRkJSU3hEUVVGQk8xRkJRelZFTEV0QlFVc3NUVUZCVFN4SlFVRkpMRWxCUVVrc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFpRVUZaTEVOQlFVTXNVVUZCVVN4RFFVRkRMRVZCUVVVc1EwRkJRenRaUVVOMlJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjN1owSkJRMlFzVlVGQlZTeEZRVUZGTEVkQlFVY3NRMEZCUXl4WlFVRlpMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNUdGhRVU5xUlN4RFFVRkJPMUZCUTBZc1EwRkJRenRSUVVWRUxFOUJRVThzUTBGQlF5eExRVUZMTEVOQlFVTXNUVUZCVFN4RlFVRkZMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlFUdEpRVU53UXl4RFFVRkRPMGxCUlVRc1YwRkJWeXhEUVVGRExFdEJRV0U3VVVGRGVFSXNTVUZCU1N4RFFVRkRMREpDUVVFeVFpeEZRVUZGTEVOQlFVTTdXVUZEYkVNc1QwRkJUVHRSUVVOUUxFTkJRVU03VVVGRFJDeE5RVUZOTEUxQlFVMHNSMEZIVGl4RlFVRkZMRU5CUVVFN1VVRkRVaXhOUVVGTkxFdEJRVXNzUjBGQlJ5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRmxCUVZrc1IwRkJSeXhKUVVGSkxFTkJRVU1zWVVGQllTeERRVUZETEVOQlFVRTdVVUZETlVRc1MwRkJTeXhOUVVGTkxFTkJRVU1zU1VGQlNTeEZRVUZGTEU5QlFVOHNRMEZCUXl4SlFVRkpMRWxCUVVrc1EwRkJReXhUUVVGVExFVkJRVVVzUTBGQlF6dFpRVU01UXl4SlFVRkpMRTlCUVU4c1EwRkJReXhIUVVGSExFVkJRVVVzUTBGQlF6dG5Ra0ZEYWtJc1RVRkJUU3hKUVVGSkxFZEJRVWNzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMRWRCUVVjc1QwRkJUeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZCTzJkQ1FVTm9SQ3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVYzdiMEpCUTJRc1ZVRkJWU3hGUVVGRkxFZEJRVWtzUTBGQlF5eEpRVUZKTEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlJTeEpRVUZKTzI5Q1FVTTFReXhaUVVGWkxFVkJRVVVzUjBGQlNTeERRVUZETEVOQlFVTXNTVUZCU1N4SFFVRkhMRXRCUVVzc1EwRkJReXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVVc1NVRkJTVHRwUWtGRGVFUXNRMEZCUVR0WlFVTkdMRU5CUVVNN2FVSkJRVTBzUTBGQlF6dG5Ra0ZEVUN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWM3YjBKQlEyUXNWVUZCVlN4RlFVRkZMRXRCUVVzN2IwSkJRMnBDTEZsQlFWa3NSVUZCUlN4TFFVRkxPMmxDUVVOdVFpeERRVUZCTzFsQlEwWXNRMEZCUXp0UlFVTkdMRU5CUVVNN1VVRkRSQ3hQUVVGUExFTkJRVU1zUjBGQlJ5eERRVUZETEhWQ1FVRjFRaXhMUVVGTExFbEJRVWtzUlVGQlJTeERRVUZETEV0QlFVc3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVFN1VVRkROVVVzVDBGQlR5eERRVUZETEV0QlFVc3NRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhWUVVGVkxFVkJRVVVzV1VGQldTeERRVUZETEVOQlFVTXNRMEZCUVR0SlFVTnNSQ3hEUVVGRE8wTkJRMFE3UVVFelIwUXNPRU5CTWtkREluMD0iXX0=",
    "761": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {\n    if (k2 === undefined)\n        k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = { enumerable: true, get: function () { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function (o, m, k, k2) {\n    if (k2 === undefined)\n        k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function (o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule)\n        return mod;\n    var result = {};\n    if (mod != null)\n        for (var k in mod)\n            if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k))\n                __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProfilerConfig = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst BaseModel_1 = require(\"./BaseModel\");\nconst config_1 = require(\"../constants/config\");\nconst PathUtils_1 = require(\"../helper/PathUtils\");\nconst UnifiedPath_1 = require(\"../system/UnifiedPath\");\nconst Crypto_1 = require(\"../system/Crypto\");\nconst PermissionHelper_1 = require(\"../helper/PermissionHelper\");\n// Types\nconst types_1 = require(\"../types\");\nclass ProfilerConfig extends BaseModel_1.BaseModel {\n    constructor(filePath, config) {\n        super();\n        this.filePath = filePath;\n        this.extends = config.extends;\n        this.registryOptions = config.registryOptions;\n        this.exportOptions = config.exportOptions;\n        this.projectOptions = config.projectOptions;\n        this.runtimeOptions = config.runtimeOptions;\n    }\n    static getDefaultConfig() {\n        return new ProfilerConfig(new UnifiedPath_1.UnifiedPath(process.cwd()).join(config_1.STATIC_CONFIG_FILENAME), config_1.DEFAULT_PROFILER_CONFIG);\n    }\n    getAnonymizedRuntimeOptions() {\n        if (this.runtimeOptions.sensorInterface) {\n            switch (this.runtimeOptions.sensorInterface.type) {\n                case types_1.SensorInterfaceType.windows:\n                    return Object.assign(Object.assign({}, this.runtimeOptions), { sensorInterface: {\n                            type: types_1.SensorInterfaceType.windows,\n                            options: {\n                                sampleInterval: this.runtimeOptions.sensorInterface.options.sampleInterval,\n                                outputFilePath: '<anonymized>'\n                            }\n                        } });\n                case types_1.SensorInterfaceType.perf:\n                    return Object.assign(Object.assign({}, this.runtimeOptions), { sensorInterface: {\n                            type: types_1.SensorInterfaceType.perf,\n                            options: {\n                                sampleInterval: this.runtimeOptions.sensorInterface.options.sampleInterval,\n                                outputFilePath: '<anonymized>'\n                            }\n                        } });\n                case types_1.SensorInterfaceType.powermetrics:\n                    return Object.assign(Object.assign({}, this.runtimeOptions), { sensorInterface: {\n                            type: types_1.SensorInterfaceType.powermetrics,\n                            options: {\n                                sampleInterval: this.runtimeOptions.sensorInterface.options.sampleInterval,\n                                outputFilePath: '<anonymized>'\n                            }\n                        } });\n            }\n        }\n        return this.runtimeOptions;\n    }\n    getV8CPUSamplingInterval() {\n        return this.runtimeOptions.v8.cpu.sampleInterval;\n    }\n    getRegistryUploadUrl() {\n        return `http://${this.registryOptions.url}/upload`;\n    }\n    uploadEnabled() {\n        var _a, _b;\n        return (((_a = this.registryOptions) === null || _a === void 0 ? void 0 : _a.url) !== undefined) && ((_b = this.registryOptions) === null || _b === void 0 ? void 0 : _b.url) !== '';\n    }\n    getProjectIdentifier() {\n        if (!Crypto_1.Crypto.validateUniqueID(this.projectOptions.identifier)) {\n            throw new Error('ProfilerConfig.getProjectIdentifier: identifier should be an uuid4');\n        }\n        return this.projectOptions.identifier;\n    }\n    getRootDir() {\n        if (PathUtils_1.PathUtils.isAbsolute(this.exportOptions.rootDir)) {\n            return new UnifiedPath_1.UnifiedPath(this.exportOptions.rootDir);\n        }\n        return this.filePath.dirName().join(this.exportOptions.rootDir);\n    }\n    getOutDir() {\n        if (PathUtils_1.PathUtils.isAbsolute(this.exportOptions.outDir)) {\n            return new UnifiedPath_1.UnifiedPath(this.exportOptions.outDir);\n        }\n        return this.filePath.dirName().join(this.exportOptions.outDir);\n    }\n    getOutHistoryDir() {\n        if (PathUtils_1.PathUtils.isAbsolute(this.exportOptions.outHistoryDir)) {\n            return new UnifiedPath_1.UnifiedPath(this.exportOptions.outHistoryDir);\n        }\n        return this.filePath.dirName().join(this.exportOptions.outHistoryDir);\n    }\n    getSensorInterfaceType() {\n        var _a;\n        return (_a = this.runtimeOptions.sensorInterface) === null || _a === void 0 ? void 0 : _a.type;\n    }\n    getSensorInterfaceOptions() {\n        var _a;\n        return (_a = this.runtimeOptions.sensorInterface) === null || _a === void 0 ? void 0 : _a.options;\n    }\n    shouldExportV8Profile() {\n        return this.exportOptions.exportV8Profile;\n    }\n    shouldExportReport() {\n        return this.exportOptions.exportReport;\n    }\n    shouldExportSensorInterfaceData() {\n        return this.exportOptions.exportSensorInterfaceData;\n    }\n    getSeedForMathRandom() {\n        return this.runtimeOptions.seeds['Math.random'];\n    }\n    configAsExtended(pathDiff) {\n        const exportOptions = this.exportOptions;\n        if (exportOptions) {\n            if (exportOptions.outDir && !PathUtils_1.PathUtils.isAbsolute(exportOptions.outDir)) {\n                exportOptions.outDir = pathDiff.join(exportOptions.outDir).toString();\n            }\n            if (exportOptions.outHistoryDir && !PathUtils_1.PathUtils.isAbsolute(exportOptions.outHistoryDir)) {\n                exportOptions.outHistoryDir = pathDiff.join(exportOptions.outHistoryDir).toString();\n            }\n            if (exportOptions.rootDir && !PathUtils_1.PathUtils.isAbsolute(exportOptions.rootDir)) {\n                exportOptions.rootDir = pathDiff.join(exportOptions.rootDir).toString();\n            }\n        }\n        return {\n            exportOptions: exportOptions,\n            projectOptions: this.projectOptions,\n            runtimeOptions: this.runtimeOptions,\n            registryOptions: this.registryOptions\n        };\n    }\n    /**\n     * Fills unspecified values of the config with values of the given config\n     *\n     * example usage:\n     * - every config that gets resolved inherits values of the default config (baseConfig)\n     * \t\tto ensure that unspecified values are filled with the default value. This happens via:\n     * \t\tconfig.implement(baseConfig):\n     *\n     * - if a config contains the extends keyword like this:\n     * \t\t{\n     * \t \t\t\"extends\": \"<config that gets extended>\"\n     * \t\t}\n     * \t\tthe config gets extended via:\n     * \t\tconfig.implement(<config that gets extended>):\n     *\n     * it also adjusts the inherited path values values to make them relative to the config\n     *\n     *\n     * @param config to inherit from\n     */\n    implement(config) {\n        var _a, _b, _c, _d, _e, _f;\n        const pathDiff = this.filePath.dirName().pathTo(config.filePath.dirName());\n        const configToExtend = config.configAsExtended(pathDiff);\n        const newExportOptions = Object.assign(Object.assign({}, configToExtend.exportOptions), this.exportOptions);\n        const newProjectOptions = Object.assign(Object.assign({}, configToExtend.projectOptions), this.projectOptions);\n        const newRuntimeOptions = Object.assign(Object.assign(Object.assign({}, configToExtend.runtimeOptions), this.runtimeOptions), { seeds: Object.assign(Object.assign({}, (((_a = configToExtend === null || configToExtend === void 0 ? void 0 : configToExtend.runtimeOptions) === null || _a === void 0 ? void 0 : _a.seeds) || {})), (((_b = this.runtimeOptions) === null || _b === void 0 ? void 0 : _b.seeds) || {})), v8: {\n                cpu: Object.assign(Object.assign({}, (((_d = (_c = configToExtend.runtimeOptions) === null || _c === void 0 ? void 0 : _c.v8) === null || _d === void 0 ? void 0 : _d.cpu) || {})), (((_f = (_e = this.runtimeOptions) === null || _e === void 0 ? void 0 : _e.v8) === null || _f === void 0 ? void 0 : _f.cpu) || {}))\n            } });\n        const newRegistryOptions = Object.assign(Object.assign({}, configToExtend.registryOptions), this.registryOptions);\n        this.exportOptions = newExportOptions;\n        this.projectOptions = newProjectOptions;\n        this.runtimeOptions = newRuntimeOptions;\n        this.registryOptions = newRegistryOptions;\n    }\n    static fromJSON(json) {\n        let data;\n        if (typeof json === 'string') {\n            data = JSON.parse(json);\n        }\n        else {\n            data = json;\n        }\n        if (data.projectOptions === undefined ||\n            data.projectOptions.identifier === undefined) {\n            throw new Error('ProfilerConfig: the project has no identifier yet');\n        }\n        if (!Crypto_1.Crypto.validateUniqueID(data.projectOptions.identifier)) {\n            throw new Error('ProfilerConfig.getProjectIdentifier: Loaded identifier from the config should be an uuid4');\n        }\n        return new ProfilerConfig(new UnifiedPath_1.UnifiedPath(''), {\n            extends: data.extends,\n            exportOptions: data.exportOptions,\n            projectOptions: data.projectOptions,\n            runtimeOptions: data.runtimeOptions,\n            registryOptions: data.registryOptions\n        });\n    }\n    toJSON() {\n        return ({\n            extends: this.extends,\n            exportOptions: this.exportOptions,\n            projectOptions: this.projectOptions,\n            runtimeOptions: this.runtimeOptions,\n            registryOptions: this.registryOptions\n        });\n    }\n    storeToFile(filePath) {\n        if (!fs.existsSync(filePath.dirName().toPlatformString())) {\n            PermissionHelper_1.PermissionHelper.mkdirRecursivelyWithUserPermission(filePath.dirName().toPlatformString());\n        }\n        PermissionHelper_1.PermissionHelper.writeFileWithUserPermission(filePath.toPlatformString(), JSON.stringify(this, null, 2));\n    }\n    // loads a config from a given file path and extends it\n    // this method is NOT used to ensure load a valid (complete) config, use resolveFromFile to achieve that\n    static loadFromFile(filePath) {\n        if (!fs.existsSync(filePath.toPlatformString())) {\n            return undefined;\n        }\n        const loadedConfig = ProfilerConfig.fromJSON(fs.readFileSync(filePath.toPlatformString()).toString());\n        loadedConfig.filePath = filePath;\n        if (loadedConfig.extends) {\n            const configToExtendFilePath = filePath.dirName().join(loadedConfig.extends);\n            const configToExtend = ProfilerConfig.loadFromFile(configToExtendFilePath);\n            if (configToExtend) {\n                loadedConfig.implement(configToExtend);\n                return loadedConfig;\n            }\n        }\n        return loadedConfig;\n    }\n    // loads a config from a given file path and fills all non defined values with the resp. default values\n    static resolveFromFile(filePath) {\n        const baseConfig = ProfilerConfig.getDefaultConfig();\n        if (!filePath) {\n            return baseConfig;\n        }\n        const config = this.loadFromFile(filePath);\n        if (config) {\n            baseConfig.filePath = config.filePath;\n            config.implement(baseConfig);\n            return config;\n        }\n        return baseConfig;\n    }\n    static autoResolveFromPath(startDir) {\n        // Searches from the given path upwards until it finds the config file\n        const configFilePath = PathUtils_1.PathUtils.findUp(config_1.STATIC_CONFIG_FILENAME, startDir.toPlatformString());\n        if (!configFilePath) {\n            return ProfilerConfig.resolveFromFile(undefined);\n        }\n        return ProfilerConfig.resolveFromFile(new UnifiedPath_1.UnifiedPath(configFilePath));\n    }\n    static autoResolve() {\n        // Searches from the processes execution path upwards until it finds the config file\n        return this.autoResolveFromPath(new UnifiedPath_1.UnifiedPath(process.cwd()));\n    }\n}\nexports.ProfilerConfig = ProfilerConfig;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2theW1ha293c2t5L0RvY3VtZW50cy9IaXRhYmlzL0N1cnJlbnQtV29ya3NwYWNlcy9HcmVlbklUL09ha2xlYW4vcGFja2FnZXMvcHJvZmlsZXItY29yZS9kaXN0L3NyYy9tb2RlbC9Qcm9maWxlckNvbmZpZy5qcyIsInNvdXJjZXMiOlsiL1VzZXJzL2theW1ha293c2t5L0RvY3VtZW50cy9IaXRhYmlzL0N1cnJlbnQtV29ya3NwYWNlcy9HcmVlbklUL09ha2xlYW4vcGFja2FnZXMvcHJvZmlsZXItY29yZS9kaXN0L3NyYy9tb2RlbC9Qcm9maWxlckNvbmZpZy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxZQUFZLENBQUM7QUFDYixJQUFJLGVBQWUsR0FBRyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtJQUMxRixJQUFJLEVBQUUsS0FBSyxTQUFTO1FBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUM3QixJQUFJLElBQUksR0FBRyxNQUFNLENBQUMsd0JBQXdCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2pELElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUM7UUFDbEYsSUFBSSxHQUFHLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsY0FBYSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQ2hFLENBQUM7SUFDRCxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsSUFB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QUMsRUFBRSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxJQUFJLElBQUksRUFBRSxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFO2dCQUN2WixHQUFHLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEdBQUcsY0FBYyxDQUFDLGNBQWMsQ0FBQyxLQUFLLElBQUksSUFBSSxFQUFFLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEtBQUssSUFBSSxJQUFJLEVBQUUsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssSUFBSSxJQUFJLEVBQUUsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsS0FBSyxJQUFJLElBQUksRUFBRSxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO2FBQzFULEVBQUUsQ0FBQyxDQUFDO1FBQ1QsTUFBTSxrQkFBa0IsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLGNBQWMsQ0FBQyxlQUFlLENBQUMsRUFBRSxJQUFJLENB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ckQsQ0FBQztRQUNELE9BQU8sY0FBYyxDQUFDLGVBQWUsQ0FBQyxJQUFJLGFBQWEsQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztJQUN6RixDQUFDO0lBQ0QsTUFBTSxDQUFDLFdBQVc7UUFDZCxvRkFBb0Y7UUFDcEYsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxhQUFhLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbEYsQ0FBQztDQUNKO0FBQ0QsT0FBTyxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm9maWxlckNvbmZpZyA9IHZvaWQgMDtcbmNvbnN0IGZzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJmc1wiKSk7XG5jb25zdCBCYXNlTW9kZWxfMSA9IHJlcXVpcmUoXCIuL0Jhc2VNb2RlbFwiKTtcbmNvbnN0IGNvbmZpZ18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy9jb25maWdcIik7XG5jb25zdCBQYXRoVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvUGF0aFV0aWxzXCIpO1xuY29uc3QgVW5pZmllZFBhdGhfMSA9IHJlcXVpcmUoXCIuLi9zeXN0ZW0vVW5pZmllZFBhdGhcIik7XG5jb25zdCBDcnlwdG9fMSA9IHJlcXVpcmUoXCIuLi9zeXN0ZW0vQ3J5cHRvXCIpO1xuY29uc3QgUGVybWlzc2lvbkhlbHBlcl8xID0gcmVxdWlyZShcIi4uL2hlbHBlci9QZXJtaXNzaW9uSGVscGVyXCIpO1xuLy8gVHlwZXNcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5jbGFzcyBQcm9maWxlckNvbmZpZyBleHRlbmRzIEJhc2VNb2RlbF8xLkJhc2VNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoZmlsZVBhdGgsIGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbGVQYXRoID0gZmlsZVBhdGg7XG4gICAgICAgIHRoaXMuZXh0ZW5kcyA9IGNvbmZpZy5leHRlbmRzO1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5T3B0aW9ucyA9IGNvbmZpZy5yZWdpc3RyeU9wdGlvbnM7XG4gICAgICAgIHRoaXMuZXhwb3J0T3B0aW9ucyA9IGNvbmZpZy5leHBvcnRPcHRpb25zO1xuICAgICAgICB0aGlzLnByb2plY3RPcHRpb25zID0gY29uZmlnLnByb2plY3RPcHRpb25zO1xuICAgICAgICB0aGlzLnJ1bnRpbWVPcHRpb25zID0gY29uZmlnLnJ1bnRpbWVPcHRpb25zO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdENvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9maWxlckNvbmZpZyhuZXcgVW5pZmllZFBhdGhfMS5VbmlmaWVkUGF0aChwcm9jZXNzLmN3ZCgpKS5qb2luKGNvbmZpZ18xLlNUQVRJQ19DT05GSUdfRklMRU5BTUUpLCBjb25maWdfMS5ERUZBVUxUX1BST0ZJTEVSX0NPTkZJRyk7XG4gICAgfVxuICAgIGdldEFub255bWl6ZWRSdW50aW1lT3B0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMucnVudGltZU9wdGlvbnMuc2Vuc29ySW50ZXJmYWNlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucnVudGltZU9wdGlvbnMuc2Vuc29ySW50ZXJmYWNlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuU2Vuc29ySW50ZXJmYWNlVHlwZS53aW5kb3dzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJ1bnRpbWVPcHRpb25zKSwgeyBzZW5zb3JJbnRlcmZhY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlc18xLlNlbnNvckludGVyZmFjZVR5cGUud2luZG93cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUludGVydmFsOiB0aGlzLnJ1bnRpbWVPcHRpb25zLnNlbnNvckludGVyZmFjZS5vcHRpb25zLnNhbXBsZUludGVydmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRGaWxlUGF0aDogJzxhbm9ueW1pemVkPidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5TZW5zb3JJbnRlcmZhY2VUeXBlLnBlcmY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucnVudGltZU9wdGlvbnMpLCB7IHNlbnNvckludGVyZmFjZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVzXzEuU2Vuc29ySW50ZXJmYWNlVHlwZS5wZXJmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlSW50ZXJ2YWw6IHRoaXMucnVudGltZU9wdGlvbnMuc2Vuc29ySW50ZXJmYWNlLm9wdGlvbnMuc2FtcGxlSW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEZpbGVQYXRoOiAnPGFub255bWl6ZWQ+J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLlNlbnNvckludGVyZmFjZVR5cGUucG93ZXJtZXRyaWNzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJ1bnRpbWVPcHRpb25zKSwgeyBzZW5zb3JJbnRlcmZhY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlc18xLlNlbnNvckludGVyZmFjZVR5cGUucG93ZXJtZXRyaWNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlSW50ZXJ2YWw6IHRoaXMucnVudGltZU9wdGlvbnMuc2Vuc29ySW50ZXJmYWNlLm9wdGlvbnMuc2FtcGxlSW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEZpbGVQYXRoOiAnPGFub255bWl6ZWQ+J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucnVudGltZU9wdGlvbnM7XG4gICAgfVxuICAgIGdldFY4Q1BVU2FtcGxpbmdJbnRlcnZhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVudGltZU9wdGlvbnMudjguY3B1LnNhbXBsZUludGVydmFsO1xuICAgIH1cbiAgICBnZXRSZWdpc3RyeVVwbG9hZFVybCgpIHtcbiAgICAgICAgcmV0dXJuIGBodHRwOi8vJHt0aGlzLnJlZ2lzdHJ5T3B0aW9ucy51cmx9L3VwbG9hZGA7XG4gICAgfVxuICAgIHVwbG9hZEVuYWJsZWQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoKChfYSA9IHRoaXMucmVnaXN0cnlPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXJsKSAhPT0gdW5kZWZpbmVkKSAmJiAoKF9iID0gdGhpcy5yZWdpc3RyeU9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi51cmwpICE9PSAnJztcbiAgICB9XG4gICAgZ2V0UHJvamVjdElkZW50aWZpZXIoKSB7XG4gICAgICAgIGlmICghQ3J5cHRvXzEuQ3J5cHRvLnZhbGlkYXRlVW5pcXVlSUQodGhpcy5wcm9qZWN0T3B0aW9ucy5pZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9maWxlckNvbmZpZy5nZXRQcm9qZWN0SWRlbnRpZmllcjogaWRlbnRpZmllciBzaG91bGQgYmUgYW4gdXVpZDQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0T3B0aW9ucy5pZGVudGlmaWVyO1xuICAgIH1cbiAgICBnZXRSb290RGlyKCkge1xuICAgICAgICBpZiAoUGF0aFV0aWxzXzEuUGF0aFV0aWxzLmlzQWJzb2x1dGUodGhpcy5leHBvcnRPcHRpb25zLnJvb3REaXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVuaWZpZWRQYXRoXzEuVW5pZmllZFBhdGgodGhpcy5leHBvcnRPcHRpb25zLnJvb3REaXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVQYXRoLmRpck5hbWUoKS5qb2luKHRoaXMuZXhwb3J0T3B0aW9ucy5yb290RGlyKTtcbiAgICB9XG4gICAgZ2V0T3V0RGlyKCkge1xuICAgICAgICBpZiAoUGF0aFV0aWxzXzEuUGF0aFV0aWxzLmlzQWJzb2x1dGUodGhpcy5leHBvcnRPcHRpb25zLm91dERpcikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5pZmllZFBhdGhfMS5VbmlmaWVkUGF0aCh0aGlzLmV4cG9ydE9wdGlvbnMub3V0RGlyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maWxlUGF0aC5kaXJOYW1lKCkuam9pbih0aGlzLmV4cG9ydE9wdGlvbnMub3V0RGlyKTtcbiAgICB9XG4gICAgZ2V0T3V0SGlzdG9yeURpcigpIHtcbiAgICAgICAgaWYgKFBhdGhVdGlsc18xLlBhdGhVdGlscy5pc0Fic29sdXRlKHRoaXMuZXhwb3J0T3B0aW9ucy5vdXRIaXN0b3J5RGlyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmlmaWVkUGF0aF8xLlVuaWZpZWRQYXRoKHRoaXMuZXhwb3J0T3B0aW9ucy5vdXRIaXN0b3J5RGlyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maWxlUGF0aC5kaXJOYW1lKCkuam9pbih0aGlzLmV4cG9ydE9wdGlvbnMub3V0SGlzdG9yeURpcik7XG4gICAgfVxuICAgIGdldFNlbnNvckludGVyZmFjZVR5cGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMucnVudGltZU9wdGlvbnMuc2Vuc29ySW50ZXJmYWNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZTtcbiAgICB9XG4gICAgZ2V0U2Vuc29ySW50ZXJmYWNlT3B0aW9ucygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5ydW50aW1lT3B0aW9ucy5zZW5zb3JJbnRlcmZhY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpb25zO1xuICAgIH1cbiAgICBzaG91bGRFeHBvcnRWOFByb2ZpbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cG9ydE9wdGlvbnMuZXhwb3J0VjhQcm9maWxlO1xuICAgIH1cbiAgICBzaG91bGRFeHBvcnRSZXBvcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cG9ydE9wdGlvbnMuZXhwb3J0UmVwb3J0O1xuICAgIH1cbiAgICBzaG91bGRFeHBvcnRTZW5zb3JJbnRlcmZhY2VEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBvcnRPcHRpb25zLmV4cG9ydFNlbnNvckludGVyZmFjZURhdGE7XG4gICAgfVxuICAgIGdldFNlZWRGb3JNYXRoUmFuZG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW50aW1lT3B0aW9ucy5zZWVkc1snTWF0aC5yYW5kb20nXTtcbiAgICB9XG4gICAgY29uZmlnQXNFeHRlbmRlZChwYXRoRGlmZikge1xuICAgICAgICBjb25zdCBleHBvcnRPcHRpb25zID0gdGhpcy5leHBvcnRPcHRpb25zO1xuICAgICAgICBpZiAoZXhwb3J0T3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGV4cG9ydE9wdGlvbnMub3V0RGlyICYmICFQYXRoVXRpbHNfMS5QYXRoVXRpbHMuaXNBYnNvbHV0ZShleHBvcnRPcHRpb25zLm91dERpcikpIHtcbiAgICAgICAgICAgICAgICBleHBvcnRPcHRpb25zLm91dERpciA9IHBhdGhEaWZmLmpvaW4oZXhwb3J0T3B0aW9ucy5vdXREaXIpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwb3J0T3B0aW9ucy5vdXRIaXN0b3J5RGlyICYmICFQYXRoVXRpbHNfMS5QYXRoVXRpbHMuaXNBYnNvbHV0ZShleHBvcnRPcHRpb25zLm91dEhpc3RvcnlEaXIpKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0T3B0aW9ucy5vdXRIaXN0b3J5RGlyID0gcGF0aERpZmYuam9pbihleHBvcnRPcHRpb25zLm91dEhpc3RvcnlEaXIpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwb3J0T3B0aW9ucy5yb290RGlyICYmICFQYXRoVXRpbHNfMS5QYXRoVXRpbHMuaXNBYnNvbHV0ZShleHBvcnRPcHRpb25zLnJvb3REaXIpKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0T3B0aW9ucy5yb290RGlyID0gcGF0aERpZmYuam9pbihleHBvcnRPcHRpb25zLnJvb3REaXIpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4cG9ydE9wdGlvbnM6IGV4cG9ydE9wdGlvbnMsXG4gICAgICAgICAgICBwcm9qZWN0T3B0aW9uczogdGhpcy5wcm9qZWN0T3B0aW9ucyxcbiAgICAgICAgICAgIHJ1bnRpbWVPcHRpb25zOiB0aGlzLnJ1bnRpbWVPcHRpb25zLFxuICAgICAgICAgICAgcmVnaXN0cnlPcHRpb25zOiB0aGlzLnJlZ2lzdHJ5T3B0aW9uc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaWxscyB1bnNwZWNpZmllZCB2YWx1ZXMgb2YgdGhlIGNvbmZpZyB3aXRoIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gY29uZmlnXG4gICAgICpcbiAgICAgKiBleGFtcGxlIHVzYWdlOlxuICAgICAqIC0gZXZlcnkgY29uZmlnIHRoYXQgZ2V0cyByZXNvbHZlZCBpbmhlcml0cyB2YWx1ZXMgb2YgdGhlIGRlZmF1bHQgY29uZmlnIChiYXNlQ29uZmlnKVxuICAgICAqIFx0XHR0byBlbnN1cmUgdGhhdCB1bnNwZWNpZmllZCB2YWx1ZXMgYXJlIGZpbGxlZCB3aXRoIHRoZSBkZWZhdWx0IHZhbHVlLiBUaGlzIGhhcHBlbnMgdmlhOlxuICAgICAqIFx0XHRjb25maWcuaW1wbGVtZW50KGJhc2VDb25maWcpOlxuICAgICAqXG4gICAgICogLSBpZiBhIGNvbmZpZyBjb250YWlucyB0aGUgZXh0ZW5kcyBrZXl3b3JkIGxpa2UgdGhpczpcbiAgICAgKiBcdFx0e1xuICAgICAqIFx0IFx0XHRcImV4dGVuZHNcIjogXCI8Y29uZmlnIHRoYXQgZ2V0cyBleHRlbmRlZD5cIlxuICAgICAqIFx0XHR9XG4gICAgICogXHRcdHRoZSBjb25maWcgZ2V0cyBleHRlbmRlZCB2aWE6XG4gICAgICogXHRcdGNvbmZpZy5pbXBsZW1lbnQoPGNvbmZpZyB0aGF0IGdldHMgZXh0ZW5kZWQ+KTpcbiAgICAgKlxuICAgICAqIGl0IGFsc28gYWRqdXN0cyB0aGUgaW5oZXJpdGVkIHBhdGggdmFsdWVzIHZhbHVlcyB0byBtYWtlIHRoZW0gcmVsYXRpdmUgdG8gdGhlIGNvbmZpZ1xuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIHRvIGluaGVyaXQgZnJvbVxuICAgICAqL1xuICAgIGltcGxlbWVudChjb25maWcpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGNvbnN0IHBhdGhEaWZmID0gdGhpcy5maWxlUGF0aC5kaXJOYW1lKCkucGF0aFRvKGNvbmZpZy5maWxlUGF0aC5kaXJOYW1lKCkpO1xuICAgICAgICBjb25zdCBjb25maWdUb0V4dGVuZCA9IGNvbmZpZy5jb25maWdBc0V4dGVuZGVkKHBhdGhEaWZmKTtcbiAgICAgICAgY29uc3QgbmV3RXhwb3J0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnVG9FeHRlbmQuZXhwb3J0T3B0aW9ucyksIHRoaXMuZXhwb3J0T3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG5ld1Byb2plY3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25maWdUb0V4dGVuZC5wcm9qZWN0T3B0aW9ucyksIHRoaXMucHJvamVjdE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBuZXdSdW50aW1lT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25maWdUb0V4dGVuZC5ydW50aW1lT3B0aW9ucyksIHRoaXMucnVudGltZU9wdGlvbnMpLCB7IHNlZWRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgoKF9hID0gY29uZmlnVG9FeHRlbmQgPT09IG51bGwgfHwgY29uZmlnVG9FeHRlbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ1RvRXh0ZW5kLnJ1bnRpbWVPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VlZHMpIHx8IHt9KSksICgoKF9iID0gdGhpcy5ydW50aW1lT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNlZWRzKSB8fCB7fSkpLCB2ODoge1xuICAgICAgICAgICAgICAgIGNwdTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoKChfZCA9IChfYyA9IGNvbmZpZ1RvRXh0ZW5kLnJ1bnRpbWVPcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudjgpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jcHUpIHx8IHt9KSksICgoKF9mID0gKF9lID0gdGhpcy5ydW50aW1lT3B0aW9ucykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnY4KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY3B1KSB8fCB7fSkpXG4gICAgICAgICAgICB9IH0pO1xuICAgICAgICBjb25zdCBuZXdSZWdpc3RyeU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZ1RvRXh0ZW5kLnJlZ2lzdHJ5T3B0aW9ucyksIHRoaXMucmVnaXN0cnlPcHRpb25zKTtcbiAgICAgICAgdGhpcy5leHBvcnRPcHRpb25zID0gbmV3RXhwb3J0T3B0aW9ucztcbiAgICAgICAgdGhpcy5wcm9qZWN0T3B0aW9ucyA9IG5ld1Byb2plY3RPcHRpb25zO1xuICAgICAgICB0aGlzLnJ1bnRpbWVPcHRpb25zID0gbmV3UnVudGltZU9wdGlvbnM7XG4gICAgICAgIHRoaXMucmVnaXN0cnlPcHRpb25zID0gbmV3UmVnaXN0cnlPcHRpb25zO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0ganNvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5wcm9qZWN0T3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBkYXRhLnByb2plY3RPcHRpb25zLmlkZW50aWZpZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9maWxlckNvbmZpZzogdGhlIHByb2plY3QgaGFzIG5vIGlkZW50aWZpZXIgeWV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFDcnlwdG9fMS5DcnlwdG8udmFsaWRhdGVVbmlxdWVJRChkYXRhLnByb2plY3RPcHRpb25zLmlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2ZpbGVyQ29uZmlnLmdldFByb2plY3RJZGVudGlmaWVyOiBMb2FkZWQgaWRlbnRpZmllciBmcm9tIHRoZSBjb25maWcgc2hvdWxkIGJlIGFuIHV1aWQ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9maWxlckNvbmZpZyhuZXcgVW5pZmllZFBhdGhfMS5VbmlmaWVkUGF0aCgnJyksIHtcbiAgICAgICAgICAgIGV4dGVuZHM6IGRhdGEuZXh0ZW5kcyxcbiAgICAgICAgICAgIGV4cG9ydE9wdGlvbnM6IGRhdGEuZXhwb3J0T3B0aW9ucyxcbiAgICAgICAgICAgIHByb2plY3RPcHRpb25zOiBkYXRhLnByb2plY3RPcHRpb25zLFxuICAgICAgICAgICAgcnVudGltZU9wdGlvbnM6IGRhdGEucnVudGltZU9wdGlvbnMsXG4gICAgICAgICAgICByZWdpc3RyeU9wdGlvbnM6IGRhdGEucmVnaXN0cnlPcHRpb25zXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgZXh0ZW5kczogdGhpcy5leHRlbmRzLFxuICAgICAgICAgICAgZXhwb3J0T3B0aW9uczogdGhpcy5leHBvcnRPcHRpb25zLFxuICAgICAgICAgICAgcHJvamVjdE9wdGlvbnM6IHRoaXMucHJvamVjdE9wdGlvbnMsXG4gICAgICAgICAgICBydW50aW1lT3B0aW9uczogdGhpcy5ydW50aW1lT3B0aW9ucyxcbiAgICAgICAgICAgIHJlZ2lzdHJ5T3B0aW9uczogdGhpcy5yZWdpc3RyeU9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3JlVG9GaWxlKGZpbGVQYXRoKSB7XG4gICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhmaWxlUGF0aC5kaXJOYW1lKCkudG9QbGF0Zm9ybVN0cmluZygpKSkge1xuICAgICAgICAgICAgUGVybWlzc2lvbkhlbHBlcl8xLlBlcm1pc3Npb25IZWxwZXIubWtkaXJSZWN1cnNpdmVseVdpdGhVc2VyUGVybWlzc2lvbihmaWxlUGF0aC5kaXJOYW1lKCkudG9QbGF0Zm9ybVN0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBQZXJtaXNzaW9uSGVscGVyXzEuUGVybWlzc2lvbkhlbHBlci53cml0ZUZpbGVXaXRoVXNlclBlcm1pc3Npb24oZmlsZVBhdGgudG9QbGF0Zm9ybVN0cmluZygpLCBKU09OLnN0cmluZ2lmeSh0aGlzLCBudWxsLCAyKSk7XG4gICAgfVxuICAgIC8vIGxvYWRzIGEgY29uZmlnIGZyb20gYSBnaXZlbiBmaWxlIHBhdGggYW5kIGV4dGVuZHMgaXRcbiAgICAvLyB0aGlzIG1ldGhvZCBpcyBOT1QgdXNlZCB0byBlbnN1cmUgbG9hZCBhIHZhbGlkIChjb21wbGV0ZSkgY29uZmlnLCB1c2UgcmVzb2x2ZUZyb21GaWxlIHRvIGFjaGlldmUgdGhhdFxuICAgIHN0YXRpYyBsb2FkRnJvbUZpbGUoZmlsZVBhdGgpIHtcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGZpbGVQYXRoLnRvUGxhdGZvcm1TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9hZGVkQ29uZmlnID0gUHJvZmlsZXJDb25maWcuZnJvbUpTT04oZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLnRvUGxhdGZvcm1TdHJpbmcoKSkudG9TdHJpbmcoKSk7XG4gICAgICAgIGxvYWRlZENvbmZpZy5maWxlUGF0aCA9IGZpbGVQYXRoO1xuICAgICAgICBpZiAobG9hZGVkQ29uZmlnLmV4dGVuZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZ1RvRXh0ZW5kRmlsZVBhdGggPSBmaWxlUGF0aC5kaXJOYW1lKCkuam9pbihsb2FkZWRDb25maWcuZXh0ZW5kcyk7XG4gICAgICAgICAgICBjb25zdCBjb25maWdUb0V4dGVuZCA9IFByb2ZpbGVyQ29uZmlnLmxvYWRGcm9tRmlsZShjb25maWdUb0V4dGVuZEZpbGVQYXRoKTtcbiAgICAgICAgICAgIGlmIChjb25maWdUb0V4dGVuZCkge1xuICAgICAgICAgICAgICAgIGxvYWRlZENvbmZpZy5pbXBsZW1lbnQoY29uZmlnVG9FeHRlbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZWRDb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvYWRlZENvbmZpZztcbiAgICB9XG4gICAgLy8gbG9hZHMgYSBjb25maWcgZnJvbSBhIGdpdmVuIGZpbGUgcGF0aCBhbmQgZmlsbHMgYWxsIG5vbiBkZWZpbmVkIHZhbHVlcyB3aXRoIHRoZSByZXNwLiBkZWZhdWx0IHZhbHVlc1xuICAgIHN0YXRpYyByZXNvbHZlRnJvbUZpbGUoZmlsZVBhdGgpIHtcbiAgICAgICAgY29uc3QgYmFzZUNvbmZpZyA9IFByb2ZpbGVyQ29uZmlnLmdldERlZmF1bHRDb25maWcoKTtcbiAgICAgICAgaWYgKCFmaWxlUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5sb2FkRnJvbUZpbGUoZmlsZVBhdGgpO1xuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICBiYXNlQ29uZmlnLmZpbGVQYXRoID0gY29uZmlnLmZpbGVQYXRoO1xuICAgICAgICAgICAgY29uZmlnLmltcGxlbWVudChiYXNlQ29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VDb25maWc7XG4gICAgfVxuICAgIHN0YXRpYyBhdXRvUmVzb2x2ZUZyb21QYXRoKHN0YXJ0RGlyKSB7XG4gICAgICAgIC8vIFNlYXJjaGVzIGZyb20gdGhlIGdpdmVuIHBhdGggdXB3YXJkcyB1bnRpbCBpdCBmaW5kcyB0aGUgY29uZmlnIGZpbGVcbiAgICAgICAgY29uc3QgY29uZmlnRmlsZVBhdGggPSBQYXRoVXRpbHNfMS5QYXRoVXRpbHMuZmluZFVwKGNvbmZpZ18xLlNUQVRJQ19DT05GSUdfRklMRU5BTUUsIHN0YXJ0RGlyLnRvUGxhdGZvcm1TdHJpbmcoKSk7XG4gICAgICAgIGlmICghY29uZmlnRmlsZVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9maWxlckNvbmZpZy5yZXNvbHZlRnJvbUZpbGUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvZmlsZXJDb25maWcucmVzb2x2ZUZyb21GaWxlKG5ldyBVbmlmaWVkUGF0aF8xLlVuaWZpZWRQYXRoKGNvbmZpZ0ZpbGVQYXRoKSk7XG4gICAgfVxuICAgIHN0YXRpYyBhdXRvUmVzb2x2ZSgpIHtcbiAgICAgICAgLy8gU2VhcmNoZXMgZnJvbSB0aGUgcHJvY2Vzc2VzIGV4ZWN1dGlvbiBwYXRoIHVwd2FyZHMgdW50aWwgaXQgZmluZHMgdGhlIGNvbmZpZyBmaWxlXG4gICAgICAgIHJldHVybiB0aGlzLmF1dG9SZXNvbHZlRnJvbVBhdGgobmV3IFVuaWZpZWRQYXRoXzEuVW5pZmllZFBhdGgocHJvY2Vzcy5jd2QoKSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvZmlsZXJDb25maWcgPSBQcm9maWxlckNvbmZpZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVVISnZabWxzWlhKRGIyNW1hV2N1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOXpjbU12Ylc5a1pXd3ZVSEp2Wm1sc1pYSkRiMjVtYVdjdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN1FVRkJRU3gxUTBGQmQwSTdRVUZGZUVJc01rTkJRWFZETzBGQlJYWkRMR2RFUVVjMFFqdEJRVU0xUWl4dFJFRkJLME03UVVGREwwTXNkVVJCUVcxRU8wRkJRMjVFTERaRFFVRjVRenRCUVVONlF5eHBSVUZCTmtRN1FVRkROMFFzVVVGQlVUdEJRVU5TTEc5RFFWbHBRanRCUVVWcVFpeE5RVUZoTEdOQlFXVXNVMEZCVVN4eFFrRkJVenRKUVZFMVF5eFpRVUZaTEZGQlFYRkNMRVZCUVVVc1RVRkJkVUk3VVVGRGVrUXNTMEZCU3l4RlFVRkZMRU5CUVVFN1VVRkRVQ3hKUVVGSkxFTkJRVU1zVVVGQlVTeEhRVUZITEZGQlFWRXNRMEZCUVR0UlFVTjRRaXhKUVVGSkxFTkJRVU1zVDBGQlR5eEhRVUZITEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVFN1VVRkROMElzU1VGQlNTeERRVUZETEdWQlFXVXNSMEZCUnl4TlFVRk5MRU5CUVVNc1pVRkJaU3hEUVVGQk8xRkJRemRETEVsQlFVa3NRMEZCUXl4aFFVRmhMRWRCUVVjc1RVRkJUU3hEUVVGRExHRkJRV0VzUTBGQlFUdFJRVU42UXl4SlFVRkpMRU5CUVVNc1kwRkJZeXhIUVVGSExFMUJRVTBzUTBGQlF5eGpRVUZqTEVOQlFVRTdVVUZETTBNc1NVRkJTU3hEUVVGRExHTkJRV01zUjBGQlJ5eE5RVUZOTEVOQlFVTXNZMEZCWXl4RFFVRkJPMGxCUXpWRExFTkJRVU03U1VGRlJDeE5RVUZOTEVOQlFVTXNaMEpCUVdkQ08xRkJRM1JDTEU5QlFVOHNTVUZCU1N4alFVRmpMRU5CUTNoQ0xFbEJRVWtzZVVKQlFWY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNLMEpCUVhOQ0xFTkJRVU1zUlVGRE0wUXNaME5CUVhWQ0xFTkJRM1pDTEVOQlFVRTdTVUZEUml4RFFVRkRPMGxCUlVRc01rSkJRVEpDTzFGQlF6RkNMRWxCUVVrc1NVRkJTU3hEUVVGRExHTkJRV01zUTBGQlF5eGxRVUZsTEVWQlFVVXNRMEZCUXp0WlFVTjZReXhSUVVGUkxFbEJRVWtzUTBGQlF5eGpRVUZqTEVOQlFVTXNaVUZCWlN4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRE8yZENRVU5zUkN4TFFVRkxMREpDUVVGdFFpeERRVUZETEU5QlFVODdiMEpCUXk5Q0xIVkRRVU5KTEVsQlFVa3NRMEZCUXl4alFVRmpMRXRCUTNSQ0xHVkJRV1VzUlVGQlJUczBRa0ZEYUVJc1NVRkJTU3hGUVVGRkxESkNRVUZ0UWl4RFFVRkRMRTlCUVU4N05FSkJRMnBETEU5QlFVOHNSVUZCUlR0blEwRkRVaXhqUVVGakxFVkJRVVVzU1VGQlNTeERRVUZETEdOQlFXTXNRMEZCUXl4bFFVRmxMRU5CUVVNc1QwRkJUeXhEUVVGRExHTkJRV003WjBOQlF6RkZMR05CUVdNc1JVRkJSU3hqUVVGak96WkNRVU01UWp0NVFrRkRSQ3hKUVVORU8yZENRVU5HTEV0QlFVc3NNa0pCUVcxQ0xFTkJRVU1zU1VGQlNUdHZRa0ZETlVJc2RVTkJRMGtzU1VGQlNTeERRVUZETEdOQlFXTXNTMEZEZEVJc1pVRkJaU3hGUVVGRk96UkNRVU5vUWl4SlFVRkpMRVZCUVVVc01rSkJRVzFDTEVOQlFVTXNTVUZCU1RzMFFrRkRPVUlzVDBGQlR5eEZRVUZGTzJkRFFVTlNMR05CUVdNc1JVRkJSU3hKUVVGSkxFTkJRVU1zWTBGQll5eERRVUZETEdWQlFXVXNRMEZCUXl4UFFVRlBMRU5CUVVNc1kwRkJZenRuUTBGRE1VVXNZMEZCWXl4RlFVRkZMR05CUVdNN05rSkJRemxDTzNsQ1FVTkVMRWxCUTBRN1owSkJRMFlzUzBGQlN5d3lRa0ZCYlVJc1EwRkJReXhaUVVGWk8yOUNRVU53UXl4MVEwRkRTU3hKUVVGSkxFTkJRVU1zWTBGQll5eExRVU4wUWl4bFFVRmxMRVZCUVVVN05FSkJRMmhDTEVsQlFVa3NSVUZCUlN3eVFrRkJiVUlzUTBGQlF5eFpRVUZaT3pSQ1FVTjBReXhQUVVGUExFVkJRVVU3WjBOQlExSXNZMEZCWXl4RlFVRkZMRWxCUVVrc1EwRkJReXhqUVVGakxFTkJRVU1zWlVGQlpTeERRVUZETEU5QlFVOHNRMEZCUXl4alFVRmpPMmREUVVNeFJTeGpRVUZqTEVWQlFVVXNZMEZCWXpzMlFrRkRPVUk3ZVVKQlEwUXNTVUZEUkR0WlFVTklMRU5CUVVNN1VVRkRSaXhEUVVGRE8xRkJRMFFzVDBGQlR5eEpRVUZKTEVOQlFVTXNZMEZCWXl4RFFVRkJPMGxCUXpOQ0xFTkJRVU03U1VGRlJDeDNRa0ZCZDBJN1VVRkRka0lzVDBGQlR5eEpRVUZKTEVOQlFVTXNZMEZCWXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zWTBGQll5eERRVUZCTzBsQlEycEVMRU5CUVVNN1NVRkZSQ3h2UWtGQmIwSTdVVUZEYmtJc1QwRkJUeXhWUVVGVkxFbEJRVWtzUTBGQlF5eGxRVUZsTEVOQlFVTXNSMEZCUnl4VFFVRlRMRU5CUVVFN1NVRkRia1FzUTBGQlF6dEpRVVZFTEdGQlFXRTdPMUZCUTFvc1QwRkJUeXhEUVVGRExFTkJRVUVzVFVGQlFTeEpRVUZKTEVOQlFVTXNaVUZCWlN3d1EwRkJSU3hIUVVGSExFMUJRVXNzVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUVN4TlFVRkJMRWxCUVVrc1EwRkJReXhsUVVGbExEQkRRVUZGTEVkQlFVY3NUVUZCU3l4RlFVRkZMRU5CUVVFN1NVRkRja1lzUTBGQlF6dEpRVVZFTEc5Q1FVRnZRanRSUVVOdVFpeEpRVUZKTEVOQlFVTXNaVUZCVFN4RFFVRkRMR2RDUVVGblFpeERRVUZETEVsQlFVa3NRMEZCUXl4alFVRmpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFVkJRVVVzUTBGQlF6dFpRVU01UkN4TlFVRk5MRWxCUVVrc1MwRkJTeXhEUVVGRExHOUZRVUZ2UlN4RFFVRkRMRU5CUVVFN1VVRkRkRVlzUTBGQlF6dFJRVU5FTEU5QlFVOHNTVUZCU1N4RFFVRkRMR05CUVdNc1EwRkJReXhWUVVGVkxFTkJRVUU3U1VGRGRFTXNRMEZCUXp0SlFVVkVMRlZCUVZVN1VVRkRWQ3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWxCUVVrc1EwRkJReXhoUVVGaExFTkJRVU1zVDBGQlR5eERRVUZETEVWQlFVVXNRMEZCUXp0WlFVTjBSQ3hQUVVGUExFbEJRVWtzZVVKQlFWY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1lVRkJZU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZCTzFGQlEyNUVMRU5CUVVNN1VVRkRSQ3hQUVVGUExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eGhRVUZoTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVFN1NVRkRhRVVzUTBGQlF6dEpRVVZFTEZOQlFWTTdVVUZEVWl4SlFVRkpMSEZDUVVGVExFTkJRVU1zVlVGQlZTeERRVUZETEVsQlFVa3NRMEZCUXl4aFFVRmhMRU5CUVVNc1RVRkJUU3hEUVVGRExFVkJRVVVzUTBGQlF6dFpRVU55UkN4UFFVRlBMRWxCUVVrc2VVSkJRVmNzUTBGQlF5eEpRVUZKTEVOQlFVTXNZVUZCWVN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGQk8xRkJRMnhFTEVOQlFVTTdVVUZEUkN4UFFVRlBMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zVDBGQlR5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhoUVVGaExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVRTdTVUZETDBRc1EwRkJRenRKUVVWRUxHZENRVUZuUWp0UlFVTm1MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eFZRVUZWTEVOQlFVTXNTVUZCU1N4RFFVRkRMR0ZCUVdFc1EwRkJReXhoUVVGaExFTkJRVU1zUlVGQlJTeERRVUZETzFsQlF6VkVMRTlCUVU4c1NVRkJTU3g1UWtGQlZ5eERRVUZETEVsQlFVa3NRMEZCUXl4aFFVRmhMRU5CUVVNc1lVRkJZU3hEUVVGRExFTkJRVUU3VVVGRGVrUXNRMEZCUXp0UlFVTkVMRTlCUVU4c1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eFBRVUZQTEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExHRkJRV0VzUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUVR0SlFVTjBSU3hEUVVGRE8wbEJSVVFzYzBKQlFYTkNPenRSUVVOeVFpeFBRVUZQTEUxQlFVRXNTVUZCU1N4RFFVRkRMR05CUVdNc1EwRkJReXhsUVVGbExEQkRRVUZGTEVsQlFVa3NRMEZCUVR0SlFVTnFSQ3hEUVVGRE8wbEJSVVFzZVVKQlFYbENPenRSUVV0NFFpeFBRVUZQTEUxQlFVRXNTVUZCU1N4RFFVRkRMR05CUVdNc1EwRkJReXhsUVVGbExEQkRRVUZGTEU5QlFVOHNRMEZCUVR0SlFVTndSQ3hEUVVGRE8wbEJSVVFzY1VKQlFYRkNPMUZCUTNCQ0xFOUJRVThzU1VGQlNTeERRVUZETEdGQlFXRXNRMEZCUXl4bFFVRmxMRU5CUVVFN1NVRkRNVU1zUTBGQlF6dEpRVVZFTEd0Q1FVRnJRanRSUVVOcVFpeFBRVUZQTEVsQlFVa3NRMEZCUXl4aFFVRmhMRU5CUVVNc1dVRkJXU3hEUVVGQk8wbEJRM1pETEVOQlFVTTdTVUZGUkN3clFrRkJLMEk3VVVGRE9VSXNUMEZCVHl4SlFVRkpMRU5CUVVNc1lVRkJZU3hEUVVGRExIbENRVUY1UWl4RFFVRkJPMGxCUTNCRUxFTkJRVU03U1VGRlJDeHZRa0ZCYjBJN1VVRkRia0lzVDBGQlR5eEpRVUZKTEVOQlFVTXNZMEZCWXl4RFFVRkRMRXRCUVVzc1EwRkJReXhoUVVGaExFTkJRVU1zUTBGQlFUdEpRVU5vUkN4RFFVRkRPMGxCUlU4c1owSkJRV2RDTEVOQlFVTXNVVUZCY1VJN1VVRkROME1zVFVGQlRTeGhRVUZoTEVkQlFVY3NTVUZCU1N4RFFVRkRMR0ZCUVdFc1EwRkJRVHRSUVVONFF5eEpRVUZKTEdGQlFXRXNSVUZCUlN4RFFVRkRPMWxCUTI1Q0xFbEJRVWtzWVVGQllTeERRVUZETEUxQlFVMHNTVUZCU1N4RFFVRkRMSEZDUVVGVExFTkJRVU1zVlVGQlZTeERRVUZETEdGQlFXRXNRMEZCUXl4TlFVRk5MRU5CUVVNc1JVRkJSU3hEUVVGRE8yZENRVU42UlN4aFFVRmhMRU5CUVVNc1RVRkJUU3hIUVVGSExGRkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTXNZVUZCWVN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZCTzFsQlEzUkZMRU5CUVVNN1dVRkRSQ3hKUVVGSkxHRkJRV0VzUTBGQlF5eGhRVUZoTEVsQlFVa3NRMEZCUXl4eFFrRkJVeXhEUVVGRExGVkJRVlVzUTBGQlF5eGhRVUZoTEVOQlFVTXNZVUZCWVN4RFFVRkRMRVZCUVVVc1EwRkJRenRuUWtGRGRrWXNZVUZCWVN4RFFVRkRMR0ZCUVdFc1IwRkJSeXhSUVVGUkxFTkJRVU1zU1VGQlNTeERRVUZETEdGQlFXRXNRMEZCUXl4aFFVRmhMRU5CUVVNc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlFUdFpRVU53Uml4RFFVRkRPMWxCUTBRc1NVRkJTU3hoUVVGaExFTkJRVU1zVDBGQlR5eEpRVUZKTEVOQlFVTXNjVUpCUVZNc1EwRkJReXhWUVVGVkxFTkJRVU1zWVVGQllTeERRVUZETEU5QlFVOHNRMEZCUXl4RlFVRkZMRU5CUVVNN1owSkJRek5GTEdGQlFXRXNRMEZCUXl4UFFVRlBMRWRCUVVjc1VVRkJVU3hEUVVGRExFbEJRVWtzUTBGQlF5eGhRVUZoTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVUU3V1VGRGVFVXNRMEZCUXp0UlFVTkdMRU5CUVVNN1VVRkRSQ3hQUVVGUE8xbEJRMDRzWVVGQllTeEZRVUZGTEdGQlFXRTdXVUZETlVJc1kwRkJZeXhGUVVGRkxFbEJRVWtzUTBGQlF5eGpRVUZqTzFsQlEyNURMR05CUVdNc1JVRkJSU3hKUVVGSkxFTkJRVU1zWTBGQll6dFpRVU51UXl4bFFVRmxMRVZCUVVVc1NVRkJTU3hEUVVGRExHVkJRV1U3VTBGRGNrTXNRMEZCUVR0SlFVTkdMRU5CUVVNN1NVRkZSRHM3T3pzN096czdPenM3T3pzN096czdPenRQUVcxQ1J6dEpRVU5MTEZOQlFWTXNRMEZCUXl4TlFVRnpRanM3VVVGRGRrTXNUVUZCVFN4UlFVRlJMRWRCUVVjc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eFBRVUZQTEVWQlFVVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eFBRVUZQTEVWQlFVVXNRMEZCUXl4RFFVRkJPMUZCUXpGRkxFMUJRVTBzWTBGQll5eEhRVUZITEUxQlFVMHNRMEZCUXl4blFrRkJaMElzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUVR0UlFVVjRSQ3hOUVVGTkxHZENRVUZuUWl4dFEwRkJVU3hqUVVGakxFTkJRVU1zWVVGQllTeEhRVUZMTEVsQlFVa3NRMEZCUXl4aFFVRmhMRU5CUVVVc1EwRkJRVHRSUVVOdVJpeE5RVUZOTEdsQ1FVRnBRaXh0UTBGQlVTeGpRVUZqTEVOQlFVTXNZMEZCWXl4SFFVRkxMRWxCUVVrc1EwRkJReXhqUVVGakxFTkJRVVVzUTBGQlFUdFJRVU4wUml4TlFVRk5MR2xDUVVGcFFpeHBSRUZEYmtJc1kwRkJZeXhEUVVGRExHTkJRV01zUjBGRE4wSXNTVUZCU1N4RFFVRkRMR05CUVdNc1MwRkRkRUlzUzBGQlN5eHJRMEZEUkN4RFFVRkRMRU5CUVVFc1RVRkJRU3hqUVVGakxHRkJRV1FzWTBGQll5eDFRa0ZCWkN4alFVRmpMRU5CUVVVc1kwRkJZeXd3UTBGQlJTeExRVUZMTEV0QlFVa3NSVUZCUlN4RFFVRkRMRWRCUXpkRExFTkJRVU1zUTBGQlFTeE5RVUZCTEVsQlFVa3NRMEZCUXl4alFVRmpMREJEUVVGRkxFdEJRVXNzUzBGQlNTeEZRVUZGTEVOQlFVTXNSMEZGZEVNc1JVRkJSU3hGUVVGRk8yZENRVU5JTEVkQlFVY3NhME5CUTBNc1EwRkJReXhEUVVGQkxFMUJRVUVzVFVGQlFTeGpRVUZqTEVOQlFVTXNZMEZCWXl3d1EwRkJSU3hGUVVGRkxEQkRRVUZGTEVkQlFVY3NTMEZCU1N4RlFVRkZMRU5CUVVNc1IwRkRPVU1zUTBGQlF5eERRVUZCTEUxQlFVRXNUVUZCUVN4SlFVRkpMRU5CUVVNc1kwRkJZeXd3UTBGQlJTeEZRVUZGTERCRFFVRkZMRWRCUVVjc1MwRkJTU3hGUVVGRkxFTkJRVU1zUTBGRGRrTTdZVUZEUkN4SFFVTkVMRU5CUVVFN1VVRkRSQ3hOUVVGTkxHdENRVUZyUWl4dFEwRkJVU3hqUVVGakxFTkJRVU1zWlVGQlpTeEhRVUZMTEVsQlFVa3NRMEZCUXl4bFFVRmxMRU5CUVVVc1EwRkJRVHRSUVVWNlJpeEpRVUZKTEVOQlFVTXNZVUZCWVN4SFFVRkhMR2RDUVVGblFpeERRVUZCTzFGQlEzSkRMRWxCUVVrc1EwRkJReXhqUVVGakxFZEJRVWNzYVVKQlFXbENMRU5CUVVFN1VVRkRka01zU1VGQlNTeERRVUZETEdOQlFXTXNSMEZCUnl4cFFrRkJhVUlzUTBGQlFUdFJRVU4yUXl4SlFVRkpMRU5CUVVNc1pVRkJaU3hIUVVGSExHdENRVUZyUWl4RFFVRkJPMGxCUXpGRExFTkJRVU03U1VGRlJDeE5RVUZOTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVRoQ08xRkJRemRETEVsQlFVa3NTVUZCY1VJc1EwRkJRVHRSUVVONlFpeEpRVUZKTEU5QlFVOHNTVUZCU1N4TFFVRkxMRkZCUVZFc1JVRkJSU3hEUVVGRE8xbEJRemxDTEVsQlFVa3NSMEZCUnl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZCTzFGQlEzaENMRU5CUVVNN1lVRkJUU3hEUVVGRE8xbEJRMUFzU1VGQlNTeEhRVUZITEVsQlFVa3NRMEZCUVR0UlFVTmFMRU5CUVVNN1VVRkRSQ3hKUVVORExFbEJRVWtzUTBGQlF5eGpRVUZqTEV0QlFVc3NVMEZCVXp0WlFVTnFReXhKUVVGSkxFTkJRVU1zWTBGQll5eERRVUZETEZWQlFWVXNTMEZCU3l4VFFVRlRMRVZCUXpORExFTkJRVU03V1VGRFJpeE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVRkRMRzFFUVVGdFJDeERRVUZETEVOQlFVRTdVVUZEY2tVc1EwRkJRenRSUVVORUxFbEJRVWtzUTBGQlF5eGxRVUZOTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zU1VGQlNTeERRVUZETEdOQlFXTXNRMEZCUXl4VlFVRlZMRU5CUVVNc1JVRkJSU3hEUVVGRE8xbEJRemxFTEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc01rWkJRVEpHTEVOQlFVTXNRMEZCUVR0UlFVTTNSeXhEUVVGRE8xRkJSVVFzVDBGQlR5eEpRVUZKTEdOQlFXTXNRMEZEZUVJc1NVRkJTU3g1UWtGQlZ5eERRVUZETEVWQlFVVXNRMEZCUXl4RlFVTnVRanRaUVVORExFOUJRVThzUlVGQlJTeEpRVUZKTEVOQlFVTXNUMEZCVHp0WlFVTnlRaXhoUVVGaExFVkJRVVVzU1VGQlNTeERRVUZETEdGQlFXRTdXVUZEYWtNc1kwRkJZeXhGUVVGRkxFbEJRVWtzUTBGQlF5eGpRVUZqTzFsQlEyNURMR05CUVdNc1JVRkJSU3hKUVVGSkxFTkJRVU1zWTBGQll6dFpRVU51UXl4bFFVRmxMRVZCUVVVc1NVRkJTU3hEUVVGRExHVkJRV1U3VTBGRGNrTXNRMEZCUXl4RFFVRkJPMGxCUTBvc1EwRkJRenRKUVVWRUxFMUJRVTA3VVVGRFRDeFBRVUZQTEVOQlFVTTdXVUZEVUN4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRExFOUJRVTg3V1VGRGNrSXNZVUZCWVN4RlFVRkZMRWxCUVVrc1EwRkJReXhoUVVGaE8xbEJRMnBETEdOQlFXTXNSVUZCUlN4SlFVRkpMRU5CUVVNc1kwRkJZenRaUVVOdVF5eGpRVUZqTEVWQlFVVXNTVUZCU1N4RFFVRkRMR05CUVdNN1dVRkRia01zWlVGQlpTeEZRVUZGTEVsQlFVa3NRMEZCUXl4bFFVRmxPMU5CUTNKRExFTkJRVU1zUTBGQlFUdEpRVU5JTEVOQlFVTTdTVUZGUkN4WFFVRlhMRU5CUVVNc1VVRkJjVUk3VVVGRGFFTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhWUVVGVkxFTkJRVU1zVVVGQlVTeERRVUZETEU5QlFVOHNSVUZCUlN4RFFVRkRMR2RDUVVGblFpeEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRPMWxCUXpORUxHMURRVUZuUWl4RFFVRkRMR3REUVVGclF5eERRVUZETEZGQlFWRXNRMEZCUXl4UFFVRlBMRVZCUVVVc1EwRkJReXhuUWtGQlowSXNSVUZCUlN4RFFVRkRMRU5CUVVFN1VVRkRNMFlzUTBGQlF6dFJRVU5FTEcxRFFVRm5RaXhEUVVGRExESkNRVUV5UWl4RFFVTXpReXhSUVVGUkxFTkJRVU1zWjBKQlFXZENMRVZCUVVVc1JVRkRNMElzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRVZCUVVVc1NVRkJTU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVU0zUWl4RFFVRkJPMGxCUTBZc1EwRkJRenRKUVVWRUxIVkVRVUYxUkR0SlFVTjJSQ3gzUjBGQmQwYzdTVUZEZUVjc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF5eFJRVUZ4UWp0UlFVTjRReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEZWQlFWVXNRMEZCUXl4UlFVRlJMRU5CUVVNc1owSkJRV2RDTEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNN1dVRkRha1FzVDBGQlR5eFRRVUZUTEVOQlFVRTdVVUZEYWtJc1EwRkJRenRSUVVWRUxFMUJRVTBzV1VGQldTeEhRVUZITEdOQlFXTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1JVRkJSU3hEUVVGRExGbEJRVmtzUTBGQlF5eFJRVUZSTEVOQlFVTXNaMEpCUVdkQ0xFVkJRVVVzUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRU5CUVVFN1VVRkRja2NzV1VGQldTeERRVUZETEZGQlFWRXNSMEZCUnl4UlFVRlJMRU5CUVVFN1VVRkZhRU1zU1VGQlNTeFpRVUZaTEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNN1dVRkRNVUlzVFVGQlRTeHpRa0ZCYzBJc1IwRkJSeXhSUVVGUkxFTkJRVU1zVDBGQlR5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRmxCUVZrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlFUdFpRVU0xUlN4TlFVRk5MR05CUVdNc1IwRkJSeXhqUVVGakxFTkJRVU1zV1VGQldTeERRVUZETEhOQ1FVRnpRaXhEUVVGRExFTkJRVUU3V1VGRk1VVXNTVUZCU1N4alFVRmpMRVZCUVVVc1EwRkJRenRuUWtGRGNFSXNXVUZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhqUVVGakxFTkJRVU1zUTBGQlFUdG5Ra0ZEZEVNc1QwRkJUeXhaUVVGWkxFTkJRVUU3V1VGRGNFSXNRMEZCUXp0UlFVTkdMRU5CUVVNN1VVRkRSQ3hQUVVGUExGbEJRVmtzUTBGQlFUdEpRVU53UWl4RFFVRkRPMGxCUlVRc2RVZEJRWFZITzBsQlEzWkhMRTFCUVUwc1EwRkJReXhsUVVGbExFTkJRVU1zVVVGQmFVTTdVVUZEZGtRc1RVRkJUU3hWUVVGVkxFZEJRVWNzWTBGQll5eERRVUZETEdkQ1FVRm5RaXhGUVVGRkxFTkJRVUU3VVVGRGNFUXNTVUZCU1N4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8xbEJRMllzVDBGQlR5eFZRVUZWTEVOQlFVRTdVVUZEYkVJc1EwRkJRenRSUVVWRUxFMUJRVTBzVFVGQlRTeEhRVUZITEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVUU3VVVGRE1VTXNTVUZCU1N4TlFVRk5MRVZCUVVVc1EwRkJRenRaUVVOYUxGVkJRVlVzUTBGQlF5eFJRVUZSTEVkQlFVY3NUVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJRVHRaUVVOeVF5eE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGQk8xbEJRelZDTEU5QlFVOHNUVUZCVFN4RFFVRkJPMUZCUTJRc1EwRkJRenRSUVVORUxFOUJRVThzVlVGQlZTeERRVUZCTzBsQlEyeENMRU5CUVVNN1NVRkZSQ3hOUVVGTkxFTkJRVU1zYlVKQlFXMUNMRU5CUVVNc1VVRkJjVUk3VVVGREwwTXNjMFZCUVhORk8xRkJRM1JGTEUxQlFVMHNZMEZCWXl4SFFVRkhMSEZDUVVGVExFTkJRVU1zVFVGQlRTeERRVU4wUXl3clFrRkJjMElzUlVGRGRFSXNVVUZCVVN4RFFVRkRMR2RDUVVGblFpeEZRVUZGTEVOQlF6TkNMRU5CUVVFN1VVRkZSQ3hKUVVGSkxFTkJRVU1zWTBGQll5eEZRVUZGTEVOQlFVTTdXVUZEY2tJc1QwRkJUeXhqUVVGakxFTkJRVU1zWlVGQlpTeERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkJPMUZCUTJwRUxFTkJRVU03VVVGRlJDeFBRVUZQTEdOQlFXTXNRMEZCUXl4bFFVRmxMRU5CUVVNc1NVRkJTU3g1UWtGQlZ5eERRVUZETEdOQlFXTXNRMEZCUXl4RFFVRkRMRU5CUVVFN1NVRkRka1VzUTBGQlF6dEpRVVZFTEUxQlFVMHNRMEZCUXl4WFFVRlhPMUZCUTJwQ0xHOUdRVUZ2Ump0UlFVTndSaXhQUVVGUExFbEJRVWtzUTBGQlF5eHRRa0ZCYlVJc1EwRkJReXhKUVVGSkxIbENRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWRCUVVjc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlFUdEpRVU5vUlN4RFFVRkRPME5CUTBRN1FVRnVWRVFzZDBOQmJWUkRJbjA9Il19",
    "852": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Profiler = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst inspector_1 = require(\"inspector\");\nconst seedrandom_1 = __importDefault(require(\"seedrandom\"));\nconst profiler_core_1 = require(\"@oaklean/profiler-core\");\nconst V8Profiler_1 = require(\"./model/V8Profiler\");\nconst TraceEventHelper_1 = require(\"./helper/TraceEventHelper\");\nconst PowerMetricsSensorInterface_1 = require(\"./interfaces/powermetrics/PowerMetricsSensorInterface\");\nconst PerfSensorInterface_1 = require(\"./interfaces/perf/PerfSensorInterface\");\nconst WindowsSensorInterface_1 = require(\"./interfaces/windows/WindowsSensorInterface\");\nclass Profiler {\n    constructor(subOutputDir, options) {\n        this.subOutputDir = subOutputDir;\n        this.config = profiler_core_1.ProfilerConfig.autoResolve();\n        this.options = options;\n        this.loadSensorInterface();\n        this._inspectorHelper = new profiler_core_1.InspectorHelper();\n    }\n    static getSensorInterface(config) {\n        const sensorInterfaceType = config.getSensorInterfaceType();\n        switch (sensorInterfaceType) {\n            case 'powermetrics': {\n                const options = config.getSensorInterfaceOptions();\n                if (options === undefined) {\n                    throw new Error('Profiler.getSensorInterface: sensorInterfaceOptions are not defined');\n                }\n                options.outputFilePath = config.getOutDir().join(options.outputFilePath).toPlatformString();\n                return new PowerMetricsSensorInterface_1.PowerMetricsSensorInterface(options);\n            }\n            case 'perf': {\n                const options = config.getSensorInterfaceOptions();\n                if (options === undefined) {\n                    throw new Error('Profiler.getSensorInterface: sensorInterfaceOptions are not defined');\n                }\n                options.outputFilePath = config.getOutDir().join(options.outputFilePath).toPlatformString();\n                return new PerfSensorInterface_1.PerfSensorInterface(options);\n            }\n            case 'windows': {\n                const options = config.getSensorInterfaceOptions();\n                if (options === undefined) {\n                    throw new Error('Profiler.getSensorInterface: sensorInterfaceOptions are not defined');\n                }\n                options.outputFilePath = config.getOutDir().join(options.outputFilePath).toPlatformString();\n                return new WindowsSensorInterface_1.WindowsSensorInterface(options);\n            }\n        }\n    }\n    loadSensorInterface() {\n        this._sensorInterface = Profiler.getSensorInterface(this.config);\n    }\n    static inject(subOutputDir) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const profiler = new Profiler(subOutputDir);\n            const title = new Date().getTime().toString();\n            const exitResolve = () => resolve('exit');\n            const sigIntResolve = () => resolve('SIGINT');\n            const sigUsr1Resolve = () => resolve('SIGUSR1');\n            const sigUsr2Resolve = () => resolve('SIGUSR2');\n            let stopped = false;\n            function resolve(origin) {\n                return __awaiter(this, void 0, void 0, function* () {\n                    if (!stopped) {\n                        stopped = true;\n                        profiler_core_1.LoggerHelper.log(`(${profiler_core_1.APP_NAME} Profiler) Finish Measurement, please wait...`);\n                        yield profiler.finish(title);\n                        process.removeListener('exit', exitResolve);\n                        process.removeListener('SIGINT', sigIntResolve);\n                        process.removeListener('SIGUSR1', sigUsr1Resolve);\n                        process.removeListener('SIGUSR2', sigUsr2Resolve);\n                        if (origin !== 'exit') {\n                            process.exit();\n                        }\n                    }\n                });\n            }\n            profiler_core_1.LoggerHelper.log(`(${profiler_core_1.APP_NAME} Profiler) Measurement started`);\n            yield profiler.start(title);\n            process.on('exit', exitResolve);\n            // //catches ctrl+c event\n            process.on('SIGINT', sigIntResolve);\n            // // catches \"kill pid\" (for example: nodemon restart)\n            process.on('SIGUSR1', sigUsr1Resolve);\n            process.on('SIGUSR2', sigUsr2Resolve);\n            return profiler;\n        });\n    }\n    startCapturingProfilerTracingEvents() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._traceEventSession !== undefined) {\n                throw new Error('startCapturingProfilerTracingEvents: Trace Event Session should not already be defined');\n            }\n            const session = new inspector_1.Session();\n            this._traceEventSession = session;\n            session.connect();\n            session.on('NodeTracing.dataCollected', (chunk) => {\n                for (const event of chunk.params.value) {\n                    if (event.pid === process.pid && event.cat === 'v8') {\n                        if (event.name === 'CpuProfiler::StartProfiling') { // captured start event of cpu profiler\n                            this._profilerStartTime = event.ts; // store high resolution begin time\n                        }\n                    }\n                }\n            });\n            const traceConfig = { includedCategories: ['v8'] }; // config to capture v8's trace events\n            yield TraceEventHelper_1.TraceEventHelper.post(session, 'NodeTracing.start', { traceConfig }); // start trace event capturing\n        });\n    }\n    stopCapturingProfilerTracingEvents() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._traceEventSession === undefined) {\n                throw new Error('stopCapturingProfilerTracingEvents: Trace Event Session should be defined');\n            }\n            yield TraceEventHelper_1.TraceEventHelper.post(this._traceEventSession, 'NodeTracing.stop', undefined);\n            this._traceEventSession.disconnect();\n            this._traceEventSession = undefined;\n        });\n    }\n    getCPUProfilerBeginTime() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let tries = 0;\n            while (this._profilerStartTime === undefined && tries < 10) {\n                profiler_core_1.LoggerHelper.error(`Cannot capture profiler start time on try: ${tries + 1}, try again after 1 second`);\n                tries += 1;\n                yield profiler_core_1.TimeHelper.sleep(1000);\n            }\n            if (this._profilerStartTime === undefined) {\n                throw new Error(`Could not capture cpu profilers begin time after ${tries} tries, measurements failed`);\n            }\n            return this._profilerStartTime;\n        });\n    }\n    start(title, executionDetails) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const performance = new profiler_core_1.PerformanceHelper();\n            performance.start('Profiler.start');\n            const outFileReport = this.outputReportPath(title);\n            const outDir = outFileReport.dirName();\n            performance.start('Profiler.start.createOutDir');\n            if (!fs.existsSync(outDir.toPlatformString())) {\n                profiler_core_1.PermissionHelper.mkdirRecursivelyWithUserPermission(outDir);\n            }\n            performance.stop('Profiler.start.createOutDir');\n            performance.start('Profiler.start.seedRandom');\n            const mathRandomSeed = this.config.getSeedForMathRandom();\n            if (mathRandomSeed) {\n                (0, seedrandom_1.default)(mathRandomSeed, { global: true });\n            }\n            performance.stop('Profiler.start.seedRandom');\n            if (executionDetails) {\n                this.executionDetails = executionDetails;\n            }\n            else {\n                performance.start('Profiler.start.resolveExecutionDetails');\n                this.executionDetails = yield profiler_core_1.ExecutionDetails.resolveExecutionDetails();\n                performance.stop('Profiler.start.resolveExecutionDetails');\n            }\n            performance.start('Profiler.start.V8Profiler.setGenerateType');\n            V8Profiler_1.V8Profiler.setGenerateType(1); // must be set to generate new cpuprofile format\n            performance.stop('Profiler.start.V8Profiler.setGenerateType');\n            performance.start('Profiler.start.getV8CPUSamplingInterval');\n            V8Profiler_1.V8Profiler.setSamplingInterval(this.config.getV8CPUSamplingInterval()); // sets the sampling interval in microseconds\n            performance.stop('Profiler.start.getV8CPUSamplingInterval');\n            performance.start('Profiler.start.startCapturingProfilerTracingEvents');\n            yield this.startCapturingProfilerTracingEvents();\n            performance.stop('Profiler.start.startCapturingProfilerTracingEvents');\n            performance.start('Profiler.start.sensorInterface.couldBeExecuted');\n            if (this._sensorInterface !== undefined && !(yield this._sensorInterface.couldBeExecuted())) {\n                // remove sensor interface from execution details since it cannot be executed\n                this.executionDetails.runTimeOptions.sensorInterface = undefined;\n                profiler_core_1.LoggerHelper.warn(`(${profiler_core_1.APP_NAME} Profiler) Warning: ` +\n                    'Sensor Interface can not be executed, no energy measurements will be collected');\n            }\n            performance.stop('Profiler.start.sensorInterface.couldBeExecuted');\n            performance.start('Profiler.start.sensorInterface.startProfiling');\n            yield ((_a = this._sensorInterface) === null || _a === void 0 ? void 0 : _a.startProfiling());\n            performance.stop('Profiler.start.sensorInterface.startProfiling');\n            // title - handle to stop profile again\n            // recsampels(boolean) - record samples, if false no cpu times will be captured\n            performance.start('Profiler.start.V8Profiler.startProfiling');\n            V8Profiler_1.V8Profiler.startProfiling(title, true);\n            performance.stop('Profiler.start.V8Profiler.startProfiling');\n            performance.start('Profiler.start.inspectorHelper.connect');\n            yield this._inspectorHelper.connect();\n            this._inspectorHelper.listen();\n            performance.stop('Profiler.start.inspectorHelper.connect');\n            performance.stop('Profiler.start');\n            performance.printReport('Profiler.start');\n            performance.exportAndSum(this.outputDir().join('performance.json'));\n        });\n    }\n    outputDir() {\n        return this.config.getOutDir().join(this.subOutputDir || '');\n    }\n    outputReportPath(title) {\n        return this.outputDir().join(`${title}.oak`);\n    }\n    outputMetricCollectionPath(title) {\n        return this.outputDir().join(`${title}.mcollection`);\n    }\n    outputProfilePath(title) {\n        return this.outputDir().join(`${title}.cpuprofile`);\n    }\n    outputInspectorHelperPath(title) {\n        return this.outputDir().join(`${title}.inspector.json`);\n    }\n    finish(title, highResolutionStopTime) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            const performance = new profiler_core_1.PerformanceHelper();\n            performance.start('Profiler.finish');\n            if (this.executionDetails === undefined) {\n                throw new Error('Profiler.finish: Profiler was not started yet');\n            }\n            if (highResolutionStopTime !== undefined) {\n                this.executionDetails.highResolutionStopTime = highResolutionStopTime.toString();\n            }\n            performance.start('Profiler.finish.stopProfiling');\n            const profile = V8Profiler_1.V8Profiler.stopProfiling(title);\n            performance.stop('Profiler.finish.stopProfiling');\n            performance.start('Profiler.finish.stopCapturingProfilerTracingEvents');\n            this.stopCapturingProfilerTracingEvents();\n            performance.stop('Profiler.finish.stopCapturingProfilerTracingEvents');\n            performance.start('Profiler.finish.sensorInterface.stopProfiling');\n            yield ((_a = this._sensorInterface) === null || _a === void 0 ? void 0 : _a.stopProfiling());\n            performance.stop('Profiler.finish.sensorInterface.stopProfiling');\n            const CPUProfilerBeginTime = BigInt(yield this.getCPUProfilerBeginTime()) * BigInt(1000);\n            this.executionDetails.highResolutionBeginTime = CPUProfilerBeginTime.toString();\n            const exportData = {\n                nodes: profile.nodes,\n                startTime: profile.startTime,\n                endTime: profile.endTime,\n                samples: profile.samples,\n                timeDeltas: profile.timeDeltas\n            };\n            let transformerAdapter = undefined;\n            if (((_b = this.options) === null || _b === void 0 ? void 0 : _b.transformerAdapter) === 'ts-jest') {\n                if (!this.options.jestAdapter.config || !this.options.jestAdapter.context) {\n                    throw new Error('Please provide the JestEnvironmentConfig and EnvironmentContext in the profiler options at options.jestAdapter');\n                }\n                transformerAdapter = new profiler_core_1.JestAdapter(this.options.jestAdapter.config, this.options.jestAdapter.context);\n                if (!fs.existsSync(this.outputDir().toPlatformString())) {\n                    profiler_core_1.PermissionHelper.mkdirRecursivelyWithUserPermission(this.outputDir());\n                }\n                performance.start('Profiler.finish.exportJestConfig');\n                profiler_core_1.PermissionHelper.writeFileWithUserPermission(this.outputDir().join('jest.config').toPlatformString(), JSON.stringify({\n                    config: this.options.jestAdapter.config,\n                    context: this.options.jestAdapter.context\n                }));\n                performance.stop('Profiler.finish.exportJestConfig');\n            }\n            const outFileCPUProfile = this.outputProfilePath(title);\n            const outFileInspectorHelper = this.outputInspectorHelperPath(title);\n            const outFileReport = this.outputReportPath(title);\n            const outFileMetricCollection = this.outputMetricCollectionPath(title);\n            if (this.config.shouldExportV8Profile()) {\n                performance.start('Profiler.finish.exportV8Profile');\n                profiler_core_1.PermissionHelper.writeFileWithUserPermission(outFileCPUProfile.toPlatformString(), JSON.stringify(exportData, null, 2));\n                performance.stop('Profiler.finish.exportV8Profile');\n            }\n            performance.start('Profiler.finish.sensorInterface.readSensorValues');\n            const metricsDataCollection = yield ((_c = this._sensorInterface) === null || _c === void 0 ? void 0 : _c.readSensorValues(process.pid));\n            performance.stop('Profiler.finish.sensorInterface.readSensorValues');\n            const rootDir = this.config.getRootDir();\n            const report = new profiler_core_1.ProjectReport(this.executionDetails, profiler_core_1.ReportKind.measurement);\n            if (this.config.shouldExportSensorInterfaceData()) {\n                if (metricsDataCollection !== undefined) {\n                    performance.start('Profiler.finish.exportMetricsDataCollection');\n                    metricsDataCollection.storeToFile(outFileMetricCollection);\n                    performance.stop('Profiler.finish.exportMetricsDataCollection');\n                }\n            }\n            performance.start('Profiler.finish.insertCPUProfile');\n            yield report.insertCPUProfile(rootDir, profile, this._inspectorHelper, metricsDataCollection);\n            performance.stop('Profiler.finish.insertCPUProfile');\n            performance.start('Profiler.finish.inspectorHelper.disconnect');\n            yield this._inspectorHelper.disconnect();\n            performance.stop('Profiler.finish.inspectorHelper.disconnect');\n            if (this.config.shouldExportV8Profile()) {\n                performance.start('Profiler.finish.exportInspectorHelper');\n                profiler_core_1.PermissionHelper.writeFileWithUserPermission(outFileInspectorHelper.toPlatformString(), JSON.stringify(this._inspectorHelper, null, 2));\n                performance.stop('Profiler.finish.exportInspectorHelper');\n            }\n            performance.start('Profiler.finish.trackUncommittedFiles');\n            yield report.trackUncommittedFiles(rootDir);\n            performance.stop('Profiler.finish.trackUncommittedFiles');\n            if (this.config.shouldExportReport()) {\n                performance.start('Profiler.finish.exportReport');\n                report.storeToFile(outFileReport, 'bin', this.config);\n                performance.stop('Profiler.finish.exportReport');\n            }\n            if (yield report.shouldBeStoredInRegistry()) {\n                yield report.uploadToRegistry(this.config);\n            }\n            performance.stop('Profiler.finish');\n            performance.printReport('Profiler.finish');\n            performance.exportAndSum(this.outputDir().join('performance.json'));\n            return report;\n        });\n    }\n}\nexports.Profiler = Profiler;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2theW1ha293c2t5L0RvY3VtZW50cy9IaXRhYmlzL0N1cnJlbnQtV29ya3NwYWNlcy9HcmVlbklUL09ha2xlYW4vcGFja2FnZXMvcHJvZmlsZXIvc3JjL1Byb2ZpbGVyLnRzIiwic291cmNlcyI6WyIvVXNlcnMva2F5bWFrb3dza3kvRG9jdW1lbnRzL0hpdGFiaXMvQ3VycmVudC1Xb3Jrc3BhY2VzL0dyZWVuSVQvT2FrbGVhbi9wYWNrYWdlcy9wcm9maWxlci9zcmMvUHJvZmlsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx1Q0FBd0I7QUFDeEIseUNBQW1DO0FBRW5DLDREQUFtQztBQUNuQywwREFnQitCO0FBRy9CLG1EQUErQztBQUMvQyxnRUFBNEQ7QUFFNUQsdUdBQW1HO0FBQ25HLCtFQUEyRTtBQUMzRSx3RkFBb0Y7QUF3QnBGLE1BQWEsUUFBUTtJQVdwQixZQUNDLFlBQXFCLEVBQ3JCLE9BQXlCO1FBRXpCLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFBO1FBQ2hDLElBQUksQ0FBQyxNQUFNLEdBQUcsOEJBQWMsQ0FBQyxXQUFXLEVBQUUsQ0FBQTtRQUMxQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQTtRQUN0QixJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQTtRQUMxQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSwrQkFBZSxFQUFFLENBQUE7SUFDOUMsQ0FBQztJQUVELE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxNQUFzQjtRQUMvQyxNQUFNLG1CQUFtQixHQUFHLE1BQU0sQ0FBQyxzQkFBc0IsRUFBRSxDQUFBO1FBQzNELFFBQVEsbUJBQW1CLEVBQUUsQ0FBQztZQUM3QixLQUFLLGNBQWMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3JCLE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyx5QkFBeUIsRUFBRSxDQUFBO2dCQUNsRCxJQUFJLE9BQU8sS0FB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QUFFLEVBQUUsQ0FBQztnQkFDN0MsTUFBTSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO1lBQzNDLENBQUM7WUFDRCxXQUFXLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUE7WUFDbkMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFBO1lBQzFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUE7WUFFbkUsT0FBTyxNQUFNLENBQUE7O0tBQ2I7Q0FDRDtBQTVWRCw0QkE0VkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcydcbmltcG9ydCB7IFNlc3Npb24gfSBmcm9tICdpbnNwZWN0b3InXG5cbmltcG9ydCBzZWVkcmFuZG9tIGZyb20gJ3NlZWRyYW5kb20nXG5pbXBvcnQge1xuXHRBUFBfTkFNRSxcblx0VW5pZmllZFBhdGgsXG5cdFByb2ZpbGVyQ29uZmlnLFxuXHRQcm9qZWN0UmVwb3J0LFxuXHRJUHJvamVjdFJlcG9ydEV4ZWN1dGlvbkRldGFpbHMsXG5cdEplc3RBZGFwdGVyLFxuXHRUaW1lSGVscGVyLFxuXHROYW5vU2Vjb25kc19CaWdJbnQsXG5cdE1pY3JvU2Vjb25kc19udW1iZXIsXG5cdFJlcG9ydEtpbmQsXG5cdFBlcm1pc3Npb25IZWxwZXIsXG5cdExvZ2dlckhlbHBlcixcblx0RXhlY3V0aW9uRGV0YWlscyxcblx0UGVyZm9ybWFuY2VIZWxwZXIsXG5cdEluc3BlY3RvckhlbHBlclxufSBmcm9tICdAb2FrbGVhbi9wcm9maWxlci1jb3JlJ1xuaW1wb3J0IHsgSmVzdEVudmlyb25tZW50Q29uZmlnLCBFbnZpcm9ubWVudENvbnRleHQgfSBmcm9tICdAamVzdC9lbnZpcm9ubWVudCdcblxuaW1wb3J0IHsgVjhQcm9maWxlciB9IGZyb20gJy4vbW9kZWwvVjhQcm9maWxlcidcbmltcG9ydCB7IFRyYWNlRXZlbnRIZWxwZXIgfSBmcm9tICcuL2hlbHBlci9UcmFjZUV2ZW50SGVscGVyJ1xuaW1wb3J0IHsgQmFzZVNlbnNvckludGVyZmFjZSB9IGZyb20gJy4vaW50ZXJmYWNlcy9CYXNlU2Vuc29ySW50ZXJmYWNlJ1xuaW1wb3J0IHsgUG93ZXJNZXRyaWNzU2Vuc29ySW50ZXJmYWNlIH0gZnJvbSAnLi9pbnRlcmZhY2VzL3Bvd2VybWV0cmljcy9Qb3dlck1ldHJpY3NTZW5zb3JJbnRlcmZhY2UnXG5pbXBvcnQgeyBQZXJmU2Vuc29ySW50ZXJmYWNlIH0gZnJvbSAnLi9pbnRlcmZhY2VzL3BlcmYvUGVyZlNlbnNvckludGVyZmFjZSdcbmltcG9ydCB7IFdpbmRvd3NTZW5zb3JJbnRlcmZhY2UgfSBmcm9tICcuL2ludGVyZmFjZXMvd2luZG93cy9XaW5kb3dzU2Vuc29ySW50ZXJmYWNlJ1xuXG5leHBvcnQgdHlwZSBUcmFuc2Zvcm1lckFkYXB0ZXIgPSAndHMtamVzdCdcblxuZXhwb3J0IHR5cGUgUHJvZmlsZXJPcHRpb25zID0ge1xuXHR0cmFuc2Zvcm1lckFkYXB0ZXI/OiBUcmFuc2Zvcm1lckFkYXB0ZXJcblx0amVzdEFkYXB0ZXI6IHtcblx0XHRjb25maWc6IEplc3RFbnZpcm9ubWVudENvbmZpZyxcblx0XHRjb250ZXh0OiBFbnZpcm9ubWVudENvbnRleHRcblx0fVxufVxuXG5pbnRlcmZhY2UgVHJhY2VFdmVudFBhcmFtcyB7XG5cdHBpZDogbnVtYmVyLFxuXHR0aWQ6IG51bWJlcixcblx0dHM6IG51bWJlcixcblx0dHRzOiBudW1iZXIsXG5cdHBoOiBzdHJpbmcsXG5cdGNhdDogc3RyaW5nLFxuXHRuYW1lOiBzdHJpbmcsXG5cdGR1cjogbnVtYmVyXG5cdHRkdXI6IG51bWJlclxufVxuXG5leHBvcnQgY2xhc3MgUHJvZmlsZXIge1xuXHRzdWJPdXRwdXREaXI6IHN0cmluZyB8IHVuZGVmaW5lZFxuXHRjb25maWc6IFByb2ZpbGVyQ29uZmlnXG5cdG9wdGlvbnM/OiBQcm9maWxlck9wdGlvbnNcblx0ZXhlY3V0aW9uRGV0YWlscz86IElQcm9qZWN0UmVwb3J0RXhlY3V0aW9uRGV0YWlsc1xuXG5cdHByaXZhdGUgX2luc3BlY3RvckhlbHBlcjogSW5zcGVjdG9ySGVscGVyXG5cdHByaXZhdGUgX3NlbnNvckludGVyZmFjZTogQmFzZVNlbnNvckludGVyZmFjZSB8IHVuZGVmaW5lZFxuXHRwcml2YXRlIF90cmFjZUV2ZW50U2Vzc2lvbjogU2Vzc2lvbiB8IHVuZGVmaW5lZFxuXHRwcml2YXRlIF9wcm9maWxlclN0YXJ0VGltZTogTWljcm9TZWNvbmRzX251bWJlciB8IHVuZGVmaW5lZFxuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHN1Yk91dHB1dERpcj86IHN0cmluZyxcblx0XHRvcHRpb25zPzogUHJvZmlsZXJPcHRpb25zXG5cdCkge1xuXHRcdHRoaXMuc3ViT3V0cHV0RGlyID0gc3ViT3V0cHV0RGlyXG5cdFx0dGhpcy5jb25maWcgPSBQcm9maWxlckNvbmZpZy5hdXRvUmVzb2x2ZSgpXG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9uc1xuXHRcdHRoaXMubG9hZFNlbnNvckludGVyZmFjZSgpXG5cdFx0dGhpcy5faW5zcGVjdG9ySGVscGVyID0gbmV3IEluc3BlY3RvckhlbHBlcigpXG5cdH1cblxuXHRzdGF0aWMgZ2V0U2Vuc29ySW50ZXJmYWNlKGNvbmZpZzogUHJvZmlsZXJDb25maWcpIHtcblx0XHRjb25zdCBzZW5zb3JJbnRlcmZhY2VUeXBlID0gY29uZmlnLmdldFNlbnNvckludGVyZmFjZVR5cGUoKVxuXHRcdHN3aXRjaCAoc2Vuc29ySW50ZXJmYWNlVHlwZSkge1xuXHRcdFx0Y2FzZSAncG93ZXJtZXRyaWNzJzoge1xuXHRcdFx0XHRjb25zdCBvcHRpb25zID0gY29uZmlnLmdldFNlbnNvckludGVyZmFjZU9wdGlvbnMoKVxuXHRcdFx0XHRpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQcm9maWxlci5nZXRTZW5zb3JJbnRlcmZhY2U6IHNlbnNvckludGVyZmFjZU9wdGlvbnMgYXJlIG5vdCBkZWZpbmVkJylcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zLm91dHB1dEZpbGVQYXRoID0gY29uZmlnLmdldE91dERpcigpLmpvaW4ob3B0aW9ucy5vdXRwdXRGaWxlUGF0aCkudG9QbGF0Zm9ybVN0cmluZygpXG5cdFx0XHRcdHJldHVybiBuZXcgUG93ZXJNZXRyaWNzU2Vuc29ySW50ZXJmYWNlKG9wdGlvbnMpXG5cdFx0XHR9XG5cdFx0XHRjYXNlICdwZXJmJzoge1xuXHRcdFx0XHRjb25zdCBvcHRpb25zID0gY29uZmlnLmdldFNlbnNvckludGVyZmFjZU9wdGlvbnMoKVxuXHRcdFx0XHRpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQcm9maWxlci5nZXRTZW5zb3JJbnRlcmZhY2U6IHNlbnNvckludGVyZmFjZU9wdGlvbnMgYXJlIG5vdCBkZWZpbmVkJylcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zLm91dHB1dEZpbGVQYXRoID0gY29uZmlnLmdldE91dERpcigpLmpvaW4ob3B0aW9ucy5vdXRwdXRGaWxlUGF0aCkudG9QbGF0Zm9ybVN0cmluZygpXG5cdFx0XHRcdHJldHVybiBuZXcgUGVyZlNlbnNvckludGVyZmFjZShvcHRpb25zKVxuXHRcdFx0fVxuXHRcdFx0Y2FzZSAnd2luZG93cyc6IHtcblx0XHRcdFx0Y29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5nZXRTZW5zb3JJbnRlcmZhY2VPcHRpb25zKClcblx0XHRcdFx0aWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignUHJvZmlsZXIuZ2V0U2Vuc29ySW50ZXJmYWNlOiBzZW5zb3JJbnRlcmZhY2VPcHRpb25zIGFyZSBub3QgZGVmaW5lZCcpXG5cdFx0XHRcdH1cblx0XHRcdFx0b3B0aW9ucy5vdXRwdXRGaWxlUGF0aCA9IGNvbmZpZy5nZXRPdXREaXIoKS5qb2luKG9wdGlvbnMub3V0cHV0RmlsZVBhdGgpLnRvUGxhdGZvcm1TdHJpbmcoKVxuXHRcdFx0XHRyZXR1cm4gbmV3IFdpbmRvd3NTZW5zb3JJbnRlcmZhY2Uob3B0aW9ucylcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRsb2FkU2Vuc29ySW50ZXJmYWNlKCkge1xuXHRcdHRoaXMuX3NlbnNvckludGVyZmFjZSA9IFByb2ZpbGVyLmdldFNlbnNvckludGVyZmFjZSh0aGlzLmNvbmZpZylcblx0fVxuXG5cdHN0YXRpYyBhc3luYyBpbmplY3Qoc3ViT3V0cHV0RGlyPzogc3RyaW5nKTogUHJvbWlzZTxQcm9maWxlcj4ge1xuXHRcdGNvbnN0IHByb2ZpbGVyID0gbmV3IFByb2ZpbGVyKHN1Yk91dHB1dERpcilcblxuXHRcdGNvbnN0IHRpdGxlID0gbmV3IERhdGUoKS5nZXRUaW1lKCkudG9TdHJpbmcoKVxuXG5cdFx0Y29uc3QgZXhpdFJlc29sdmUgPSAoKSA9PiByZXNvbHZlKCdleGl0Jylcblx0XHRjb25zdCBzaWdJbnRSZXNvbHZlID0gKCkgPT4gcmVzb2x2ZSgnU0lHSU5UJylcblx0XHRjb25zdCBzaWdVc3IxUmVzb2x2ZSA9ICgpID0+IHJlc29sdmUoJ1NJR1VTUjEnKVxuXHRcdGNvbnN0IHNpZ1VzcjJSZXNvbHZlID0gKCkgPT4gcmVzb2x2ZSgnU0lHVVNSMicpXG5cblxuXHRcdGxldCBzdG9wcGVkID0gZmFsc2Vcblx0XHRhc3luYyBmdW5jdGlvbiByZXNvbHZlKG9yaWdpbjogc3RyaW5nKSB7XG5cdFx0XHRpZiAoIXN0b3BwZWQpIHtcblx0XHRcdFx0c3RvcHBlZCA9IHRydWVcblx0XHRcdFx0TG9nZ2VySGVscGVyLmxvZyhgKCR7QVBQX05BTUV9IFByb2ZpbGVyKSBGaW5pc2ggTWVhc3VyZW1lbnQsIHBsZWFzZSB3YWl0Li4uYClcblx0XHRcdFx0YXdhaXQgcHJvZmlsZXIuZmluaXNoKHRpdGxlKVxuXHRcdFx0XHRwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKCdleGl0JywgZXhpdFJlc29sdmUpXG5cdFx0XHRcdHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoJ1NJR0lOVCcsIHNpZ0ludFJlc29sdmUpXG5cdFx0XHRcdHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoJ1NJR1VTUjEnLCBzaWdVc3IxUmVzb2x2ZSlcblx0XHRcdFx0cHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcignU0lHVVNSMicsIHNpZ1VzcjJSZXNvbHZlKVxuXHRcdFx0XHRpZiAob3JpZ2luICE9PSAnZXhpdCcpIHtcblx0XHRcdFx0XHRwcm9jZXNzLmV4aXQoKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0TG9nZ2VySGVscGVyLmxvZyhgKCR7QVBQX05BTUV9IFByb2ZpbGVyKSBNZWFzdXJlbWVudCBzdGFydGVkYClcblx0XHRhd2FpdCBwcm9maWxlci5zdGFydCh0aXRsZSlcblxuXHRcdHByb2Nlc3Mub24oJ2V4aXQnLCBleGl0UmVzb2x2ZSlcblxuXHRcdC8vIC8vY2F0Y2hlcyBjdHJsK2MgZXZlbnRcblx0XHRwcm9jZXNzLm9uKCdTSUdJTlQnLCBzaWdJbnRSZXNvbHZlKVxuXG5cdFx0Ly8gLy8gY2F0Y2hlcyBcImtpbGwgcGlkXCIgKGZvciBleGFtcGxlOiBub2RlbW9uIHJlc3RhcnQpXG5cdFx0cHJvY2Vzcy5vbignU0lHVVNSMScsIHNpZ1VzcjFSZXNvbHZlKVxuXHRcdHByb2Nlc3Mub24oJ1NJR1VTUjInLCBzaWdVc3IyUmVzb2x2ZSlcblxuXHRcdHJldHVybiBwcm9maWxlclxuXHR9XG5cblx0YXN5bmMgc3RhcnRDYXB0dXJpbmdQcm9maWxlclRyYWNpbmdFdmVudHMoKSB7XG5cdFx0aWYgKHRoaXMuX3RyYWNlRXZlbnRTZXNzaW9uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignc3RhcnRDYXB0dXJpbmdQcm9maWxlclRyYWNpbmdFdmVudHM6IFRyYWNlIEV2ZW50IFNlc3Npb24gc2hvdWxkIG5vdCBhbHJlYWR5IGJlIGRlZmluZWQnKVxuXHRcdH1cblx0XHRjb25zdCBzZXNzaW9uID0gbmV3IFNlc3Npb24oKVxuXHRcdHRoaXMuX3RyYWNlRXZlbnRTZXNzaW9uID0gc2Vzc2lvblxuXHRcdHNlc3Npb24uY29ubmVjdCgpXG5cdFx0c2Vzc2lvbi5vbignTm9kZVRyYWNpbmcuZGF0YUNvbGxlY3RlZCcsIChjaHVuaykgPT4ge1xuXHRcdFx0Zm9yIChjb25zdCBldmVudCBvZiAoY2h1bmsucGFyYW1zLnZhbHVlIGFzIFRyYWNlRXZlbnRQYXJhbXNbXSkpIHtcblx0XHRcdFx0aWYgKGV2ZW50LnBpZCA9PT0gcHJvY2Vzcy5waWQgJiYgZXZlbnQuY2F0ID09PSAndjgnKSB7XG5cdFx0XHRcdFx0aWYgKGV2ZW50Lm5hbWUgPT09ICdDcHVQcm9maWxlcjo6U3RhcnRQcm9maWxpbmcnKSB7IC8vIGNhcHR1cmVkIHN0YXJ0IGV2ZW50IG9mIGNwdSBwcm9maWxlclxuXHRcdFx0XHRcdFx0dGhpcy5fcHJvZmlsZXJTdGFydFRpbWUgPSBldmVudC50cyBhcyBNaWNyb1NlY29uZHNfbnVtYmVyIC8vIHN0b3JlIGhpZ2ggcmVzb2x1dGlvbiBiZWdpbiB0aW1lXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSlcblx0XHRjb25zdCB0cmFjZUNvbmZpZyA9IHsgaW5jbHVkZWRDYXRlZ29yaWVzOiBbJ3Y4J10gfSAvLyBjb25maWcgdG8gY2FwdHVyZSB2OCdzIHRyYWNlIGV2ZW50c1xuXHRcdGF3YWl0IFRyYWNlRXZlbnRIZWxwZXIucG9zdChzZXNzaW9uLCAnTm9kZVRyYWNpbmcuc3RhcnQnLCB7IHRyYWNlQ29uZmlnIH0pIC8vIHN0YXJ0IHRyYWNlIGV2ZW50IGNhcHR1cmluZ1xuXHR9XG5cblx0YXN5bmMgc3RvcENhcHR1cmluZ1Byb2ZpbGVyVHJhY2luZ0V2ZW50cygpIHtcblx0XHRpZiAodGhpcy5fdHJhY2VFdmVudFNlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdzdG9wQ2FwdHVyaW5nUHJvZmlsZXJUcmFjaW5nRXZlbnRzOiBUcmFjZSBFdmVudCBTZXNzaW9uIHNob3VsZCBiZSBkZWZpbmVkJylcblx0XHR9XG5cdFx0YXdhaXQgVHJhY2VFdmVudEhlbHBlci5wb3N0KHRoaXMuX3RyYWNlRXZlbnRTZXNzaW9uLCAnTm9kZVRyYWNpbmcuc3RvcCcsIHVuZGVmaW5lZClcblx0XHR0aGlzLl90cmFjZUV2ZW50U2Vzc2lvbi5kaXNjb25uZWN0KClcblx0XHR0aGlzLl90cmFjZUV2ZW50U2Vzc2lvbiA9IHVuZGVmaW5lZFxuXHR9XG5cblx0YXN5bmMgZ2V0Q1BVUHJvZmlsZXJCZWdpblRpbWUoKTogUHJvbWlzZTxNaWNyb1NlY29uZHNfbnVtYmVyPiB7XG5cdFx0bGV0IHRyaWVzID0gMFxuXHRcdHdoaWxlICh0aGlzLl9wcm9maWxlclN0YXJ0VGltZSA9PT0gdW5kZWZpbmVkICYmIHRyaWVzIDwgMTApIHtcblx0XHRcdExvZ2dlckhlbHBlci5lcnJvcihgQ2Fubm90IGNhcHR1cmUgcHJvZmlsZXIgc3RhcnQgdGltZSBvbiB0cnk6ICR7dHJpZXMgKyAxfSwgdHJ5IGFnYWluIGFmdGVyIDEgc2Vjb25kYClcblx0XHRcdHRyaWVzICs9IDFcblx0XHRcdGF3YWl0IFRpbWVIZWxwZXIuc2xlZXAoMTAwMClcblx0XHR9XG5cdFx0aWYgKHRoaXMuX3Byb2ZpbGVyU3RhcnRUaW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGNhcHR1cmUgY3B1IHByb2ZpbGVycyBiZWdpbiB0aW1lIGFmdGVyICR7dHJpZXN9IHRyaWVzLCBtZWFzdXJlbWVudHMgZmFpbGVkYClcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2ZpbGVyU3RhcnRUaW1lXG5cdH1cblxuXHRhc3luYyBzdGFydCh0aXRsZTogc3RyaW5nLCBleGVjdXRpb25EZXRhaWxzPzogSVByb2plY3RSZXBvcnRFeGVjdXRpb25EZXRhaWxzKSB7XG5cdFx0Y29uc3QgcGVyZm9ybWFuY2UgPSBuZXcgUGVyZm9ybWFuY2VIZWxwZXIoKVxuXHRcdHBlcmZvcm1hbmNlLnN0YXJ0KCdQcm9maWxlci5zdGFydCcpXG5cblx0XHRjb25zdCBvdXRGaWxlUmVwb3J0ID0gdGhpcy5vdXRwdXRSZXBvcnRQYXRoKHRpdGxlKVxuXHRcdGNvbnN0IG91dERpciA9IG91dEZpbGVSZXBvcnQuZGlyTmFtZSgpXG5cblx0XHRwZXJmb3JtYW5jZS5zdGFydCgnUHJvZmlsZXIuc3RhcnQuY3JlYXRlT3V0RGlyJylcblx0XHRpZiAoIWZzLmV4aXN0c1N5bmMob3V0RGlyLnRvUGxhdGZvcm1TdHJpbmcoKSkpIHtcblx0XHRcdFBlcm1pc3Npb25IZWxwZXIubWtkaXJSZWN1cnNpdmVseVdpdGhVc2VyUGVybWlzc2lvbihvdXREaXIpXG5cdFx0fVxuXHRcdHBlcmZvcm1hbmNlLnN0b3AoJ1Byb2ZpbGVyLnN0YXJ0LmNyZWF0ZU91dERpcicpXG5cblx0XHRwZXJmb3JtYW5jZS5zdGFydCgnUHJvZmlsZXIuc3RhcnQuc2VlZFJhbmRvbScpXG5cdFx0Y29uc3QgbWF0aFJhbmRvbVNlZWQgPSB0aGlzLmNvbmZpZy5nZXRTZWVkRm9yTWF0aFJhbmRvbSgpXG5cdFx0aWYgKG1hdGhSYW5kb21TZWVkKSB7XG5cdFx0XHRzZWVkcmFuZG9tKG1hdGhSYW5kb21TZWVkLCB7IGdsb2JhbDogdHJ1ZSB9KVxuXHRcdH1cblx0XHRwZXJmb3JtYW5jZS5zdG9wKCdQcm9maWxlci5zdGFydC5zZWVkUmFuZG9tJylcblxuXHRcdGlmIChleGVjdXRpb25EZXRhaWxzKSB7XG5cdFx0XHR0aGlzLmV4ZWN1dGlvbkRldGFpbHMgPSBleGVjdXRpb25EZXRhaWxzXG5cdFx0fSBlbHNlIHtcblx0XHRcdHBlcmZvcm1hbmNlLnN0YXJ0KCdQcm9maWxlci5zdGFydC5yZXNvbHZlRXhlY3V0aW9uRGV0YWlscycpXG5cdFx0XHR0aGlzLmV4ZWN1dGlvbkRldGFpbHMgPSBhd2FpdCBFeGVjdXRpb25EZXRhaWxzLnJlc29sdmVFeGVjdXRpb25EZXRhaWxzKClcblx0XHRcdHBlcmZvcm1hbmNlLnN0b3AoJ1Byb2ZpbGVyLnN0YXJ0LnJlc29sdmVFeGVjdXRpb25EZXRhaWxzJylcblx0XHR9XG5cdFx0cGVyZm9ybWFuY2Uuc3RhcnQoJ1Byb2ZpbGVyLnN0YXJ0LlY4UHJvZmlsZXIuc2V0R2VuZXJhdGVUeXBlJylcblx0XHRWOFByb2ZpbGVyLnNldEdlbmVyYXRlVHlwZSgxKSAvLyBtdXN0IGJlIHNldCB0byBnZW5lcmF0ZSBuZXcgY3B1cHJvZmlsZSBmb3JtYXRcblx0XHRwZXJmb3JtYW5jZS5zdG9wKCdQcm9maWxlci5zdGFydC5WOFByb2ZpbGVyLnNldEdlbmVyYXRlVHlwZScpXG5cblx0XHRwZXJmb3JtYW5jZS5zdGFydCgnUHJvZmlsZXIuc3RhcnQuZ2V0VjhDUFVTYW1wbGluZ0ludGVydmFsJylcblx0XHRWOFByb2ZpbGVyLnNldFNhbXBsaW5nSW50ZXJ2YWwodGhpcy5jb25maWcuZ2V0VjhDUFVTYW1wbGluZ0ludGVydmFsKCkpIC8vIHNldHMgdGhlIHNhbXBsaW5nIGludGVydmFsIGluIG1pY3Jvc2Vjb25kc1xuXHRcdHBlcmZvcm1hbmNlLnN0b3AoJ1Byb2ZpbGVyLnN0YXJ0LmdldFY4Q1BVU2FtcGxpbmdJbnRlcnZhbCcpXG5cblx0XHRwZXJmb3JtYW5jZS5zdGFydCgnUHJvZmlsZXIuc3RhcnQuc3RhcnRDYXB0dXJpbmdQcm9maWxlclRyYWNpbmdFdmVudHMnKVxuXHRcdGF3YWl0IHRoaXMuc3RhcnRDYXB0dXJpbmdQcm9maWxlclRyYWNpbmdFdmVudHMoKVxuXHRcdHBlcmZvcm1hbmNlLnN0b3AoJ1Byb2ZpbGVyLnN0YXJ0LnN0YXJ0Q2FwdHVyaW5nUHJvZmlsZXJUcmFjaW5nRXZlbnRzJylcblxuXHRcdHBlcmZvcm1hbmNlLnN0YXJ0KCdQcm9maWxlci5zdGFydC5zZW5zb3JJbnRlcmZhY2UuY291bGRCZUV4ZWN1dGVkJylcblx0XHRpZiAodGhpcy5fc2Vuc29ySW50ZXJmYWNlICE9PSB1bmRlZmluZWQgJiYgIWF3YWl0IHRoaXMuX3NlbnNvckludGVyZmFjZS5jb3VsZEJlRXhlY3V0ZWQoKSkge1xuXHRcdFx0Ly8gcmVtb3ZlIHNlbnNvciBpbnRlcmZhY2UgZnJvbSBleGVjdXRpb24gZGV0YWlscyBzaW5jZSBpdCBjYW5ub3QgYmUgZXhlY3V0ZWRcblx0XHRcdHRoaXMuZXhlY3V0aW9uRGV0YWlscy5ydW5UaW1lT3B0aW9ucy5zZW5zb3JJbnRlcmZhY2UgPSB1bmRlZmluZWRcblx0XHRcdExvZ2dlckhlbHBlci53YXJuKGAoJHtBUFBfTkFNRX0gUHJvZmlsZXIpIFdhcm5pbmc6IGAgKyBcblx0XHRcdFx0J1NlbnNvciBJbnRlcmZhY2UgY2FuIG5vdCBiZSBleGVjdXRlZCwgbm8gZW5lcmd5IG1lYXN1cmVtZW50cyB3aWxsIGJlIGNvbGxlY3RlZCcpXG5cdFx0fVxuXHRcdHBlcmZvcm1hbmNlLnN0b3AoJ1Byb2ZpbGVyLnN0YXJ0LnNlbnNvckludGVyZmFjZS5jb3VsZEJlRXhlY3V0ZWQnKVxuXG5cdFx0cGVyZm9ybWFuY2Uuc3RhcnQoJ1Byb2ZpbGVyLnN0YXJ0LnNlbnNvckludGVyZmFjZS5zdGFydFByb2ZpbGluZycpXG5cdFx0YXdhaXQgdGhpcy5fc2Vuc29ySW50ZXJmYWNlPy5zdGFydFByb2ZpbGluZygpXG5cdFx0cGVyZm9ybWFuY2Uuc3RvcCgnUHJvZmlsZXIuc3RhcnQuc2Vuc29ySW50ZXJmYWNlLnN0YXJ0UHJvZmlsaW5nJylcblxuXHRcdC8vIHRpdGxlIC0gaGFuZGxlIHRvIHN0b3AgcHJvZmlsZSBhZ2FpblxuXHRcdC8vIHJlY3NhbXBlbHMoYm9vbGVhbikgLSByZWNvcmQgc2FtcGxlcywgaWYgZmFsc2Ugbm8gY3B1IHRpbWVzIHdpbGwgYmUgY2FwdHVyZWRcblx0XHRwZXJmb3JtYW5jZS5zdGFydCgnUHJvZmlsZXIuc3RhcnQuVjhQcm9maWxlci5zdGFydFByb2ZpbGluZycpXG5cdFx0VjhQcm9maWxlci5zdGFydFByb2ZpbGluZyh0aXRsZSwgdHJ1ZSlcblx0XHRwZXJmb3JtYW5jZS5zdG9wKCdQcm9maWxlci5zdGFydC5WOFByb2ZpbGVyLnN0YXJ0UHJvZmlsaW5nJylcblx0XHRwZXJmb3JtYW5jZS5zdGFydCgnUHJvZmlsZXIuc3RhcnQuaW5zcGVjdG9ySGVscGVyLmNvbm5lY3QnKVxuXHRcdGF3YWl0IHRoaXMuX2luc3BlY3RvckhlbHBlci5jb25uZWN0KClcblx0XHR0aGlzLl9pbnNwZWN0b3JIZWxwZXIubGlzdGVuKClcblx0XHRwZXJmb3JtYW5jZS5zdG9wKCdQcm9maWxlci5zdGFydC5pbnNwZWN0b3JIZWxwZXIuY29ubmVjdCcpXG5cdFx0cGVyZm9ybWFuY2Uuc3RvcCgnUHJvZmlsZXIuc3RhcnQnKVxuXHRcdHBlcmZvcm1hbmNlLnByaW50UmVwb3J0KCdQcm9maWxlci5zdGFydCcpXG5cdFx0cGVyZm9ybWFuY2UuZXhwb3J0QW5kU3VtKHRoaXMub3V0cHV0RGlyKCkuam9pbigncGVyZm9ybWFuY2UuanNvbicpKVxuXHR9XG5cblx0b3V0cHV0RGlyKCk6IFVuaWZpZWRQYXRoIHtcblx0XHRyZXR1cm4gdGhpcy5jb25maWcuZ2V0T3V0RGlyKCkuam9pbih0aGlzLnN1Yk91dHB1dERpciB8fCAnJylcblx0fVxuXG5cdG91dHB1dFJlcG9ydFBhdGgodGl0bGU6IHN0cmluZyk6IFVuaWZpZWRQYXRoIHtcblx0XHRyZXR1cm4gdGhpcy5vdXRwdXREaXIoKS5qb2luKGAke3RpdGxlfS5vYWtgKVxuXHR9XG5cblx0b3V0cHV0TWV0cmljQ29sbGVjdGlvblBhdGgodGl0bGU6IHN0cmluZyk6IFVuaWZpZWRQYXRoIHtcblx0XHRyZXR1cm4gdGhpcy5vdXRwdXREaXIoKS5qb2luKGAke3RpdGxlfS5tY29sbGVjdGlvbmApXG5cdH1cblxuXHRvdXRwdXRQcm9maWxlUGF0aCh0aXRsZTogc3RyaW5nKTogVW5pZmllZFBhdGgge1xuXHRcdHJldHVybiB0aGlzLm91dHB1dERpcigpLmpvaW4oYCR7dGl0bGV9LmNwdXByb2ZpbGVgKVxuXHR9XG5cblx0b3V0cHV0SW5zcGVjdG9ySGVscGVyUGF0aCh0aXRsZTogc3RyaW5nKTogVW5pZmllZFBhdGgge1xuXHRcdHJldHVybiB0aGlzLm91dHB1dERpcigpLmpvaW4oYCR7dGl0bGV9Lmluc3BlY3Rvci5qc29uYClcblx0fVxuXG5cdGFzeW5jIGZpbmlzaCh0aXRsZTogc3RyaW5nLCBoaWdoUmVzb2x1dGlvblN0b3BUaW1lPzogTmFub1NlY29uZHNfQmlnSW50KTogUHJvbWlzZTxQcm9qZWN0UmVwb3J0PiB7XG5cdFx0Y29uc3QgcGVyZm9ybWFuY2UgPSBuZXcgUGVyZm9ybWFuY2VIZWxwZXIoKVxuXHRcdFxuXHRcdHBlcmZvcm1hbmNlLnN0YXJ0KCdQcm9maWxlci5maW5pc2gnKVxuXHRcdGlmICh0aGlzLmV4ZWN1dGlvbkRldGFpbHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQcm9maWxlci5maW5pc2g6IFByb2ZpbGVyIHdhcyBub3Qgc3RhcnRlZCB5ZXQnKVxuXHRcdH1cblx0XHRpZiAoaGlnaFJlc29sdXRpb25TdG9wVGltZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLmV4ZWN1dGlvbkRldGFpbHMuaGlnaFJlc29sdXRpb25TdG9wVGltZSA9IGhpZ2hSZXNvbHV0aW9uU3RvcFRpbWUudG9TdHJpbmcoKVxuXHRcdH1cblxuXHRcdHBlcmZvcm1hbmNlLnN0YXJ0KCdQcm9maWxlci5maW5pc2guc3RvcFByb2ZpbGluZycpXG5cdFx0Y29uc3QgcHJvZmlsZSA9IFY4UHJvZmlsZXIuc3RvcFByb2ZpbGluZyh0aXRsZSlcblx0XHRwZXJmb3JtYW5jZS5zdG9wKCdQcm9maWxlci5maW5pc2guc3RvcFByb2ZpbGluZycpXG5cblx0XHRwZXJmb3JtYW5jZS5zdGFydCgnUHJvZmlsZXIuZmluaXNoLnN0b3BDYXB0dXJpbmdQcm9maWxlclRyYWNpbmdFdmVudHMnKVxuXHRcdHRoaXMuc3RvcENhcHR1cmluZ1Byb2ZpbGVyVHJhY2luZ0V2ZW50cygpXG5cdFx0cGVyZm9ybWFuY2Uuc3RvcCgnUHJvZmlsZXIuZmluaXNoLnN0b3BDYXB0dXJpbmdQcm9maWxlclRyYWNpbmdFdmVudHMnKVxuXG5cdFx0cGVyZm9ybWFuY2Uuc3RhcnQoJ1Byb2ZpbGVyLmZpbmlzaC5zZW5zb3JJbnRlcmZhY2Uuc3RvcFByb2ZpbGluZycpXG5cdFx0YXdhaXQgdGhpcy5fc2Vuc29ySW50ZXJmYWNlPy5zdG9wUHJvZmlsaW5nKClcblx0XHRwZXJmb3JtYW5jZS5zdG9wKCdQcm9maWxlci5maW5pc2guc2Vuc29ySW50ZXJmYWNlLnN0b3BQcm9maWxpbmcnKVxuXG5cdFx0Y29uc3QgQ1BVUHJvZmlsZXJCZWdpblRpbWUgPSBCaWdJbnQoYXdhaXQgdGhpcy5nZXRDUFVQcm9maWxlckJlZ2luVGltZSgpKSAqIEJpZ0ludCgxMDAwKSBhcyBOYW5vU2Vjb25kc19CaWdJbnRcblx0XHR0aGlzLmV4ZWN1dGlvbkRldGFpbHMuaGlnaFJlc29sdXRpb25CZWdpblRpbWUgPSBDUFVQcm9maWxlckJlZ2luVGltZS50b1N0cmluZygpXG5cblx0XHRjb25zdCBleHBvcnREYXRhID0ge1xuXHRcdFx0bm9kZXM6IHByb2ZpbGUubm9kZXMsXG5cdFx0XHRzdGFydFRpbWU6IHByb2ZpbGUuc3RhcnRUaW1lLFxuXHRcdFx0ZW5kVGltZTogcHJvZmlsZS5lbmRUaW1lLFxuXHRcdFx0c2FtcGxlczogcHJvZmlsZS5zYW1wbGVzLFxuXHRcdFx0dGltZURlbHRhczogcHJvZmlsZS50aW1lRGVsdGFzXG5cdFx0fVxuXHRcdGxldCB0cmFuc2Zvcm1lckFkYXB0ZXIgPSB1bmRlZmluZWRcblx0XHRpZiAodGhpcy5vcHRpb25zPy50cmFuc2Zvcm1lckFkYXB0ZXIgPT09ICd0cy1qZXN0Jykge1xuXHRcdFx0aWYgKCF0aGlzLm9wdGlvbnMuamVzdEFkYXB0ZXIuY29uZmlnIHx8ICF0aGlzLm9wdGlvbnMuamVzdEFkYXB0ZXIuY29udGV4dCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIHRoZSBKZXN0RW52aXJvbm1lbnRDb25maWcgYW5kIEVudmlyb25tZW50Q29udGV4dCBpbiB0aGUgcHJvZmlsZXIgb3B0aW9ucyBhdCBvcHRpb25zLmplc3RBZGFwdGVyJylcblx0XHRcdH1cblx0XHRcdHRyYW5zZm9ybWVyQWRhcHRlciA9IG5ldyBKZXN0QWRhcHRlcihcblx0XHRcdFx0dGhpcy5vcHRpb25zLmplc3RBZGFwdGVyLmNvbmZpZyxcblx0XHRcdFx0dGhpcy5vcHRpb25zLmplc3RBZGFwdGVyLmNvbnRleHRcblx0XHRcdClcblx0XHRcdGlmICghZnMuZXhpc3RzU3luYyh0aGlzLm91dHB1dERpcigpLnRvUGxhdGZvcm1TdHJpbmcoKSkpIHtcblx0XHRcdFx0UGVybWlzc2lvbkhlbHBlci5ta2RpclJlY3Vyc2l2ZWx5V2l0aFVzZXJQZXJtaXNzaW9uKHRoaXMub3V0cHV0RGlyKCkpXG5cdFx0XHR9XG5cdFx0XHRwZXJmb3JtYW5jZS5zdGFydCgnUHJvZmlsZXIuZmluaXNoLmV4cG9ydEplc3RDb25maWcnKVxuXHRcdFx0UGVybWlzc2lvbkhlbHBlci53cml0ZUZpbGVXaXRoVXNlclBlcm1pc3Npb24oXG5cdFx0XHRcdHRoaXMub3V0cHV0RGlyKCkuam9pbignamVzdC5jb25maWcnKS50b1BsYXRmb3JtU3RyaW5nKCksXG5cdFx0XHRcdEpTT04uc3RyaW5naWZ5KHtcblx0XHRcdFx0XHRjb25maWc6IHRoaXMub3B0aW9ucy5qZXN0QWRhcHRlci5jb25maWcsXG5cdFx0XHRcdFx0Y29udGV4dDogdGhpcy5vcHRpb25zLmplc3RBZGFwdGVyLmNvbnRleHRcblx0XHRcdFx0fSlcblx0XHRcdClcblx0XHRcdHBlcmZvcm1hbmNlLnN0b3AoJ1Byb2ZpbGVyLmZpbmlzaC5leHBvcnRKZXN0Q29uZmlnJylcblx0XHR9XG5cdFx0Y29uc3Qgb3V0RmlsZUNQVVByb2ZpbGUgPSB0aGlzLm91dHB1dFByb2ZpbGVQYXRoKHRpdGxlKVxuXHRcdGNvbnN0IG91dEZpbGVJbnNwZWN0b3JIZWxwZXIgPSB0aGlzLm91dHB1dEluc3BlY3RvckhlbHBlclBhdGgodGl0bGUpXG5cdFx0Y29uc3Qgb3V0RmlsZVJlcG9ydCA9IHRoaXMub3V0cHV0UmVwb3J0UGF0aCh0aXRsZSlcblx0XHRjb25zdCBvdXRGaWxlTWV0cmljQ29sbGVjdGlvbiA9IHRoaXMub3V0cHV0TWV0cmljQ29sbGVjdGlvblBhdGgodGl0bGUpXG5cdFx0aWYgKHRoaXMuY29uZmlnLnNob3VsZEV4cG9ydFY4UHJvZmlsZSgpKSB7XG5cdFx0XHRwZXJmb3JtYW5jZS5zdGFydCgnUHJvZmlsZXIuZmluaXNoLmV4cG9ydFY4UHJvZmlsZScpXG5cdFx0XHRQZXJtaXNzaW9uSGVscGVyLndyaXRlRmlsZVdpdGhVc2VyUGVybWlzc2lvbihcblx0XHRcdFx0b3V0RmlsZUNQVVByb2ZpbGUudG9QbGF0Zm9ybVN0cmluZygpLFxuXHRcdFx0XHRKU09OLnN0cmluZ2lmeShleHBvcnREYXRhLCBudWxsLCAyKSxcblx0XHRcdClcblx0XHRcdHBlcmZvcm1hbmNlLnN0b3AoJ1Byb2ZpbGVyLmZpbmlzaC5leHBvcnRWOFByb2ZpbGUnKVxuXHRcdH1cblx0XHRwZXJmb3JtYW5jZS5zdGFydCgnUHJvZmlsZXIuZmluaXNoLnNlbnNvckludGVyZmFjZS5yZWFkU2Vuc29yVmFsdWVzJylcblx0XHRjb25zdCBtZXRyaWNzRGF0YUNvbGxlY3Rpb24gPSBhd2FpdCB0aGlzLl9zZW5zb3JJbnRlcmZhY2U/LnJlYWRTZW5zb3JWYWx1ZXMocHJvY2Vzcy5waWQpXG5cdFx0cGVyZm9ybWFuY2Uuc3RvcCgnUHJvZmlsZXIuZmluaXNoLnNlbnNvckludGVyZmFjZS5yZWFkU2Vuc29yVmFsdWVzJylcblxuXHRcdGNvbnN0IHJvb3REaXIgPSB0aGlzLmNvbmZpZy5nZXRSb290RGlyKClcblx0XHRjb25zdCByZXBvcnQgPSBuZXcgUHJvamVjdFJlcG9ydCh0aGlzLmV4ZWN1dGlvbkRldGFpbHMsIFJlcG9ydEtpbmQubWVhc3VyZW1lbnQpXG5cdFx0aWYgKHRoaXMuY29uZmlnLnNob3VsZEV4cG9ydFNlbnNvckludGVyZmFjZURhdGEoKSkge1xuXHRcdFx0aWYgKG1ldHJpY3NEYXRhQ29sbGVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHBlcmZvcm1hbmNlLnN0YXJ0KCdQcm9maWxlci5maW5pc2guZXhwb3J0TWV0cmljc0RhdGFDb2xsZWN0aW9uJylcblx0XHRcdFx0bWV0cmljc0RhdGFDb2xsZWN0aW9uLnN0b3JlVG9GaWxlKG91dEZpbGVNZXRyaWNDb2xsZWN0aW9uKVxuXHRcdFx0XHRwZXJmb3JtYW5jZS5zdG9wKCdQcm9maWxlci5maW5pc2guZXhwb3J0TWV0cmljc0RhdGFDb2xsZWN0aW9uJylcblx0XHRcdH1cblx0XHR9XG5cblx0XHRwZXJmb3JtYW5jZS5zdGFydCgnUHJvZmlsZXIuZmluaXNoLmluc2VydENQVVByb2ZpbGUnKVxuXHRcdGF3YWl0IHJlcG9ydC5pbnNlcnRDUFVQcm9maWxlKFxuXHRcdFx0cm9vdERpcixcblx0XHRcdHByb2ZpbGUsXG5cdFx0XHR0aGlzLl9pbnNwZWN0b3JIZWxwZXIsXG5cdFx0XHRtZXRyaWNzRGF0YUNvbGxlY3Rpb25cblx0XHQpXG5cdFx0cGVyZm9ybWFuY2Uuc3RvcCgnUHJvZmlsZXIuZmluaXNoLmluc2VydENQVVByb2ZpbGUnKVxuXG5cdFx0cGVyZm9ybWFuY2Uuc3RhcnQoJ1Byb2ZpbGVyLmZpbmlzaC5pbnNwZWN0b3JIZWxwZXIuZGlzY29ubmVjdCcpXG5cdFx0YXdhaXQgdGhpcy5faW5zcGVjdG9ySGVscGVyLmRpc2Nvbm5lY3QoKVxuXHRcdHBlcmZvcm1hbmNlLnN0b3AoJ1Byb2ZpbGVyLmZpbmlzaC5pbnNwZWN0b3JIZWxwZXIuZGlzY29ubmVjdCcpXG5cblx0XHRpZiAodGhpcy5jb25maWcuc2hvdWxkRXhwb3J0VjhQcm9maWxlKCkpIHtcblx0XHRcdHBlcmZvcm1hbmNlLnN0YXJ0KCdQcm9maWxlci5maW5pc2guZXhwb3J0SW5zcGVjdG9ySGVscGVyJylcblx0XHRcdFBlcm1pc3Npb25IZWxwZXIud3JpdGVGaWxlV2l0aFVzZXJQZXJtaXNzaW9uKFxuXHRcdFx0XHRvdXRGaWxlSW5zcGVjdG9ySGVscGVyLnRvUGxhdGZvcm1TdHJpbmcoKSxcblx0XHRcdFx0SlNPTi5zdHJpbmdpZnkodGhpcy5faW5zcGVjdG9ySGVscGVyLCBudWxsLCAyKSxcblx0XHRcdClcblx0XHRcdHBlcmZvcm1hbmNlLnN0b3AoJ1Byb2ZpbGVyLmZpbmlzaC5leHBvcnRJbnNwZWN0b3JIZWxwZXInKVxuXHRcdH1cblxuXHRcdHBlcmZvcm1hbmNlLnN0YXJ0KCdQcm9maWxlci5maW5pc2gudHJhY2tVbmNvbW1pdHRlZEZpbGVzJylcblx0XHRhd2FpdCByZXBvcnQudHJhY2tVbmNvbW1pdHRlZEZpbGVzKHJvb3REaXIpXG5cdFx0cGVyZm9ybWFuY2Uuc3RvcCgnUHJvZmlsZXIuZmluaXNoLnRyYWNrVW5jb21taXR0ZWRGaWxlcycpXG5cblx0XHRpZiAodGhpcy5jb25maWcuc2hvdWxkRXhwb3J0UmVwb3J0KCkpIHtcblx0XHRcdHBlcmZvcm1hbmNlLnN0YXJ0KCdQcm9maWxlci5maW5pc2guZXhwb3J0UmVwb3J0Jylcblx0XHRcdHJlcG9ydC5zdG9yZVRvRmlsZShvdXRGaWxlUmVwb3J0LCAnYmluJywgdGhpcy5jb25maWcpXG5cdFx0XHRwZXJmb3JtYW5jZS5zdG9wKCdQcm9maWxlci5maW5pc2guZXhwb3J0UmVwb3J0Jylcblx0XHR9XG5cblx0XHRpZiAoYXdhaXQgcmVwb3J0LnNob3VsZEJlU3RvcmVkSW5SZWdpc3RyeSgpKSB7XG5cdFx0XHRhd2FpdCByZXBvcnQudXBsb2FkVG9SZWdpc3RyeSh0aGlzLmNvbmZpZylcblx0XHR9XG5cdFx0cGVyZm9ybWFuY2Uuc3RvcCgnUHJvZmlsZXIuZmluaXNoJylcblx0XHRwZXJmb3JtYW5jZS5wcmludFJlcG9ydCgnUHJvZmlsZXIuZmluaXNoJylcblx0XHRwZXJmb3JtYW5jZS5leHBvcnRBbmRTdW0odGhpcy5vdXRwdXREaXIoKS5qb2luKCdwZXJmb3JtYW5jZS5qc29uJykpXG5cblx0XHRyZXR1cm4gcmVwb3J0XG5cdH1cbn1cbiJdfQ==",
    "861": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.V8Profiler = void 0;\nconst profiler_core_1 = require(\"@oaklean/profiler-core\");\nconst WEBPACK_URL_REGEX = /webpack-internal:\\/\\/(.+?[^/]\\/)([^?]+)(.*)$/;\nfunction parseWebpackSourceMapUrl(url) {\n    const matches = WEBPACK_URL_REGEX.exec(url);\n    if (matches && matches.length > 2) {\n        const module = matches[1];\n        const filePath = matches[2];\n        return {\n            module,\n            filePath\n        };\n    }\n    return null;\n}\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst v8Profiler = require('v8-profiler-next');\nclass V8Profiler {\n    static startProfiling(name, recsamples, mode) {\n        v8Profiler.startProfiling(name, recsamples, mode);\n    }\n    static stopProfiling(name) {\n        const profile = v8Profiler.stopProfiling(name);\n        V8Profiler.cleanUpProfile(profile);\n        V8Profiler.unifyProfile(profile);\n        return profile;\n    }\n    static setGenerateType(type) {\n        v8Profiler.setGenerateType(type);\n    }\n    static setSamplingInterval(num) {\n        v8Profiler.setSamplingInterval(num);\n    }\n    /**\n     * Unifies the V8 Profile to ensure compatibility between linux / mac / windows\n     * All filePaths are converted to unix paths\n     *\n     * @param profile\n     */\n    static unifyProfile(profile) {\n        for (const node of profile.nodes) {\n            if (node.callFrame.url !== '' && !node.callFrame.url.startsWith('node:')) {\n                if (node.callFrame.url.startsWith('file://')) {\n                    node.callFrame.url = node.callFrame.url.slice(7);\n                }\n                if (node.callFrame.url.startsWith('webpack-internal://')) {\n                    const match = parseWebpackSourceMapUrl(node.callFrame.url);\n                    if (match !== null) {\n                        node.callFrame.url = match.filePath;\n                        console.log({\n                            id: node.id,\n                            module: match.module,\n                            url: match.filePath,\n                            line: node.callFrame.lineNumber,\n                            col: node.callFrame.columnNumber\n                        });\n                    }\n                }\n                node.callFrame.url = new profiler_core_1.UnifiedPath(node.callFrame.url).toString();\n            }\n        }\n    }\n    // Method to fix accumulated errors in cpu profiles caused by negative timeDelta\n    // https://github.com/jlfwong/speedscope/blob/main/src/import/chrome.ts\n    // https://github.com/jlfwong/speedscope/pull/305\n    static cleanUpProfile(profile) {\n        if (profile.samples === undefined || profile.timeDeltas === undefined) {\n            throw new Error('V8Profiler.cleanUpProfile: profile format is not complete');\n        }\n        const sampleTimes = [];\n        // The first delta is relative to the profile startTime.\n        // Ref: https://github.com/v8/v8/blob/44bd8fd7/src/inspector/js_protocol.json#L1485\n        let elapsed = profile.timeDeltas[0];\n        // Prevents negative time deltas from causing bad data. See\n        // https://github.com/jlfwong/speedscope/pull/305 for details.\n        let lastValidElapsed = elapsed;\n        // The chrome CPU profile format doesn't collapse identical samples. We'll do that\n        // here to save a ton of work later doing mergers.\n        for (let i = 0; i < profile.samples.length; i++) {\n            if (elapsed < lastValidElapsed) {\n                sampleTimes.push(lastValidElapsed);\n            }\n            else {\n                sampleTimes.push(elapsed);\n                lastValidElapsed = elapsed;\n            }\n            if (i === profile.samples.length - 1) {\n                if (elapsed < lastValidElapsed) {\n                    sampleTimes.push(lastValidElapsed);\n                }\n                else {\n                    sampleTimes.push(elapsed);\n                    lastValidElapsed = elapsed;\n                }\n            }\n            else {\n                const timeDelta = profile.timeDeltas[i + 1];\n                elapsed += timeDelta;\n            }\n        }\n        let latest = sampleTimes[0];\n        const timeDeltas = [latest];\n        for (let i = 1; i < sampleTimes.length - 1; i++) {\n            const delta = sampleTimes[i] - latest;\n            timeDeltas.push(delta);\n            latest = sampleTimes[i];\n        }\n        profile.timeDeltas = timeDeltas;\n    }\n}\nexports.V8Profiler = V8Profiler;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2theW1ha293c2t5L0RvY3VtZW50cy9IaXRhYmlzL0N1cnJlbnQtV29ya3NwYWNlcy9HcmVlbklUL09ha2xlYW4vcGFja2FnZXMvcHJvZmlsZXIvc3JjL21vZGVsL1Y4UHJvZmlsZXIudHMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYXltYWtvd3NreS9Eb2N1bWVudHMvSGl0YWJpcy9DdXJyZW50LVdvcmtzcGFjZXMvR3JlZW5JVC9PYWtsZWFuL3BhY2thZ2VzL3Byb2ZpbGVyL3NyYy9tb2RlbC9WOFByb2ZpbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUdBLDBEQUF5RTtBQUV6RSxNQUFNLGlCQUFpQixHQUFHLDhDQUE4QyxDQUFBO0FBRXhFLFNBQVMsd0JBQXdCLENBQUMsR0FBVztJQUM1QyxNQUFNLE9BQU8sR0FBRyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUE7SUFDM0MsSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUNuQyxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUE7UUFDekIsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFBO1FBQzNCLE9BQU87WUFDTixNQUFNO1lBQ04sUUFBUTtTQUNSLENBQUE7SUFDRixDQUFDO0lBQ0QsT0FBTyxJQUFJLENBQUE7QUFDWixDQUFDO0FBRUQsOERBQThEO0FBQzlELE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFBO0FBRTlDLE1BQWEsVUFBVTtJQUN0QixNQUFNLENBQUMsY0FBYyxDQUFDLElBQVksRUFBRSxVQUFvQixFQUFFLElBQVk7UUFDckUsVUFBVSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFBO0lBQ2xELENBQUM7SUFFRCxNQUFNLENBQUMsYUFBYSxDQUFDLElBQWE7UUFDakMsTUFBTSxPQUFPLEdB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QyxDQUFBO1FBQ3hCLENBQUM7UUFFRCxPQUFPLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQTtJQUNoQyxDQUFDO0NBQ0Q7QUFyR0QsZ0NBcUdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnXG5cbmltcG9ydCB0eXBlIHsgUHJvdG9jb2wgYXMgQ2RwIH0gZnJvbSAnZGV2dG9vbHMtcHJvdG9jb2wnXG5pbXBvcnQgeyBNaWNyb1NlY29uZHNfbnVtYmVyLCBVbmlmaWVkUGF0aCB9IGZyb20gJ0BvYWtsZWFuL3Byb2ZpbGVyLWNvcmUnXG5cbmNvbnN0IFdFQlBBQ0tfVVJMX1JFR0VYID0gL3dlYnBhY2staW50ZXJuYWw6XFwvXFwvKC4rP1teL11cXC8pKFteP10rKSguKikkL1xuXG5mdW5jdGlvbiBwYXJzZVdlYnBhY2tTb3VyY2VNYXBVcmwodXJsOiBzdHJpbmcpIHtcblx0Y29uc3QgbWF0Y2hlcyA9IFdFQlBBQ0tfVVJMX1JFR0VYLmV4ZWModXJsKVxuXHRpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDIpIHtcblx0XHRjb25zdCBtb2R1bGUgPSBtYXRjaGVzWzFdXG5cdFx0Y29uc3QgZmlsZVBhdGggPSBtYXRjaGVzWzJdXG5cdFx0cmV0dXJuIHtcblx0XHRcdG1vZHVsZSxcblx0XHRcdGZpbGVQYXRoXG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsXG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG5jb25zdCB2OFByb2ZpbGVyID0gcmVxdWlyZSgndjgtcHJvZmlsZXItbmV4dCcpXG5cbmV4cG9ydCBjbGFzcyBWOFByb2ZpbGVyIHtcblx0c3RhdGljIHN0YXJ0UHJvZmlsaW5nKG5hbWU6IHN0cmluZywgcmVjc2FtcGxlcz86IGJvb2xlYW4sIG1vZGU/OiAwIHwgMSkgOiB2b2lkIHtcblx0XHR2OFByb2ZpbGVyLnN0YXJ0UHJvZmlsaW5nKG5hbWUsIHJlY3NhbXBsZXMsIG1vZGUpXG5cdH1cblxuXHRzdGF0aWMgc3RvcFByb2ZpbGluZyhuYW1lPzogc3RyaW5nKTogQ2RwLlByb2ZpbGVyLlByb2ZpbGUge1xuXHRcdGNvbnN0IHByb2ZpbGUgPSB2OFByb2ZpbGVyLnN0b3BQcm9maWxpbmcobmFtZSlcblx0XHRWOFByb2ZpbGVyLmNsZWFuVXBQcm9maWxlKHByb2ZpbGUpXG5cdFx0VjhQcm9maWxlci51bmlmeVByb2ZpbGUocHJvZmlsZSlcblx0XHRyZXR1cm4gcHJvZmlsZVxuXHR9XG5cblx0c3RhdGljIHNldEdlbmVyYXRlVHlwZSh0eXBlOiAwIHwgMSkge1xuXHRcdHY4UHJvZmlsZXIuc2V0R2VuZXJhdGVUeXBlKHR5cGUpXG5cdH1cblxuXHRzdGF0aWMgc2V0U2FtcGxpbmdJbnRlcnZhbChudW06IE1pY3JvU2Vjb25kc19udW1iZXIpIHtcblx0XHR2OFByb2ZpbGVyLnNldFNhbXBsaW5nSW50ZXJ2YWwobnVtKVxuXHR9XG5cblx0LyoqXG5cdCAqIFVuaWZpZXMgdGhlIFY4IFByb2ZpbGUgdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkgYmV0d2VlbiBsaW51eCAvIG1hYyAvIHdpbmRvd3Ncblx0ICogQWxsIGZpbGVQYXRocyBhcmUgY29udmVydGVkIHRvIHVuaXggcGF0aHNcblx0ICogXG5cdCAqIEBwYXJhbSBwcm9maWxlIFxuXHQgKi9cblx0c3RhdGljIHVuaWZ5UHJvZmlsZShwcm9maWxlOiBDZHAuUHJvZmlsZXIuUHJvZmlsZSkge1xuXHRcdGZvciAoY29uc3Qgbm9kZSBvZiBwcm9maWxlLm5vZGVzKSB7XG5cdFx0XHRpZiAobm9kZS5jYWxsRnJhbWUudXJsICE9PSAnJyAmJiAhbm9kZS5jYWxsRnJhbWUudXJsLnN0YXJ0c1dpdGgoJ25vZGU6JykpIHtcblx0XHRcdFx0aWYgKG5vZGUuY2FsbEZyYW1lLnVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykpIHtcblx0XHRcdFx0XHRub2RlLmNhbGxGcmFtZS51cmwgPSBub2RlLmNhbGxGcmFtZS51cmwuc2xpY2UoNylcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobm9kZS5jYWxsRnJhbWUudXJsLnN0YXJ0c1dpdGgoJ3dlYnBhY2staW50ZXJuYWw6Ly8nKSkge1xuXHRcdFx0XHRcdGNvbnN0IG1hdGNoID0gcGFyc2VXZWJwYWNrU291cmNlTWFwVXJsKG5vZGUuY2FsbEZyYW1lLnVybClcblx0XHRcdFx0XHRpZiAobWF0Y2ggIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdG5vZGUuY2FsbEZyYW1lLnVybCA9IG1hdGNoLmZpbGVQYXRoXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyh7XG5cdFx0XHRcdFx0XHRcdGlkOiBub2RlLmlkLFxuXHRcdFx0XHRcdFx0XHRtb2R1bGU6IG1hdGNoLm1vZHVsZSxcblx0XHRcdFx0XHRcdFx0dXJsOiBtYXRjaC5maWxlUGF0aCxcblx0XHRcdFx0XHRcdFx0bGluZTogbm9kZS5jYWxsRnJhbWUubGluZU51bWJlcixcblx0XHRcdFx0XHRcdFx0Y29sOiBub2RlLmNhbGxGcmFtZS5jb2x1bW5OdW1iZXJcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUuY2FsbEZyYW1lLnVybCA9IG5ldyBVbmlmaWVkUGF0aChub2RlLmNhbGxGcmFtZS51cmwpLnRvU3RyaW5nKClcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBNZXRob2QgdG8gZml4IGFjY3VtdWxhdGVkIGVycm9ycyBpbiBjcHUgcHJvZmlsZXMgY2F1c2VkIGJ5IG5lZ2F0aXZlIHRpbWVEZWx0YVxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vamxmd29uZy9zcGVlZHNjb3BlL2Jsb2IvbWFpbi9zcmMvaW1wb3J0L2Nocm9tZS50c1xuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vamxmd29uZy9zcGVlZHNjb3BlL3B1bGwvMzA1XG5cdHN0YXRpYyBjbGVhblVwUHJvZmlsZShwcm9maWxlOiBDZHAuUHJvZmlsZXIuUHJvZmlsZSkge1xuXHRcdGlmIChwcm9maWxlLnNhbXBsZXMgPT09IHVuZGVmaW5lZCB8fCBwcm9maWxlLnRpbWVEZWx0YXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdWOFByb2ZpbGVyLmNsZWFuVXBQcm9maWxlOiBwcm9maWxlIGZvcm1hdCBpcyBub3QgY29tcGxldGUnKVxuXHRcdH1cblx0XHRjb25zdCBzYW1wbGVUaW1lczogbnVtYmVyW10gPSBbXVxuXG5cdFx0Ly8gVGhlIGZpcnN0IGRlbHRhIGlzIHJlbGF0aXZlIHRvIHRoZSBwcm9maWxlIHN0YXJ0VGltZS5cblx0XHQvLyBSZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS92OC92OC9ibG9iLzQ0YmQ4ZmQ3L3NyYy9pbnNwZWN0b3IvanNfcHJvdG9jb2wuanNvbiNMMTQ4NVxuXHRcdGxldCBlbGFwc2VkID0gcHJvZmlsZS50aW1lRGVsdGFzWzBdXG5cblx0XHQvLyBQcmV2ZW50cyBuZWdhdGl2ZSB0aW1lIGRlbHRhcyBmcm9tIGNhdXNpbmcgYmFkIGRhdGEuIFNlZVxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qbGZ3b25nL3NwZWVkc2NvcGUvcHVsbC8zMDUgZm9yIGRldGFpbHMuXG5cdFx0bGV0IGxhc3RWYWxpZEVsYXBzZWQgPSBlbGFwc2VkXG5cblx0XHQvLyBUaGUgY2hyb21lIENQVSBwcm9maWxlIGZvcm1hdCBkb2Vzbid0IGNvbGxhcHNlIGlkZW50aWNhbCBzYW1wbGVzLiBXZSdsbCBkbyB0aGF0XG5cdFx0Ly8gaGVyZSB0byBzYXZlIGEgdG9uIG9mIHdvcmsgbGF0ZXIgZG9pbmcgbWVyZ2Vycy5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHByb2ZpbGUuc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGVsYXBzZWQgPCBsYXN0VmFsaWRFbGFwc2VkKSB7XG5cdFx0XHRcdHNhbXBsZVRpbWVzLnB1c2gobGFzdFZhbGlkRWxhcHNlZClcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNhbXBsZVRpbWVzLnB1c2goZWxhcHNlZClcblx0XHRcdFx0bGFzdFZhbGlkRWxhcHNlZCA9IGVsYXBzZWRcblx0XHRcdH1cblxuXHRcdFx0aWYgKGkgPT09IHByb2ZpbGUuc2FtcGxlcy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdGlmIChlbGFwc2VkIDwgbGFzdFZhbGlkRWxhcHNlZCkge1xuXHRcdFx0XHRcdHNhbXBsZVRpbWVzLnB1c2gobGFzdFZhbGlkRWxhcHNlZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzYW1wbGVUaW1lcy5wdXNoKGVsYXBzZWQpXG5cdFx0XHRcdFx0bGFzdFZhbGlkRWxhcHNlZCA9IGVsYXBzZWRcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgdGltZURlbHRhID0gcHJvZmlsZS50aW1lRGVsdGFzW2kgKyAxXVxuXHRcdFx0XHRlbGFwc2VkICs9IHRpbWVEZWx0YVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCBsYXRlc3QgPSBzYW1wbGVUaW1lc1swXVxuXHRcdGNvbnN0IHRpbWVEZWx0YXMgPSBbbGF0ZXN0XVxuXG5cdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBzYW1wbGVUaW1lcy5sZW5ndGggLSAxOyBpKyspIHtcblx0XHRcdGNvbnN0IGRlbHRhID0gc2FtcGxlVGltZXNbaV0gLSBsYXRlc3Rcblx0XHRcdHRpbWVEZWx0YXMucHVzaChkZWx0YSlcblx0XHRcdGxhdGVzdCA9IHNhbXBsZVRpbWVzW2ldXG5cdFx0fVxuXG5cdFx0cHJvZmlsZS50aW1lRGVsdGFzID0gdGltZURlbHRhc1xuXHR9XG59Il19",
    "862": "'use strict';\n\nconst Stream = require('stream').Stream;\nconst inherits = require('util').inherits;\nconst binding = require('./lib/binding');\nconst workerThreads = require('./lib/worker_threads');\n\nfunction global_check() {\n  const version = process.versions.node.split('.').map(item => Number(item));\n  const greater_than_12_15_0 = version[0] > 12 || (version[0] === 12 && version[1] > 15);\n  return { greater_than_12_15_0 };\n}\n\nbinding.setup({\n  debug: !!process.env.V8_PROFILER_DEBUG,\n  thread_id: workerThreads.threadId\n}, global_check);\n\nfunction nodes(snapshot) {\n  let n = snapshot.nodesCount, i, nodes = [];\n  for (i = 0; i < n; i++) {\n    nodes[i] = snapshot.getNode(i);\n  }\n  return nodes;\n}\n\nfunction nodesHist(snapshot) {\n  let objects = {};\n  nodes(snapshot).forEach(function (node) {\n    let key = node.type === 'Object' ? node.name : node.type;\n    objects[key] = objects[node.name] || 0;\n    objects[key]++;\n  });\n  return objects;\n}\n\nfunction Snapshot() { }\n\nSnapshot.prototype.getHeader = function () {\n  return {\n    typeId: this.typeId,\n    uid: this.uid,\n    title: this.title\n  };\n};\n\n/**\n* @param {Snapshot} other\n* @returns {Object}\n*/\nSnapshot.prototype.compare = function (other) {\n  let selfHist = nodesHist(this),\n    otherHist = nodesHist(other),\n    keys = Object.keys(selfHist).concat(Object.keys(otherHist)),\n    diff = {};\n\n  keys.forEach(function (key) {\n    if (key in diff) { return; }\n\n    let selfCount = selfHist[key] || 0,\n      otherCount = otherHist[key] || 0;\n\n    diff[key] = otherCount - selfCount;\n  });\n\n  return diff;\n};\n\nfunction ExportStream() {\n  Stream.Transform.call(this);\n  this._transform = function noTransform(chunk, encoding, done) {\n    done(null, chunk);\n  };\n}\ninherits(ExportStream, Stream.Transform);\n\n/**\n* @param {Stream.Writable|function} dataReceiver\n* @returns {Stream|undefined}\n*/\nSnapshot.prototype.export = function (dataReceiver) {\n  dataReceiver = dataReceiver || new ExportStream();\n\n  let toStream = dataReceiver instanceof Stream,\n    chunks = toStream ? null : [];\n\n  function onChunk(chunk, len) {\n    if (toStream) { dataReceiver.write(chunk); }\n    else { chunks.push(chunk); }\n  }\n\n  function onDone() {\n    if (toStream) { dataReceiver.end(); }\n    else { dataReceiver(null, chunks.join('')); }\n  }\n\n  this.serialize(onChunk, onDone);\n\n  return toStream ? dataReceiver : undefined;\n};\n\nfunction CpuProfile() { }\n\nCpuProfile.prototype.getHeader = function () {\n  return {\n    typeId: this.typeId,\n    uid: this.uid,\n    title: this.title\n  };\n};\n\nCpuProfile.prototype.export = function (dataReceiver) {\n  dataReceiver = dataReceiver || new ExportStream();\n\n  let toStream = dataReceiver instanceof Stream;\n  let error, result;\n\n  try {\n    result = JSON.stringify(this);\n  } catch (err) {\n    error = err;\n  }\n\n  process.nextTick(function () {\n    if (toStream) {\n      if (error) {\n        dataReceiver.emit('error', error);\n      }\n\n      dataReceiver.end(result);\n    } else {\n      dataReceiver(error, result);\n    }\n  });\n\n  return toStream ? dataReceiver : undefined;\n};\n\nfunction SamplingHeapProfile() { }\n\nSamplingHeapProfile.prototype.export = function (dataReceiver) {\n  dataReceiver = dataReceiver || new ExportStream();\n\n  let toStream = dataReceiver instanceof Stream;\n  let error, result;\n\n  try {\n    result = JSON.stringify(this);\n  } catch (err) {\n    error = err;\n  }\n\n  process.nextTick(function () {\n    if (toStream) {\n      if (error) {\n        dataReceiver.emit('error', error);\n      }\n\n      dataReceiver.end(result);\n    } else {\n      dataReceiver(error, result);\n    }\n  });\n\n  return toStream ? dataReceiver : undefined;\n};\n\nlet startTime, endTime;\nlet activeProfiles = [];\n\nlet profiler = {\n  /*HEAP PROFILER API*/\n\n  get snapshots() { return binding.heap.snapshots; },\n\n  takeSnapshot: function (name, control) {\n    if (typeof name === 'function') {\n      control = name;\n      name = '';\n    }\n\n    if (typeof control !== 'function') {\n      control = function noop() { };\n    }\n\n    name = name ? '' + name : '';\n\n    let snapshot = binding.heap.takeSnapshot(name, control);\n    snapshot.__proto__ = Snapshot.prototype;\n    snapshot.title = name ? name : snapshot.title;\n    return snapshot;\n  },\n\n  deleteAllSnapshots: function () {\n    Object.keys(binding.heap.snapshots).forEach(function (key) {\n      binding.heap.snapshots[key].delete();\n    });\n  },\n\n  startTrackingHeapObjects: function () {\n    binding.heap.startTrackingHeapObjects();\n  },\n\n  stopTrackingHeapObjects: function () {\n    binding.heap.stopTrackingHeapObjects();\n  },\n\n  getHeapStats: function (iterator, callback) {\n    if (typeof iterator !== 'function') { iterator = function noop() { }; }\n\n    if (typeof callback !== 'function') { callback = function noop() { }; }\n\n    return binding.heap.getHeapStats(iterator, callback);\n  },\n\n  getObjectByHeapObjectId: function (id) {\n    id = parseInt(id, 10);\n    if (isNaN(id)) { return; }\n\n    return binding.heap.getObjectByHeapObjectId(id);\n  },\n\n  getHeapObjectId: function (value) {\n    if (!arguments.length) { return; }\n    return binding.heap.getHeapObjectId(value);\n  },\n\n  /*CPU PROFILER API*/\n\n  get profiles() { return binding.cpu.profiles; },\n\n  setGenerateType: function (type) {\n    const types = [0, 1];\n    if (types.indexOf(type) > -1) {\n      binding.cpu.setGenerateType(type);\n    } else {\n      console.error(`type should in [${types.join(', ')}], got ${type}.`);\n    }\n  },\n\n  setProfilesCleanupLimit: function (limit) {\n    if (!isNaN(limit)) {\n      binding.cpu.setProfilesCleanupLimit(Number(limit));\n    } else {\n      console.error(`limit should be number.`);\n    }\n  },\n\n  startProfiling: function (name, recsamples, mode) {\n    if (activeProfiles.length === 0 && typeof process._startProfilerIdleNotifier === 'function') {\n      process._startProfilerIdleNotifier();\n    }\n\n    if (typeof name === 'boolean') {\n      recsamples = name;\n      name = '';\n    }\n\n    if ([0, 1].indexOf(mode) === -1) {\n      mode = 0;\n    }\n\n    recsamples = recsamples === undefined ? true : Boolean(recsamples);\n    name = name && '' + name || '';\n\n    if (activeProfiles.indexOf(name) < 0) { activeProfiles.push(name); }\n\n    startTime = Date.now();\n    binding.cpu.startProfiling(name, recsamples, mode);\n  },\n\n  stopProfiling: function (name) {\n    let index = activeProfiles.indexOf(name);\n    if (name && index < 0) { return; }\n\n    let profile = binding.cpu.stopProfiling(name);\n    endTime = Date.now();\n    profile.__proto__ = CpuProfile.prototype;\n    if (!profile.startTime) { profile.startTime = startTime; }\n    if (!profile.endTime) { profile.endTime = endTime; }\n\n    if (name) { activeProfiles.splice(index, 1); }\n    else { activeProfiles.length = activeProfiles.length - 1; }\n\n    if (activeProfiles.length === 0 && typeof process._stopProfilerIdleNotifier === 'function') {\n      process._stopProfilerIdleNotifier();\n    }\n\n    return profile;\n  },\n\n  setSamplingInterval: function (num) {\n    if (activeProfiles.length) {\n      throw new Error('setSamplingInterval must be called when there are no profiles being recorded.');\n    }\n\n    num = parseInt(num, 10) || 1000;\n    binding.cpu.setSamplingInterval(num);\n  },\n\n  deleteAllProfiles: function () {\n    Object.keys(binding.cpu.profiles).forEach(function (key) {\n      binding.cpu.profiles[key].delete();\n    });\n  },\n\n  collectSample: function () {\n    if (process.versions.modules >= 48) {\n      binding.cpu.collectSample();\n    }\n  },\n\n  /*SAMPLING HEAP PROFILER API*/\n\n  startSamplingHeapProfiling: function (interval, depth) {\n    if (process.versions.modules < 48) { throw new Error('Sampling heap profiler needs node version >= node-v6.0.0!'); }\n    if (arguments.length === 2) { binding.samplingHeap.startSamplingHeapProfiling(interval, depth); }\n    else { binding.samplingHeap.startSamplingHeapProfiling(); }\n  },\n\n  stopSamplingHeapProfiling: function () {\n    if (process.versions.modules < 48) { throw new Error('Sampling heap profiler needs node version >= node-v6.0.0!'); }\n    let profile = binding.samplingHeap.stopSamplingHeapProfiling();\n    profile.__proto__ = SamplingHeapProfile.prototype;\n    return profile;\n  }\n};\n\nmodule.exports = profiler;\nprocess.profiler = profiler;\n"
  },
  "loadedFiles": {
    "./packages/profiler/src/Profiler.ts": "import * as fs from 'fs'\nimport { Session } from 'inspector'\n\nimport seedrandom from 'seedrandom'\nimport {\n\tAPP_NAME,\n\tUnifiedPath,\n\tProfilerConfig,\n\tProjectReport,\n\tIProjectReportExecutionDetails,\n\tJestAdapter,\n\tTimeHelper,\n\tNanoSeconds_BigInt,\n\tMicroSeconds_number,\n\tReportKind,\n\tPermissionHelper,\n\tLoggerHelper,\n\tExecutionDetails,\n\tPerformanceHelper,\n\tInspectorHelper\n} from '@oaklean/profiler-core'\nimport { JestEnvironmentConfig, EnvironmentContext } from '@jest/environment'\n\nimport { V8Profiler } from './model/V8Profiler'\nimport { TraceEventHelper } from './helper/TraceEventHelper'\nimport { BaseSensorInterface } from './interfaces/BaseSensorInterface'\nimport { PowerMetricsSensorInterface } from './interfaces/powermetrics/PowerMetricsSensorInterface'\nimport { PerfSensorInterface } from './interfaces/perf/PerfSensorInterface'\nimport { WindowsSensorInterface } from './interfaces/windows/WindowsSensorInterface'\n\nexport type TransformerAdapter = 'ts-jest'\n\nexport type ProfilerOptions = {\n\ttransformerAdapter?: TransformerAdapter\n\tjestAdapter: {\n\t\tconfig: JestEnvironmentConfig,\n\t\tcontext: EnvironmentContext\n\t}\n}\n\ninterface TraceEventParams {\n\tpid: number,\n\ttid: number,\n\tts: number,\n\ttts: number,\n\tph: string,\n\tcat: string,\n\tname: string,\n\tdur: number\n\ttdur: number\n}\n\nexport class Profiler {\n\tsubOutputDir: string | undefined\n\tconfig: ProfilerConfig\n\toptions?: ProfilerOptions\n\texecutionDetails?: IProjectReportExecutionDetails\n\n\tprivate _inspectorHelper: InspectorHelper\n\tprivate _sensorInterface: BaseSensorInterface | undefined\n\tprivate _traceEventSession: Session | undefined\n\tprivate _profilerStartTime: MicroSeconds_number | undefined\n\n\tconstructor(\n\t\tsubOutputDir?: string,\n\t\toptions?: ProfilerOptions\n\t) {\n\t\tthis.subOutputDir = subOutputDir\n\t\tthis.config = ProfilerConfig.autoResolve()\n\t\tthis.options = options\n\t\tthis.loadSensorInterface()\n\t\tthis._inspectorHelper = new InspectorHelper()\n\t}\n\n\tstatic getSensorInterface(config: ProfilerConfig) {\n\t\tconst sensorInterfaceType = config.getSensorInterfaceType()\n\t\tswitch (sensorInterfaceType) {\n\t\t\tcase 'powermetrics': {\n\t\t\t\tconst options = config.getSensorInterfaceOptions()\n\t\t\t\tif (options === undefined) {\n\t\t\t\t\tthrow new Error('Profiler.getSensorInterface: sensorInterfaceOptions are not defined')\n\t\t\t\t}\n\t\t\t\toptions.outputFilePath = config.getOutDir().join(options.outputFilePath).toPlatformString()\n\t\t\t\treturn new PowerMetricsSensorInterface(options)\n\t\t\t}\n\t\t\tcase 'perf': {\n\t\t\t\tconst options = config.getSensorInterfaceOptions()\n\t\t\t\tif (options === undefined) {\n\t\t\t\t\tthrow new Error('Profiler.getSensorInterface: sensorInterfaceOptions are not defined')\n\t\t\t\t}\n\t\t\t\toptions.outputFilePath = config.getOutDir().join(options.outputFilePath).toPlatformString()\n\t\t\t\treturn new PerfSensorInterface(options)\n\t\t\t}\n\t\t\tcase 'windows': {\n\t\t\t\tconst options = config.getSensorInterfaceOptions()\n\t\t\t\tif (options === undefined) {\n\t\t\t\t\tthrow new Error('Profiler.getSensorInterface: sensorInterfaceOptions are not defined')\n\t\t\t\t}\n\t\t\t\toptions.outputFilePath = config.getOutDir().join(options.outputFilePath).toPlatformString()\n\t\t\t\treturn new WindowsSensorInterface(options)\n\t\t\t}\n\t\t}\n\t}\n\n\tloadSensorInterface() {\n\t\tthis._sensorInterface = Profiler.getSensorInterface(this.config)\n\t}\n\n\tstatic async inject(subOutputDir?: string): Promise<Profiler> {\n\t\tconst profiler = new Profiler(subOutputDir)\n\n\t\tconst title = new Date().getTime().toString()\n\n\t\tconst exitResolve = () => resolve('exit')\n\t\tconst sigIntResolve = () => resolve('SIGINT')\n\t\tconst sigUsr1Resolve = () => resolve('SIGUSR1')\n\t\tconst sigUsr2Resolve = () => resolve('SIGUSR2')\n\n\n\t\tlet stopped = false\n\t\tasync function resolve(origin: string) {\n\t\t\tif (!stopped) {\n\t\t\t\tstopped = true\n\t\t\t\tLoggerHelper.log(`(${APP_NAME} Profiler) Finish Measurement, please wait...`)\n\t\t\t\tawait profiler.finish(title)\n\t\t\t\tprocess.removeListener('exit', exitResolve)\n\t\t\t\tprocess.removeListener('SIGINT', sigIntResolve)\n\t\t\t\tprocess.removeListener('SIGUSR1', sigUsr1Resolve)\n\t\t\t\tprocess.removeListener('SIGUSR2', sigUsr2Resolve)\n\t\t\t\tif (origin !== 'exit') {\n\t\t\t\t\tprocess.exit()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLoggerHelper.log(`(${APP_NAME} Profiler) Measurement started`)\n\t\tawait profiler.start(title)\n\n\t\tprocess.on('exit', exitResolve)\n\n\t\t// //catches ctrl+c event\n\t\tprocess.on('SIGINT', sigIntResolve)\n\n\t\t// // catches \"kill pid\" (for example: nodemon restart)\n\t\tprocess.on('SIGUSR1', sigUsr1Resolve)\n\t\tprocess.on('SIGUSR2', sigUsr2Resolve)\n\n\t\treturn profiler\n\t}\n\n\tasync startCapturingProfilerTracingEvents() {\n\t\tif (this._traceEventSession !== undefined) {\n\t\t\tthrow new Error('startCapturingProfilerTracingEvents: Trace Event Session should not already be defined')\n\t\t}\n\t\tconst session = new Session()\n\t\tthis._traceEventSession = session\n\t\tsession.connect()\n\t\tsession.on('NodeTracing.dataCollected', (chunk) => {\n\t\t\tfor (const event of (chunk.params.value as TraceEventParams[])) {\n\t\t\t\tif (event.pid === process.pid && event.cat === 'v8') {\n\t\t\t\t\tif (event.name === 'CpuProfiler::StartProfiling') { // captured start event of cpu profiler\n\t\t\t\t\t\tthis._profilerStartTime = event.ts as MicroSeconds_number // store high resolution begin time\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tconst traceConfig = { includedCategories: ['v8'] } // config to capture v8's trace events\n\t\tawait TraceEventHelper.post(session, 'NodeTracing.start', { traceConfig }) // start trace event capturing\n\t}\n\n\tasync stopCapturingProfilerTracingEvents() {\n\t\tif (this._traceEventSession === undefined) {\n\t\t\tthrow new Error('stopCapturingProfilerTracingEvents: Trace Event Session should be defined')\n\t\t}\n\t\tawait TraceEventHelper.post(this._traceEventSession, 'NodeTracing.stop', undefined)\n\t\tthis._traceEventSession.disconnect()\n\t\tthis._traceEventSession = undefined\n\t}\n\n\tasync getCPUProfilerBeginTime(): Promise<MicroSeconds_number> {\n\t\tlet tries = 0\n\t\twhile (this._profilerStartTime === undefined && tries < 10) {\n\t\t\tLoggerHelper.error(`Cannot capture profiler start time on try: ${tries + 1}, try again after 1 second`)\n\t\t\ttries += 1\n\t\t\tawait TimeHelper.sleep(1000)\n\t\t}\n\t\tif (this._profilerStartTime === undefined) {\n\t\t\tthrow new Error(`Could not capture cpu profilers begin time after ${tries} tries, measurements failed`)\n\t\t}\n\t\treturn this._profilerStartTime\n\t}\n\n\tasync start(title: string, executionDetails?: IProjectReportExecutionDetails) {\n\t\tconst performance = new PerformanceHelper()\n\t\tperformance.start('Profiler.start')\n\n\t\tconst outFileReport = this.outputReportPath(title)\n\t\tconst outDir = outFileReport.dirName()\n\n\t\tperformance.start('Profiler.start.createOutDir')\n\t\tif (!fs.existsSync(outDir.toPlatformString())) {\n\t\t\tPermissionHelper.mkdirRecursivelyWithUserPermission(outDir)\n\t\t}\n\t\tperformance.stop('Profiler.start.createOutDir')\n\n\t\tperformance.start('Profiler.start.seedRandom')\n\t\tconst mathRandomSeed = this.config.getSeedForMathRandom()\n\t\tif (mathRandomSeed) {\n\t\t\tseedrandom(mathRandomSeed, { global: true })\n\t\t}\n\t\tperformance.stop('Profiler.start.seedRandom')\n\n\t\tif (executionDetails) {\n\t\t\tthis.executionDetails = executionDetails\n\t\t} else {\n\t\t\tperformance.start('Profiler.start.resolveExecutionDetails')\n\t\t\tthis.executionDetails = await ExecutionDetails.resolveExecutionDetails()\n\t\t\tperformance.stop('Profiler.start.resolveExecutionDetails')\n\t\t}\n\t\tperformance.start('Profiler.start.V8Profiler.setGenerateType')\n\t\tV8Profiler.setGenerateType(1) // must be set to generate new cpuprofile format\n\t\tperformance.stop('Profiler.start.V8Profiler.setGenerateType')\n\n\t\tperformance.start('Profiler.start.getV8CPUSamplingInterval')\n\t\tV8Profiler.setSamplingInterval(this.config.getV8CPUSamplingInterval()) // sets the sampling interval in microseconds\n\t\tperformance.stop('Profiler.start.getV8CPUSamplingInterval')\n\n\t\tperformance.start('Profiler.start.startCapturingProfilerTracingEvents')\n\t\tawait this.startCapturingProfilerTracingEvents()\n\t\tperformance.stop('Profiler.start.startCapturingProfilerTracingEvents')\n\n\t\tperformance.start('Profiler.start.sensorInterface.couldBeExecuted')\n\t\tif (this._sensorInterface !== undefined && !await this._sensorInterface.couldBeExecuted()) {\n\t\t\t// remove sensor interface from execution details since it cannot be executed\n\t\t\tthis.executionDetails.runTimeOptions.sensorInterface = undefined\n\t\t\tLoggerHelper.warn(`(${APP_NAME} Profiler) Warning: ` + \n\t\t\t\t'Sensor Interface can not be executed, no energy measurements will be collected')\n\t\t}\n\t\tperformance.stop('Profiler.start.sensorInterface.couldBeExecuted')\n\n\t\tperformance.start('Profiler.start.sensorInterface.startProfiling')\n\t\tawait this._sensorInterface?.startProfiling()\n\t\tperformance.stop('Profiler.start.sensorInterface.startProfiling')\n\n\t\t// title - handle to stop profile again\n\t\t// recsampels(boolean) - record samples, if false no cpu times will be captured\n\t\tperformance.start('Profiler.start.V8Profiler.startProfiling')\n\t\tV8Profiler.startProfiling(title, true)\n\t\tperformance.stop('Profiler.start.V8Profiler.startProfiling')\n\t\tperformance.start('Profiler.start.inspectorHelper.connect')\n\t\tawait this._inspectorHelper.connect()\n\t\tthis._inspectorHelper.listen()\n\t\tperformance.stop('Profiler.start.inspectorHelper.connect')\n\t\tperformance.stop('Profiler.start')\n\t\tperformance.printReport('Profiler.start')\n\t\tperformance.exportAndSum(this.outputDir().join('performance.json'))\n\t}\n\n\toutputDir(): UnifiedPath {\n\t\treturn this.config.getOutDir().join(this.subOutputDir || '')\n\t}\n\n\toutputReportPath(title: string): UnifiedPath {\n\t\treturn this.outputDir().join(`${title}.oak`)\n\t}\n\n\toutputMetricCollectionPath(title: string): UnifiedPath {\n\t\treturn this.outputDir().join(`${title}.mcollection`)\n\t}\n\n\toutputProfilePath(title: string): UnifiedPath {\n\t\treturn this.outputDir().join(`${title}.cpuprofile`)\n\t}\n\n\toutputInspectorHelperPath(title: string): UnifiedPath {\n\t\treturn this.outputDir().join(`${title}.inspector.json`)\n\t}\n\n\tasync finish(title: string, highResolutionStopTime?: NanoSeconds_BigInt): Promise<ProjectReport> {\n\t\tconst performance = new PerformanceHelper()\n\t\t\n\t\tperformance.start('Profiler.finish')\n\t\tif (this.executionDetails === undefined) {\n\t\t\tthrow new Error('Profiler.finish: Profiler was not started yet')\n\t\t}\n\t\tif (highResolutionStopTime !== undefined) {\n\t\t\tthis.executionDetails.highResolutionStopTime = highResolutionStopTime.toString()\n\t\t}\n\n\t\tperformance.start('Profiler.finish.stopProfiling')\n\t\tconst profile = V8Profiler.stopProfiling(title)\n\t\tperformance.stop('Profiler.finish.stopProfiling')\n\n\t\tperformance.start('Profiler.finish.stopCapturingProfilerTracingEvents')\n\t\tthis.stopCapturingProfilerTracingEvents()\n\t\tperformance.stop('Profiler.finish.stopCapturingProfilerTracingEvents')\n\n\t\tperformance.start('Profiler.finish.sensorInterface.stopProfiling')\n\t\tawait this._sensorInterface?.stopProfiling()\n\t\tperformance.stop('Profiler.finish.sensorInterface.stopProfiling')\n\n\t\tconst CPUProfilerBeginTime = BigInt(await this.getCPUProfilerBeginTime()) * BigInt(1000) as NanoSeconds_BigInt\n\t\tthis.executionDetails.highResolutionBeginTime = CPUProfilerBeginTime.toString()\n\n\t\tconst exportData = {\n\t\t\tnodes: profile.nodes,\n\t\t\tstartTime: profile.startTime,\n\t\t\tendTime: profile.endTime,\n\t\t\tsamples: profile.samples,\n\t\t\ttimeDeltas: profile.timeDeltas\n\t\t}\n\t\tlet transformerAdapter = undefined\n\t\tif (this.options?.transformerAdapter === 'ts-jest') {\n\t\t\tif (!this.options.jestAdapter.config || !this.options.jestAdapter.context) {\n\t\t\t\tthrow new Error('Please provide the JestEnvironmentConfig and EnvironmentContext in the profiler options at options.jestAdapter')\n\t\t\t}\n\t\t\ttransformerAdapter = new JestAdapter(\n\t\t\t\tthis.options.jestAdapter.config,\n\t\t\t\tthis.options.jestAdapter.context\n\t\t\t)\n\t\t\tif (!fs.existsSync(this.outputDir().toPlatformString())) {\n\t\t\t\tPermissionHelper.mkdirRecursivelyWithUserPermission(this.outputDir())\n\t\t\t}\n\t\t\tperformance.start('Profiler.finish.exportJestConfig')\n\t\t\tPermissionHelper.writeFileWithUserPermission(\n\t\t\t\tthis.outputDir().join('jest.config').toPlatformString(),\n\t\t\t\tJSON.stringify({\n\t\t\t\t\tconfig: this.options.jestAdapter.config,\n\t\t\t\t\tcontext: this.options.jestAdapter.context\n\t\t\t\t})\n\t\t\t)\n\t\t\tperformance.stop('Profiler.finish.exportJestConfig')\n\t\t}\n\t\tconst outFileCPUProfile = this.outputProfilePath(title)\n\t\tconst outFileInspectorHelper = this.outputInspectorHelperPath(title)\n\t\tconst outFileReport = this.outputReportPath(title)\n\t\tconst outFileMetricCollection = this.outputMetricCollectionPath(title)\n\t\tif (this.config.shouldExportV8Profile()) {\n\t\t\tperformance.start('Profiler.finish.exportV8Profile')\n\t\t\tPermissionHelper.writeFileWithUserPermission(\n\t\t\t\toutFileCPUProfile.toPlatformString(),\n\t\t\t\tJSON.stringify(exportData, null, 2),\n\t\t\t)\n\t\t\tperformance.stop('Profiler.finish.exportV8Profile')\n\t\t}\n\t\tperformance.start('Profiler.finish.sensorInterface.readSensorValues')\n\t\tconst metricsDataCollection = await this._sensorInterface?.readSensorValues(process.pid)\n\t\tperformance.stop('Profiler.finish.sensorInterface.readSensorValues')\n\n\t\tconst rootDir = this.config.getRootDir()\n\t\tconst report = new ProjectReport(this.executionDetails, ReportKind.measurement)\n\t\tif (this.config.shouldExportSensorInterfaceData()) {\n\t\t\tif (metricsDataCollection !== undefined) {\n\t\t\t\tperformance.start('Profiler.finish.exportMetricsDataCollection')\n\t\t\t\tmetricsDataCollection.storeToFile(outFileMetricCollection)\n\t\t\t\tperformance.stop('Profiler.finish.exportMetricsDataCollection')\n\t\t\t}\n\t\t}\n\n\t\tperformance.start('Profiler.finish.insertCPUProfile')\n\t\tawait report.insertCPUProfile(\n\t\t\trootDir,\n\t\t\tprofile,\n\t\t\tthis._inspectorHelper,\n\t\t\tmetricsDataCollection\n\t\t)\n\t\tperformance.stop('Profiler.finish.insertCPUProfile')\n\n\t\tperformance.start('Profiler.finish.inspectorHelper.disconnect')\n\t\tawait this._inspectorHelper.disconnect()\n\t\tperformance.stop('Profiler.finish.inspectorHelper.disconnect')\n\n\t\tif (this.config.shouldExportV8Profile()) {\n\t\t\tperformance.start('Profiler.finish.exportInspectorHelper')\n\t\t\tPermissionHelper.writeFileWithUserPermission(\n\t\t\t\toutFileInspectorHelper.toPlatformString(),\n\t\t\t\tJSON.stringify(this._inspectorHelper, null, 2),\n\t\t\t)\n\t\t\tperformance.stop('Profiler.finish.exportInspectorHelper')\n\t\t}\n\n\t\tperformance.start('Profiler.finish.trackUncommittedFiles')\n\t\tawait report.trackUncommittedFiles(rootDir)\n\t\tperformance.stop('Profiler.finish.trackUncommittedFiles')\n\n\t\tif (this.config.shouldExportReport()) {\n\t\t\tperformance.start('Profiler.finish.exportReport')\n\t\t\treport.storeToFile(outFileReport, 'bin', this.config)\n\t\t\tperformance.stop('Profiler.finish.exportReport')\n\t\t}\n\n\t\tif (await report.shouldBeStoredInRegistry()) {\n\t\t\tawait report.uploadToRegistry(this.config)\n\t\t}\n\t\tperformance.stop('Profiler.finish')\n\t\tperformance.printReport('Profiler.finish')\n\t\tperformance.exportAndSum(this.outputDir().join('performance.json'))\n\n\t\treturn report\n\t}\n}\n",
    "./packages/profiler/src/model/V8Profiler.ts": "import * as fs from 'fs'\n\nimport type { Protocol as Cdp } from 'devtools-protocol'\nimport { MicroSeconds_number, UnifiedPath } from '@oaklean/profiler-core'\n\nconst WEBPACK_URL_REGEX = /webpack-internal:\\/\\/(.+?[^/]\\/)([^?]+)(.*)$/\n\nfunction parseWebpackSourceMapUrl(url: string) {\n\tconst matches = WEBPACK_URL_REGEX.exec(url)\n\tif (matches && matches.length > 2) {\n\t\tconst module = matches[1]\n\t\tconst filePath = matches[2]\n\t\treturn {\n\t\t\tmodule,\n\t\t\tfilePath\n\t\t}\n\t}\n\treturn null\n}\n\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst v8Profiler = require('v8-profiler-next')\n\nexport class V8Profiler {\n\tstatic startProfiling(name: string, recsamples?: boolean, mode?: 0 | 1) : void {\n\t\tv8Profiler.startProfiling(name, recsamples, mode)\n\t}\n\n\tstatic stopProfiling(name?: string): Cdp.Profiler.Profile {\n\t\tconst profile = v8Profiler.stopProfiling(name)\n\t\tV8Profiler.cleanUpProfile(profile)\n\t\tV8Profiler.unifyProfile(profile)\n\t\treturn profile\n\t}\n\n\tstatic setGenerateType(type: 0 | 1) {\n\t\tv8Profiler.setGenerateType(type)\n\t}\n\n\tstatic setSamplingInterval(num: MicroSeconds_number) {\n\t\tv8Profiler.setSamplingInterval(num)\n\t}\n\n\t/**\n\t * Unifies the V8 Profile to ensure compatibility between linux / mac / windows\n\t * All filePaths are converted to unix paths\n\t * \n\t * @param profile \n\t */\n\tstatic unifyProfile(profile: Cdp.Profiler.Profile) {\n\t\tfor (const node of profile.nodes) {\n\t\t\tif (node.callFrame.url !== '' && !node.callFrame.url.startsWith('node:')) {\n\t\t\t\tif (node.callFrame.url.startsWith('file://')) {\n\t\t\t\t\tnode.callFrame.url = node.callFrame.url.slice(7)\n\t\t\t\t}\n\t\t\t\tif (node.callFrame.url.startsWith('webpack-internal://')) {\n\t\t\t\t\tconst match = parseWebpackSourceMapUrl(node.callFrame.url)\n\t\t\t\t\tif (match !== null) {\n\t\t\t\t\t\tnode.callFrame.url = match.filePath\n\t\t\t\t\t\tconsole.log({\n\t\t\t\t\t\t\tid: node.id,\n\t\t\t\t\t\t\tmodule: match.module,\n\t\t\t\t\t\t\turl: match.filePath,\n\t\t\t\t\t\t\tline: node.callFrame.lineNumber,\n\t\t\t\t\t\t\tcol: node.callFrame.columnNumber\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode.callFrame.url = new UnifiedPath(node.callFrame.url).toString()\n\t\t\t}\n\t\t}\n\t}\n\n\t// Method to fix accumulated errors in cpu profiles caused by negative timeDelta\n\t// https://github.com/jlfwong/speedscope/blob/main/src/import/chrome.ts\n\t// https://github.com/jlfwong/speedscope/pull/305\n\tstatic cleanUpProfile(profile: Cdp.Profiler.Profile) {\n\t\tif (profile.samples === undefined || profile.timeDeltas === undefined) {\n\t\t\tthrow new Error('V8Profiler.cleanUpProfile: profile format is not complete')\n\t\t}\n\t\tconst sampleTimes: number[] = []\n\n\t\t// The first delta is relative to the profile startTime.\n\t\t// Ref: https://github.com/v8/v8/blob/44bd8fd7/src/inspector/js_protocol.json#L1485\n\t\tlet elapsed = profile.timeDeltas[0]\n\n\t\t// Prevents negative time deltas from causing bad data. See\n\t\t// https://github.com/jlfwong/speedscope/pull/305 for details.\n\t\tlet lastValidElapsed = elapsed\n\n\t\t// The chrome CPU profile format doesn't collapse identical samples. We'll do that\n\t\t// here to save a ton of work later doing mergers.\n\t\tfor (let i = 0; i < profile.samples.length; i++) {\n\t\t\tif (elapsed < lastValidElapsed) {\n\t\t\t\tsampleTimes.push(lastValidElapsed)\n\t\t\t} else {\n\t\t\t\tsampleTimes.push(elapsed)\n\t\t\t\tlastValidElapsed = elapsed\n\t\t\t}\n\n\t\t\tif (i === profile.samples.length - 1) {\n\t\t\t\tif (elapsed < lastValidElapsed) {\n\t\t\t\t\tsampleTimes.push(lastValidElapsed)\n\t\t\t\t} else {\n\t\t\t\t\tsampleTimes.push(elapsed)\n\t\t\t\t\tlastValidElapsed = elapsed\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst timeDelta = profile.timeDeltas[i + 1]\n\t\t\t\telapsed += timeDelta\n\t\t\t}\n\t\t}\n\n\t\tlet latest = sampleTimes[0]\n\t\tconst timeDeltas = [latest]\n\n\t\tfor (let i = 1; i < sampleTimes.length - 1; i++) {\n\t\t\tconst delta = sampleTimes[i] - latest\n\t\t\ttimeDeltas.push(delta)\n\t\t\tlatest = sampleTimes[i]\n\t\t}\n\n\t\tprofile.timeDeltas = timeDeltas\n\t}\n}",
    "./packages/profiler-core/dist/src/helper/InspectorHelper.js": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InspectorHelper = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst inspector_1 = __importDefault(require(\"inspector\"));\nconst LoggerHelper_1 = require(\"./LoggerHelper\");\nconst PermissionHelper_1 = require(\"./PermissionHelper\");\nconst TypescriptParser_1 = require(\"./TypescriptParser\");\nconst SourceMap_1 = require(\"../model/SourceMap\");\nconst UnifiedPath_1 = require(\"../system/UnifiedPath\");\nclass InspectorHelper {\n    constructor() {\n        this._session = new inspector_1.default.Session();\n        this.sourceCodeMap = new Map();\n        this.sourceMapMap = new Map();\n        this.loadedFiles = new Map();\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._session.connect();\n            // wait for debugger to be enabled\n            yield new Promise((resolve) => {\n                this._session.post('Debugger.enable', resolve);\n            });\n        });\n    }\n    storeToFile(filePath, kind) {\n        if (!fs.existsSync(filePath.dirName().toPlatformString())) {\n            PermissionHelper_1.PermissionHelper.mkdirRecursivelyWithUserPermission(filePath.dirName().toPlatformString());\n        }\n        switch (kind) {\n            case 'pretty-json':\n                PermissionHelper_1.PermissionHelper.writeFileWithUserPermission(filePath.toPlatformString(), JSON.stringify(this, null, 2));\n                break;\n            case 'json':\n                PermissionHelper_1.PermissionHelper.writeFileWithUserPermission(filePath.toPlatformString(), JSON.stringify(this));\n                break;\n            default:\n                break;\n        }\n    }\n    static loadFromFile(filePath) {\n        if (!fs.existsSync(filePath.toPlatformString())) {\n            return undefined;\n        }\n        return InspectorHelper.fromJSON(fs.readFileSync(filePath.toPlatformString()).toString());\n    }\n    toJSON() {\n        return {\n            sourceCodeMap: Object.fromEntries(this.sourceCodeMap),\n            loadedFiles: Object.fromEntries(this.loadedFiles)\n        };\n    }\n    static fromJSON(json) {\n        let data;\n        if (typeof json === 'string') {\n            data = JSON.parse(json);\n        }\n        else {\n            data = json;\n        }\n        const result = new InspectorHelper();\n        for (const [key, value] of Object.entries(data.sourceCodeMap)) {\n            result.sourceCodeMap.set(key, value);\n        }\n        for (const [key, value] of Object.entries(data.loadedFiles)) {\n            result.loadedFiles.set(key, value);\n        }\n        return result;\n    }\n    listen() {\n        this._session.on('inspectorNotification', (message) => __awaiter(this, void 0, void 0, function* () {\n            if (message.method === 'Debugger.scriptParsed') {\n                const params = message.params;\n                yield this.sourceCodeFromId(params.scriptId);\n            }\n        }));\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield new Promise((resolve) => {\n                this._session.post('Debugger.disable', resolve);\n            });\n            this._session.disconnect();\n        });\n    }\n    fillSourceMapsFromCPUModel(cpuModel) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const scriptMap = new Map();\n            for (const location of cpuModel.ILocations) {\n                const scriptId = location.callFrame.scriptId.toString();\n                if (scriptMap.has(scriptId)) {\n                    continue;\n                }\n                scriptMap.set(scriptId, location.callFrame.url);\n            }\n            const promises = [];\n            for (const [scriptId, filePath] of scriptMap) {\n                promises.push(this.sourceMapFromId(new UnifiedPath_1.UnifiedPath(filePath), scriptId));\n            }\n            yield Promise.all(promises);\n        });\n    }\n    loadFile(relativePath, filePath) {\n        let source = this.loadedFiles.get(relativePath.toString());\n        if (source !== undefined) {\n            return source;\n        }\n        source = fs.readFileSync(filePath.toPlatformString()).toString();\n        this.loadedFiles.set(relativePath.toString(), source);\n        return source;\n    }\n    parseFile(relativePath, filePath) {\n        const source = this.loadFile(relativePath, filePath);\n        return TypescriptParser_1.TypescriptParser.parseSource(filePath, source);\n    }\n    sourceCodeFromId(scriptId, filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (scriptId === '0') {\n                return null;\n            }\n            let source = this.sourceCodeMap.get(scriptId);\n            if (source !== undefined) {\n                return source;\n            }\n            const result = yield (new Promise((resolve) => {\n                this._session.post('Debugger.getScriptSource', { scriptId }, (err, args) => {\n                    if (err) {\n                        resolve({ source: '', err });\n                    }\n                    else {\n                        resolve({ source: args.scriptSource });\n                    }\n                });\n            }));\n            if (result.err) {\n                LoggerHelper_1.LoggerHelper.error('Error getting script source', result.err, { scriptId, filePath });\n                throw result.err;\n            }\n            source = result.source;\n            this.sourceCodeMap.set(scriptId, source);\n            return source;\n        });\n    }\n    sourceMapFromId(filePath, scriptId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (scriptId === '0') {\n                return null;\n            }\n            let sourceMap = this.sourceMapMap.get(scriptId);\n            if (sourceMap !== undefined) {\n                return sourceMap;\n            }\n            const sourceCode = yield this.sourceCodeFromId(scriptId, filePath);\n            if (sourceCode === null) {\n                throw new Error(`No source map found for scriptId ${filePath.toPlatformString()} ${scriptId}`);\n            }\n            sourceMap = SourceMap_1.SourceMap.fromCompiledJSString(filePath, sourceCode);\n            this.sourceMapMap.set(scriptId, sourceMap);\n            return sourceMap;\n        });\n    }\n}\nexports.InspectorHelper = InspectorHelper;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5zcGVjdG9ySGVscGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2hlbHBlci9JbnNwZWN0b3JIZWxwZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx1Q0FBd0I7QUFDeEIsMERBQWlDO0FBRWpDLGlEQUE2QztBQUU3Qyx5REFBcUQ7QUFDckQseURBQXFEO0FBRXJELGtEQUE4QztBQUM5Qyx1REFBbUQ7QUFLbkQsTUFBYSxlQUFlO0lBVTNCO1FBQ0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLG1CQUFTLENBQUMsT0FBTyxFQUFFLENBQUE7UUFDdkMsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFBO1FBQzlCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQTtRQUM3QixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUE7SUFDN0IsQ0FBQztJQUVLLE9BQU87O1lBQ1osSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQTtZQUN2QixrQ0FBa0M7WUFDbEMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFO2dCQUM3QixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxPQUFPLENBQUMsQ0FBQTtZQUMvQyxDQUFDLENBQUMsQ0FBQTtRQUNILENBQUM7S0FBQTtJQUVELFdBQVcsQ0FDVixRQUFxQixFQUNyQixJQUE0QjtRQUU1QixJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxFQUFFLENBQUM7WUFDM0QsbUNBQWdCLENBQUMsa0NBQWtDLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQTtRQUMz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",
    "./packages/profiler-core/dist/src/model/ProfilerConfig.js": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProfilerConfig = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst BaseModel_1 = require(\"./BaseModel\");\nconst config_1 = require(\"../constants/config\");\nconst PathUtils_1 = require(\"../helper/PathUtils\");\nconst UnifiedPath_1 = require(\"../system/UnifiedPath\");\nconst Crypto_1 = require(\"../system/Crypto\");\nconst PermissionHelper_1 = require(\"../helper/PermissionHelper\");\n// Types\nconst types_1 = require(\"../types\");\nclass ProfilerConfig extends BaseModel_1.BaseModel {\n    constructor(filePath, config) {\n        super();\n        this.filePath = filePath;\n        this.extends = config.extends;\n        this.registryOptions = config.registryOptions;\n        this.exportOptions = config.exportOptions;\n        this.projectOptions = config.projectOptions;\n        this.runtimeOptions = config.runtimeOptions;\n    }\n    static getDefaultConfig() {\n        return new ProfilerConfig(new UnifiedPath_1.UnifiedPath(process.cwd()).join(config_1.STATIC_CONFIG_FILENAME), config_1.DEFAULT_PROFILER_CONFIG);\n    }\n    getAnonymizedRuntimeOptions() {\n        if (this.runtimeOptions.sensorInterface) {\n            switch (this.runtimeOptions.sensorInterface.type) {\n                case types_1.SensorInterfaceType.windows:\n                    return Object.assign(Object.assign({}, this.runtimeOptions), { sensorInterface: {\n                            type: types_1.SensorInterfaceType.windows,\n                            options: {\n                                sampleInterval: this.runtimeOptions.sensorInterface.options.sampleInterval,\n                                outputFilePath: '<anonymized>'\n                            }\n                        } });\n                case types_1.SensorInterfaceType.perf:\n                    return Object.assign(Object.assign({}, this.runtimeOptions), { sensorInterface: {\n                            type: types_1.SensorInterfaceType.perf,\n                            options: {\n                                sampleInterval: this.runtimeOptions.sensorInterface.options.sampleInterval,\n                                outputFilePath: '<anonymized>'\n                            }\n                        } });\n                case types_1.SensorInterfaceType.powermetrics:\n                    return Object.assign(Object.assign({}, this.runtimeOptions), { sensorInterface: {\n                            type: types_1.SensorInterfaceType.powermetrics,\n                            options: {\n                                sampleInterval: this.runtimeOptions.sensorInterface.options.sampleInterval,\n                                outputFilePath: '<anonymized>'\n                            }\n                        } });\n            }\n        }\n        return this.runtimeOptions;\n    }\n    getV8CPUSamplingInterval() {\n        return this.runtimeOptions.v8.cpu.sampleInterval;\n    }\n    getRegistryUploadUrl() {\n        return `http://${this.registryOptions.url}/upload`;\n    }\n    uploadEnabled() {\n        var _a, _b;\n        return (((_a = this.registryOptions) === null || _a === void 0 ? void 0 : _a.url) !== undefined) && ((_b = this.registryOptions) === null || _b === void 0 ? void 0 : _b.url) !== '';\n    }\n    getProjectIdentifier() {\n        if (!Crypto_1.Crypto.validateUniqueID(this.projectOptions.identifier)) {\n            throw new Error('ProfilerConfig.getProjectIdentifier: identifier should be an uuid4');\n        }\n        return this.projectOptions.identifier;\n    }\n    getRootDir() {\n        if (PathUtils_1.PathUtils.isAbsolute(this.exportOptions.rootDir)) {\n            return new UnifiedPath_1.UnifiedPath(this.exportOptions.rootDir);\n        }\n        return this.filePath.dirName().join(this.exportOptions.rootDir);\n    }\n    getOutDir() {\n        if (PathUtils_1.PathUtils.isAbsolute(this.exportOptions.outDir)) {\n            return new UnifiedPath_1.UnifiedPath(this.exportOptions.outDir);\n        }\n        return this.filePath.dirName().join(this.exportOptions.outDir);\n    }\n    getOutHistoryDir() {\n        if (PathUtils_1.PathUtils.isAbsolute(this.exportOptions.outHistoryDir)) {\n            return new UnifiedPath_1.UnifiedPath(this.exportOptions.outHistoryDir);\n        }\n        return this.filePath.dirName().join(this.exportOptions.outHistoryDir);\n    }\n    getSensorInterfaceType() {\n        var _a;\n        return (_a = this.runtimeOptions.sensorInterface) === null || _a === void 0 ? void 0 : _a.type;\n    }\n    getSensorInterfaceOptions() {\n        var _a;\n        return (_a = this.runtimeOptions.sensorInterface) === null || _a === void 0 ? void 0 : _a.options;\n    }\n    shouldExportV8Profile() {\n        return this.exportOptions.exportV8Profile;\n    }\n    shouldExportReport() {\n        return this.exportOptions.exportReport;\n    }\n    shouldExportSensorInterfaceData() {\n        return this.exportOptions.exportSensorInterfaceData;\n    }\n    getSeedForMathRandom() {\n        return this.runtimeOptions.seeds['Math.random'];\n    }\n    configAsExtended(pathDiff) {\n        const exportOptions = this.exportOptions;\n        if (exportOptions) {\n            if (exportOptions.outDir && !PathUtils_1.PathUtils.isAbsolute(exportOptions.outDir)) {\n                exportOptions.outDir = pathDiff.join(exportOptions.outDir).toString();\n            }\n            if (exportOptions.outHistoryDir && !PathUtils_1.PathUtils.isAbsolute(exportOptions.outHistoryDir)) {\n                exportOptions.outHistoryDir = pathDiff.join(exportOptions.outHistoryDir).toString();\n            }\n            if (exportOptions.rootDir && !PathUtils_1.PathUtils.isAbsolute(exportOptions.rootDir)) {\n                exportOptions.rootDir = pathDiff.join(exportOptions.rootDir).toString();\n            }\n        }\n        return {\n            exportOptions: exportOptions,\n            projectOptions: this.projectOptions,\n            runtimeOptions: this.runtimeOptions,\n            registryOptions: this.registryOptions\n        };\n    }\n    /**\n     * Fills unspecified values of the config with values of the given config\n     *\n     * example usage:\n     * - every config that gets resolved inherits values of the default config (baseConfig)\n     * \t\tto ensure that unspecified values are filled with the default value. This happens via:\n     * \t\tconfig.implement(baseConfig):\n     *\n     * - if a config contains the extends keyword like this:\n     * \t\t{\n     * \t \t\t\"extends\": \"<config that gets extended>\"\n     * \t\t}\n     * \t\tthe config gets extended via:\n     * \t\tconfig.implement(<config that gets extended>):\n     *\n     * it also adjusts the inherited path values values to make them relative to the config\n     *\n     *\n     * @param config to inherit from\n     */\n    implement(config) {\n        var _a, _b, _c, _d, _e, _f;\n        const pathDiff = this.filePath.dirName().pathTo(config.filePath.dirName());\n        const configToExtend = config.configAsExtended(pathDiff);\n        const newExportOptions = Object.assign(Object.assign({}, configToExtend.exportOptions), this.exportOptions);\n        const newProjectOptions = Object.assign(Object.assign({}, configToExtend.projectOptions), this.projectOptions);\n        const newRuntimeOptions = Object.assign(Object.assign(Object.assign({}, configToExtend.runtimeOptions), this.runtimeOptions), { seeds: Object.assign(Object.assign({}, (((_a = configToExtend === null || configToExtend === void 0 ? void 0 : configToExtend.runtimeOptions) === null || _a === void 0 ? void 0 : _a.seeds) || {})), (((_b = this.runtimeOptions) === null || _b === void 0 ? void 0 : _b.seeds) || {})), v8: {\n                cpu: Object.assign(Object.assign({}, (((_d = (_c = configToExtend.runtimeOptions) === null || _c === void 0 ? void 0 : _c.v8) === null || _d === void 0 ? void 0 : _d.cpu) || {})), (((_f = (_e = this.runtimeOptions) === null || _e === void 0 ? void 0 : _e.v8) === null || _f === void 0 ? void 0 : _f.cpu) || {}))\n            } });\n        const newRegistryOptions = Object.assign(Object.assign({}, configToExtend.registryOptions), this.registryOptions);\n        this.exportOptions = newExportOptions;\n        this.projectOptions = newProjectOptions;\n        this.runtimeOptions = newRuntimeOptions;\n        this.registryOptions = newRegistryOptions;\n    }\n    static fromJSON(json) {\n        let data;\n        if (typeof json === 'string') {\n            data = JSON.parse(json);\n        }\n        else {\n            data = json;\n        }\n        if (data.projectOptions === undefined ||\n            data.projectOptions.identifier === undefined) {\n            throw new Error('ProfilerConfig: the project has no identifier yet');\n        }\n        if (!Crypto_1.Crypto.validateUniqueID(data.projectOptions.identifier)) {\n            throw new Error('ProfilerConfig.getProjectIdentifier: Loaded identifier from the config should be an uuid4');\n        }\n        return new ProfilerConfig(new UnifiedPath_1.UnifiedPath(''), {\n            extends: data.extends,\n            exportOptions: data.exportOptions,\n            projectOptions: data.projectOptions,\n            runtimeOptions: data.runtimeOptions,\n            registryOptions: data.registryOptions\n        });\n    }\n    toJSON() {\n        return ({\n            extends: this.extends,\n            exportOptions: this.exportOptions,\n            projectOptions: this.projectOptions,\n            runtimeOptions: this.runtimeOptions,\n            registryOptions: this.registryOptions\n        });\n    }\n    storeToFile(filePath) {\n        if (!fs.existsSync(filePath.dirName().toPlatformString())) {\n            PermissionHelper_1.PermissionHelper.mkdirRecursivelyWithUserPermission(filePath.dirName().toPlatformString());\n        }\n        PermissionHelper_1.PermissionHelper.writeFileWithUserPermission(filePath.toPlatformString(), JSON.stringify(this, null, 2));\n    }\n    // loads a config from a given file path and extends it\n    // this method is NOT used to ensure load a valid (complete) config, use resolveFromFile to achieve that\n    static loadFromFile(filePath) {\n        if (!fs.existsSync(filePath.toPlatformString())) {\n            return undefined;\n        }\n        const loadedConfig = ProfilerConfig.fromJSON(fs.readFileSync(filePath.toPlatformString()).toString());\n        loadedConfig.filePath = filePath;\n        if (loadedConfig.extends) {\n            const configToExtendFilePath = filePath.dirName().join(loadedConfig.extends);\n            const configToExtend = ProfilerConfig.loadFromFile(configToExtendFilePath);\n            if (configToExtend) {\n                loadedConfig.implement(configToExtend);\n                return loadedConfig;\n            }\n        }\n        return loadedConfig;\n    }\n    // loads a config from a given file path and fills all non defined values with the resp. default values\n    static resolveFromFile(filePath) {\n        const baseConfig = ProfilerConfig.getDefaultConfig();\n        if (!filePath) {\n            return baseConfig;\n        }\n        const config = this.loadFromFile(filePath);\n        if (config) {\n            baseConfig.filePath = config.filePath;\n            config.implement(baseConfig);\n            return config;\n        }\n        return baseConfig;\n    }\n    static autoResolveFromPath(startDir) {\n        // Searches from the given path upwards until it finds the config file\n        const configFilePath = PathUtils_1.PathUtils.findUp(config_1.STATIC_CONFIG_FILENAME, startDir.toPlatformString());\n        if (!configFilePath) {\n            return ProfilerConfig.resolveFromFile(undefined);\n        }\n        return ProfilerConfig.resolveFromFile(new UnifiedPath_1.UnifiedPath(configFilePath));\n    }\n    static autoResolve() {\n        // Searches from the processes execution path upwards until it finds the config file\n        return this.autoResolveFromPath(new UnifiedPath_1.UnifiedPath(process.cwd()));\n    }\n}\nexports.ProfilerConfig = ProfilerConfig;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvZmlsZXJDb25maWcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbW9kZWwvUHJvZmlsZXJDb25maWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx1Q0FBd0I7QUFFeEIsMkNBQXVDO0FBRXZDLGdEQUc0QjtBQUM1QixtREFBK0M7QUFDL0MsdURBQW1EO0FBQ25ELDZDQUF5QztBQUN6QyxpRUFBNkQ7QUFDN0QsUUFBUTtBQUNSLG9DQVlpQjtBQUVqQixNQUFhLGNBQWUsU0FBUSxxQkFBUztJQVE1QyxZQUFZLFFBQXFCLEVBQUUsTUFBdUI7UUFDekQsS0FBSyxFQUFFLENBQUE7UUFDUCxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQTtRQUN4QixJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUE7UUFDN0IsSUFBSSxDQUFDLGVBQWUsR0FBRyxNQUFNLENBQUMsZUFBZSxDQUFBO1FBQzdDLElBQUksQ0FBQyxhQUFhLEdBQUcsTUFBTSxDQUFDLGFBQWEsQ0FBQTtRQUN6QyxJQUFJLENBQUMsY0FBYyxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUE7UUFDM0MsSUFBSSxDQUFDLGNBQWMsR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFBO0lBQzVDLENBQUM7SUFFRCxNQUFNLENBQUMsZ0JBQWdCO1FBQ3RCLE9BQU8sSUFBSSxjQUFjLENBQ3hCLElBQUkseUJBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsK0JBQXNCLENBQUMsRUFDM0QsZ0NBQXVCLENBQ3ZCLENBQUE7SUFDRixDQUFDO0lBRUQsMkJBQTJCO1FBQzFCLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUN6QyxRQUFRLElBQUksQ0FBQyxjQUFjLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNsRCxLQUFLLDJC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",
    "./packages/profiler-core/dist/src/helper/PathUtils.js": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathUtils = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst path = __importStar(require(\"path\"));\nconst pathCollator = new Intl.Collator(undefined, {\n    numeric: true,\n    sensitivity: 'base'\n});\nclass PathUtils {\n    static sortFilePathArray(filePathArray) {\n        filePathArray.sort(pathCollator.compare);\n    }\n    static getPathRelativeTo(from, to) {\n        return path.relative(from, to);\n    }\n    static makeAbsolute(startDir, relativeFilePath) {\n        if (PathUtils.isAbsolute(relativeFilePath)) {\n            return relativeFilePath;\n        }\n        return path.normalize(path.join(startDir, relativeFilePath));\n    }\n    static isAbsolute(pathString) {\n        return path.isAbsolute(pathString) || /^(?:[a-zA-Z]:)?\\\\?\\\\(?:[^\\\\/:*?\"<>|\\r\\n]+\\\\)*[^\\\\/:*?\"<>|\\r\\n]*$/.test(pathString);\n    }\n    static unifyPath(pathString) {\n        if (pathString === '' || pathString === '.' || pathString === './') {\n            return './';\n        }\n        if (pathString === '/') {\n            return '/';\n        }\n        if (pathString === '../') {\n            return '../';\n        }\n        const isAbsolute = PathUtils.isAbsolute(pathString);\n        pathString = pathString.replace(/\\\\/g, '/');\n        pathString = pathString.replace(/\\/+$/g, '');\n        if (!isAbsolute) {\n            if (pathString.slice(0, 2) !== './' && pathString.slice(0, 3) !== '../') {\n                return './' + pathString;\n            }\n        }\n        return pathString;\n    }\n    static findUp(filename, startDir) {\n        const { root } = path.parse(startDir);\n        let tmpDir = startDir;\n        while (tmpDir !== root) {\n            let list;\n            try {\n                list = fs.readdirSync(tmpDir);\n            }\n            catch (e) {\n                break;\n            }\n            if (list.includes(filename) && fs.statSync(path.join(tmpDir, filename)).isFile()) {\n                // found\n                return path.join(tmpDir, filename);\n            }\n            else {\n                tmpDir = path.normalize(path.join(tmpDir, '..'));\n            }\n        }\n        return undefined;\n    }\n}\nexports.PathUtils = PathUtils;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGF0aFV0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2hlbHBlci9QYXRoVXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx1Q0FBd0I7QUFDeEIsMkNBQTRCO0FBRTVCLE1BQU0sWUFBWSxHQUFHLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUU7SUFDakQsT0FBTyxFQUFFLElBQUk7SUFDYixXQUFXLEVBQUUsTUFBTTtDQUNuQixDQUFDLENBQUE7QUFFRixNQUFhLFNBQVM7SUFDckIsTUFBTSxDQUFDLGlCQUFpQixDQUFDLGFBQXVCO1FBQy9DLGFBQWEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFBO0lBQ3pDLENBQUM7SUFFRCxNQUFNLENBQUMsaUJBQWlCLENBQUMsSUFBWSxFQUFFLEVBQVU7UUFDaEQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQTtJQUMvQixDQUFDO0lBRUQsTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUFnQixFQUFFLGdCQUF3QjtRQUM3RCxJQUFJLFNBQVMsQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDO1lBQzVDLE9BQU8sZ0JBQWdCLENBQUE7UUFDeEIsQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDLENBQUE7SUFDN0QsQ0FBQztJQUVELE1BQU0sQ0FBQyxVQUFVLENBQUMsVUFBa0I7UUFDbkMsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLGtFQUFrRSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQTtJQUMxSCxDQUFDO0lBRUQsTUFBTSxDQUFDLFNBQVMsQ0FBQyxVQUFrQjtRQUNsQyxJQUFJLFVBQVUsS0FBSyxFQUFFLElBQUksVUFBVSxLQUFLLEdBQUcsSUFBSSxVQUFVLEtBQUssSUFBSSxFQUFFLENBQUM7WUFDcEUsT0FBTyxJQUFJLENBQUE7UUFDWixDQUFDO1FBQ0QsSUFBSSxVQUFVLEtBQUssR0FBRyxFQUFFLENBQUM7WUFDeEIsT0FBTyxHQUFHLENBQUE7UUFDWCxDQUFDO1FBQ0QsSUFBSSxVQUFVLEtBQUssS0FBSyxFQUFFLENBQUM7WUFDMUIsT0FBTyxLQUFLLENBQUE7UUFDYixDQUFDO1FBQ0QsTUFBTSxVQUFVLEdBQUcsU0FBUyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQTtRQUNuRCxVQUFVLEdBQUcsVUFBVSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUE7UUFDM0MsVUFBVSxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFBO1FBQzVDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUNqQixJQUFJLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLElBQUksSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxLQUFLLEVBQUUsQ0FBQztnQkFDekUsT0FBTyxJQUFJLEdBQUcsVUFBVSxDQUFBO1lBQ3pCLENBQUM7UUFDRixDQUFDO1FBQ0QsT0FBTyxVQUFVLENBQUE7SUFDbEIsQ0FBQztJQUVELE1BQU0sQ0FBQyxNQUFNLENBQ1osUUFBZ0IsRUFDaEIsUUFBZ0I7UUFFaEIsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUE7UUFFckMsSUFBSSxNQUFNLEdBQUcsUUFBUSxDQUFBO1FBRXJCLE9BQU8sTUFBTSxLQUFLLElBQUksRUFBRSxDQUFDO1lBQ3hCLElBQUksSUFBYyxDQUFBO1lBQ2xCLElBQUksQ0FBQztnQkFDSixJQUFJLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQTtZQUM5QixDQUFDO1lBQUMsT0FBTyxDQUFNLEVBQUUsQ0FBQztnQkFDakIsTUFBSztZQUNOLENBQUM7WUFDRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUM7Z0JBQ2xGLFFBQVE7Z0JBQ1IsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQTtZQUNuQyxDQUFDO2lCQUFNLENBQUM7Z0JBQ1AsTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQTtZQUNqRCxDQUFDO1FBQ0YsQ0FBQztRQUNELE9BQU8sU0FBUyxDQUFBO0lBQ2pCLENBQUM7Q0FDRDtBQWpFRCw4QkFpRUMifQ==",
    "./packages/profiler-core/dist/src/system/UnifiedPath.js": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnifiedPath = void 0;\nconst path = __importStar(require(\"path\"));\nconst PathUtils_1 = require(\"../helper/PathUtils\");\nclass UnifiedPath {\n    constructor(...args) {\n        if (args.length === 0 || args.length === 1) {\n            this._unifiedPath = PathUtils_1.PathUtils.unifyPath(args[0] || '');\n        }\n        else {\n            this._unifiedPath = PathUtils_1.PathUtils.unifyPath(args.join('/'));\n        }\n    }\n    static fromPathParts(parts) {\n        return new UnifiedPath(parts[0]).join(...parts.slice(1));\n    }\n    copy() {\n        return new UnifiedPath(this._unifiedPath);\n    }\n    /**\n     * String representation of a UnifiedPath\n     *\n     * @returns\n     */\n    toString() {\n        return this._unifiedPath;\n    }\n    /**\n     * Returns UnifiedPath as a string for the current platform\n     *\n     * @returns\n     */\n    toPlatformString() {\n        return this._unifiedPath.split('/').join(path.sep);\n    }\n    /**\n     * JSON representation of a UnifiedPath\n     *\n     * @returns\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Returns the directory name of a path\n     *\n     * @returns\n     */\n    dirName() {\n        return new UnifiedPath(path.dirname(this.toString()));\n    }\n    /**\n     * Returns the basename name of a path\n     *\n     * @returns The basename of the path (path/to/index.coffee.md -> index.coffee.md)\n     */\n    basename() {\n        return path.basename(this.toString());\n    }\n    /**\n     * Returns the extension of a path\n     *\n     * @returns The extension of the path (path/to/index.coffee.md -> .md)\n     */\n    extname() {\n        return path.extname(this.basename());\n    }\n    isRelative() {\n        return this._unifiedPath === '' || (this._unifiedPath[0] !== '/' && !this.isAbsoluteWindowsPath());\n    }\n    isAbsoluteWindowsPath() {\n        return /^[A-Za-z]:/.test(this._unifiedPath);\n    }\n    /**\n     * Gives the relative UnifiedPath that points from this to the other path\n     *\n     * @param other\n     * @returns\n     */\n    pathTo(other) {\n        if (typeof other === 'string') {\n            other = new UnifiedPath(other);\n        }\n        return new UnifiedPath(PathUtils_1.PathUtils.getPathRelativeTo(this.toString(), other.toString()));\n    }\n    /**\n     * Splits the path into an array of it's components\n     *\n     * @returns\n     */\n    split() {\n        if (!this._parts) {\n            const parts = this._unifiedPath.split('/');\n            if (parts[0] === '' && parts.length > 1) {\n                parts[0] = '/';\n            }\n            if (parts[0] === '.' && parts.length > 1) {\n                parts.splice(0, 1);\n            }\n            this._parts = parts;\n        }\n        return this._parts;\n    }\n    join(...args) {\n        if (args.length === 0) {\n            return new UnifiedPath(this._unifiedPath);\n        }\n        const parts = [];\n        for (const part of args) {\n            if (typeof part === 'string') {\n                parts.push(new UnifiedPath(part).toString());\n            }\n            else {\n                parts.push(part.toString());\n            }\n        }\n        return new UnifiedPath(path.posix.join(this._unifiedPath, ...parts));\n    }\n    /**\n     * Returns the unified path from the root of the path to the first occurrence of the given directory\n     * and the remainder\n     *\n     * /path/to/node_modules/node_module_name/file -> /path/to/node_modules\n     *\n     * @param dirName\n     * @returns\n     */\n    pathUntilSubDir(dirName) {\n        const pathParts = this.split();\n        const firstMatch = pathParts.indexOf(dirName);\n        if (firstMatch !== -1) {\n            return {\n                match: new UnifiedPath(path.posix.join(...pathParts.slice(0, firstMatch + 1))),\n                remainder: new UnifiedPath(path.posix.join(...pathParts.slice(firstMatch + 1))),\n            };\n        }\n        return undefined;\n    }\n}\nexports.UnifiedPath = UnifiedPath;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVW5pZmllZFBhdGguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvc3lzdGVtL1VuaWZpZWRQYXRoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTRCO0FBRTVCLG1EQUErQztBQU8vQyxNQUFhLFdBQVc7SUFJdkIsWUFBWSxHQUFHLElBQWM7UUFDNUIsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQzVDLElBQUksQ0FBQyxZQUFZLEdBQUcscUJBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFBO1FBQ3ZELENBQUM7YUFBTSxDQUFDO1lBQ1AsSUFBSSxDQUFDLFlBQVksR0FBRyxxQkFBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUE7UUFDeEQsQ0FBQztJQUNGLENBQUM7SUFFRCxNQUFNLENBQUMsYUFBYSxDQUFDLEtBQWU7UUFDbkMsT0FBTyxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7SUFDekQsQ0FBQztJQUVELElBQUk7UUFDSCxPQUFPLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQTtJQUMxQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFFBQVE7UUFDUCxPQUFPLElBQUksQ0FBQyxZQUFrQyxDQUFBO0lBQy9DLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsZ0JBQWdCO1FBQ2YsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FB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",
    "./packages/profiler/examples/example002.ts": "import minifier from 'html-minifier'\n\nimport { Profiler } from '../src/index'\n\nconst profile = new Profiler('example002')\n\nasync function main() {\n\tconst title = 'latest'\n\tawait profile.start(title)\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst result = minifier.minify('<style>* { font-size: 11px }</style><p title=\"blah\" id=\"moo\">foo</p>', {\n\t\tminifyCSS: true\n\t})\n\n\tawait profile.finish(title)\n}\n\nmain()",
    "./packages/profiler-core/dist/src/helper/PerformanceHelper.js": "\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PerformanceHelper = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst TimeHelper_1 = require(\"./TimeHelper\");\nconst PermissionHelper_1 = require(\"./PermissionHelper\");\nconst ENABLE_PERFORMANCE_TRACKING = process.env.OAKLEAN_ENABLE_PERFORMANCE_TRACKING !== undefined;\nclass PerformanceHelper {\n    constructor() {\n        this._measures = new Map();\n        this._firstMeasure = BigInt(0);\n        this._lastMeasure = BigInt(0);\n    }\n    static loadFromFile(path) {\n        if (fs_1.default.existsSync(path.toPlatformString())) {\n            const jsonString = fs_1.default.readFileSync(path.toPlatformString(), 'utf8').toString();\n            return JSON.parse(jsonString);\n        }\n        return { measures: {} };\n    }\n    static storeToFile(path, data) {\n        const dir = path.dirName();\n        if (!fs_1.default.existsSync(dir.toPlatformString())) {\n            PermissionHelper_1.PermissionHelper.mkdirRecursivelyWithUserPermission(dir);\n        }\n        fs_1.default.writeFileSync(path.toPlatformString(), JSON.stringify(data, null, 2));\n    }\n    exportAndSum(path) {\n        if (!ENABLE_PERFORMANCE_TRACKING) {\n            return;\n        }\n        const report = PerformanceHelper.loadFromFile(path);\n        for (const [name, measure] of this._measures) {\n            if (measure.end) {\n                const diff = Number(measure.end - measure.start);\n                report.measures[name] = (report.measures[name] || 0) + diff;\n            }\n        }\n        PerformanceHelper.storeToFile(path, report);\n    }\n    start(name) {\n        if (!ENABLE_PERFORMANCE_TRACKING) {\n            return;\n        }\n        const time = TimeHelper_1.TimeHelper.getCurrentHighResolutionTime();\n        if (!this._firstMeasure) {\n            this._firstMeasure = time;\n        }\n        this._measures.set(name, {\n            start: time,\n            end: null\n        });\n    }\n    stop(name) {\n        if (!ENABLE_PERFORMANCE_TRACKING) {\n            return;\n        }\n        const time = TimeHelper_1.TimeHelper.getCurrentHighResolutionTime();\n        this._lastMeasure = time;\n        const measure = this._measures.get(name);\n        if (measure) {\n            measure.end = time;\n        }\n    }\n    static printAccumulatedReport(path) {\n        const loadedReport = PerformanceHelper.loadFromFile(path);\n        console.log('Accumulated performance report:');\n        const report = {};\n        for (const name of Object.keys(loadedReport.measures)) {\n            report[name] = {\n                'Duration': `${(loadedReport.measures[name] / 1e9).toFixed(3)} s`\n            };\n        }\n        console.table(report, ['Duration']);\n    }\n    printReport(title) {\n        if (!ENABLE_PERFORMANCE_TRACKING) {\n            return;\n        }\n        const report = {};\n        const total = Number(this._lastMeasure - this._firstMeasure);\n        for (const [name, measure] of this._measures) {\n            if (measure.end) {\n                const diff = Number(measure.end - measure.start);\n                report[name] = {\n                    'Duration': `${(diff / 1e9).toFixed(3)} s`,\n                    'Percentage': `${((diff / total) * 100).toFixed(2)} %`\n                };\n            }\n            else {\n                report[name] = {\n                    'Duration': 'N/A',\n                    'Percentage': 'N/A'\n                };\n            }\n        }\n        console.log(`Performance report (${title}):`, (total / 1e9).toFixed(3), 's');\n        console.table(report, ['Duration', 'Percentage']);\n    }\n}\nexports.PerformanceHelper = PerformanceHelper;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGVyZm9ybWFuY2VIZWxwZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvaGVscGVyL1BlcmZvcm1hbmNlSGVscGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDRDQUFtQjtBQUVuQiw2Q0FBeUM7QUFDekMseURBQXFEO0FBVXJELE1BQU0sMkJBQTJCLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQ0FBbUMsS0FBSyxTQUFTLENBQUE7QUFFakcsTUFBYSxpQkFBaUI7SUFLN0I7UUFDQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksR0FBRyxFQUFnQyxDQUFBO1FBQ3hELElBQUksQ0FBQyxhQUFhLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBdUIsQ0FBQTtRQUNwRCxJQUFJLENBQUMsWUFBWSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQXVCLENBQUE7SUFDcEQsQ0FBQztJQUVELE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBaUI7UUFDcEMsSUFBSSxZQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLEVBQUUsQ0FBQztZQUM1QyxNQUFNLFVBQVUsR0FBRyxZQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFBO1lBQzlFLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQXVCLENBQUE7UUFDcEQsQ0FBQztRQUNELE9BQU8sRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFLENBQUE7SUFDeEIsQ0FBQztJQUVELE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBaUIsRUFBRSxJQUF3QjtRQUM3RCxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUE7UUFDMUIsSUFBSSxDQUFDLFlBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLGdCQUFnQixFQUFFLENBQUMsRUFBRSxDQUFDO1lB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"
  }
}