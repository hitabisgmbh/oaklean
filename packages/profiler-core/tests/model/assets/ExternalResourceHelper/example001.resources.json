{
  "fileInfoPerScriptID": {
    "13": {
      "sourceCode": "'use strict';\n\n// HOW and WHY the timers implementation works the way it does.\n//\n// Timers are crucial to Node.js. Internally, any TCP I/O connection creates a\n// timer so that we can time out of connections. Additionally, many user\n// libraries and applications also use timers. As such there may be a\n// significantly large amount of timeouts scheduled at any given time.\n// Therefore, it is very important that the timers implementation is performant\n// and efficient.\n//\n// Note: It is suggested you first read through the lib/internal/linkedlist.js\n// linked list implementation, since timers depend on it extensively. It can be\n// somewhat counter-intuitive at first, as it is not actually a class. Instead,\n// it is a set of helpers that operate on an existing object.\n//\n// In order to be as performant as possible, the architecture and data\n// structures are designed so that they are optimized to handle the following\n// use cases as efficiently as possible:\n\n// - Adding a new timer. (insert)\n// - Removing an existing timer. (remove)\n// - Handling a timer timing out. (timeout)\n//\n// Whenever possible, the implementation tries to make the complexity of these\n// operations as close to constant-time as possible.\n// (So that performance is not impacted by the number of scheduled timers.)\n//\n// Object maps are kept which contain linked lists keyed by their duration in\n// milliseconds.\n//\n/* eslint-disable node-core/non-ascii-character */\n//\n// ╔════ > Object Map\n// ║\n// ╠══\n// ║ lists: { '40': { }, '320': { etc } } (keys of millisecond duration)\n// ╚══          ┌────┘\n//              │\n// ╔══          │\n// ║ TimersList { _idleNext: { }, _idlePrev: (self) }\n// ║         ┌────────────────┘\n// ║    ╔══  │                              ^\n// ║    ║    { _idleNext: { },  _idlePrev: { }, _onTimeout: (callback) }\n// ║    ║      ┌───────────┘\n// ║    ║      │                                  ^\n// ║    ║      { _idleNext: { etc },  _idlePrev: { }, _onTimeout: (callback) }\n// ╠══  ╠══\n// ║    ║\n// ║    ╚════ >  Actual JavaScript timeouts\n// ║\n// ╚════ > Linked List\n//\n/* eslint-enable node-core/non-ascii-character */\n//\n// With this, virtually constant-time insertion (append), removal, and timeout\n// is possible in the JavaScript layer. Any one list of timers is able to be\n// sorted by just appending to it because all timers within share the same\n// duration. Therefore, any timer added later will always have been scheduled to\n// timeout later, thus only needing to be appended.\n// Removal from an object-property linked list is also virtually constant-time\n// as can be seen in the lib/internal/linkedlist.js implementation.\n// Timeouts only need to process any timers currently due to expire, which will\n// always be at the beginning of the list for reasons stated above. Any timers\n// after the first one encountered that does not yet need to timeout will also\n// always be due to timeout at a later time.\n//\n// Less-than constant time operations are thus contained in two places:\n// The PriorityQueue — an efficient binary heap implementation that does all\n// operations in worst-case O(log n) time — which manages the order of expiring\n// Timeout lists and the object map lookup of a specific list by the duration of\n// timers within (or creation of a new list). However, these operations combined\n// have shown to be trivial in comparison to other timers architectures.\n\nconst {\n  MathMax,\n  MathTrunc,\n  NumberIsFinite,\n  NumberMIN_SAFE_INTEGER,\n  ReflectApply,\n  Symbol,\n} = primordials;\n\nconst binding = internalBinding('timers');\nconst {\n  immediateInfo,\n  timeoutInfo,\n} = binding;\n\nconst {\n  getDefaultTriggerAsyncId,\n  newAsyncId,\n  initHooksExist,\n  destroyHooksExist,\n  // The needed emit*() functions.\n  emitInit,\n  emitBefore,\n  emitAfter,\n  emitDestroy,\n} = require('internal/async_hooks');\n\n// Symbols for storing async id state.\nconst async_id_symbol = Symbol('asyncId');\nconst trigger_async_id_symbol = Symbol('triggerId');\n\nconst kHasPrimitive = Symbol('kHasPrimitive');\n\nconst {\n  ERR_OUT_OF_RANGE,\n} = require('internal/errors').codes;\nconst {\n  validateFunction,\n  validateNumber,\n} = require('internal/validators');\n\nconst L = require('internal/linkedlist');\nconst PriorityQueue = require('internal/priority_queue');\n\nconst { inspect } = require('internal/util/inspect');\nlet debug = require('internal/util/debuglog').debuglog('timer', (fn) => {\n  debug = fn;\n});\n\n// *Must* match Environment::ImmediateInfo::Fields in src/env.h.\nconst kCount = 0;\nconst kRefCount = 1;\nconst kHasOutstanding = 2;\n\n// Timeout values > TIMEOUT_MAX are set to 1.\nconst TIMEOUT_MAX = 2 ** 31 - 1;\n\nlet timerListId = NumberMIN_SAFE_INTEGER;\n\nconst kRefed = Symbol('refed');\n\nlet nextExpiry = Infinity;\n// timeoutInfo is an Int32Array that contains the reference count of Timeout\n// objects at index 0. This is a TypedArray so that GetActiveResourcesInfo() in\n// `src/node_process_methods.cc` is able to access this value without crossing\n// the JS-C++ boundary, which is slow at the time of writing.\ntimeoutInfo[0] = 0;\n\n// This is a priority queue with a custom sorting function that first compares\n// the expiry times of two lists and if they're the same then compares their\n// individual IDs to determine which list was created first.\nconst timerListQueue = new PriorityQueue(compareTimersLists, setPosition);\n\n// Object map containing linked lists of timers, keyed and sorted by their\n// duration in milliseconds.\n//\n// - key = time in milliseconds\n// - value = linked list\nconst timerListMap = { __proto__: null };\n\nfunction initAsyncResource(resource, type) {\n  const asyncId = resource[async_id_symbol] = newAsyncId();\n  const triggerAsyncId =\n    resource[trigger_async_id_symbol] = getDefaultTriggerAsyncId();\n  if (initHooksExist())\n    emitInit(asyncId, type, triggerAsyncId, resource);\n}\nclass Timeout {\n  // Timer constructor function.\n  // The entire prototype is defined in lib/timers.js\n  constructor(callback, after, args, isRepeat, isRefed) {\n    after *= 1; // Coalesce to number or NaN\n    if (!(after >= 1 && after <= TIMEOUT_MAX)) {\n      if (after > TIMEOUT_MAX) {\n        process.emitWarning(`${after} does not fit into` +\n                            ' a 32-bit signed integer.' +\n                            '\\nTimeout duration was set to 1.',\n                            'TimeoutOverflowWarning');\n      }\n      after = 1; // Schedule on next tick, follows browser behavior\n    }\n\n    this._idleTimeout = after;\n    this._idlePrev = this;\n    this._idleNext = this;\n    this._idleStart = null;\n    // This must be set to null first to avoid function tracking\n    // on the hidden class, revisit in V8 versions after 6.2\n    this._onTimeout = null;\n    this._onTimeout = callback;\n    this._timerArgs = args;\n    this._repeat = isRepeat ? after : null;\n    this._destroyed = false;\n\n    if (isRefed)\n      incRefCount();\n    this[kRefed] = isRefed;\n    this[kHasPrimitive] = false;\n\n    initAsyncResource(this, 'Timeout');\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [inspect.custom](_, options) {\n    return inspect(this, {\n      ...options,\n      // Only inspect one level.\n      depth: 0,\n      // It should not recurse.\n      customInspect: false,\n    });\n  }\n\n  refresh() {\n    if (this[kRefed])\n      active(this);\n    else\n      unrefActive(this);\n\n    return this;\n  }\n\n  unref() {\n    if (this[kRefed]) {\n      this[kRefed] = false;\n      if (!this._destroyed)\n        decRefCount();\n    }\n    return this;\n  }\n\n  ref() {\n    if (!this[kRefed]) {\n      this[kRefed] = true;\n      if (!this._destroyed)\n        incRefCount();\n    }\n    return this;\n  }\n\n  hasRef() {\n    return this[kRefed];\n  }\n}\n\nclass TimersList {\n  constructor(expiry, msecs) {\n    this._idleNext = this; // Create the list with the linkedlist properties to\n    this._idlePrev = this; // Prevent any unnecessary hidden class changes.\n    this.expiry = expiry;\n    this.id = timerListId++;\n    this.msecs = msecs;\n    this.priorityQueuePosition = null;\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [inspect.custom](_, options) {\n    return inspect(this, {\n      ...options,\n      // Only inspect one level.\n      depth: 0,\n      // It should not recurse.\n      customInspect: false,\n    });\n  }\n}\n\n// A linked list for storing `setImmediate()` requests\nclass ImmediateList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  // Appends an item to the end of the linked list, adjusting the current tail's\n  // next pointer and the item's previous pointer where applicable\n  append(item) {\n    if (this.tail !== null) {\n      this.tail._idleNext = item;\n      item._idlePrev = this.tail;\n    } else {\n      this.head = item;\n    }\n    this.tail = item;\n  }\n\n  // Removes an item from the linked list, adjusting the pointers of adjacent\n  // items and the linked list's head or tail pointers as necessary\n  remove(item) {\n    if (item._idleNext) {\n      item._idleNext._idlePrev = item._idlePrev;\n    }\n\n    if (item._idlePrev) {\n      item._idlePrev._idleNext = item._idleNext;\n    }\n\n    if (item === this.head)\n      this.head = item._idleNext;\n    if (item === this.tail)\n      this.tail = item._idlePrev;\n\n    item._idleNext = null;\n    item._idlePrev = null;\n  }\n}\n\n// Create a single linked list instance only once at startup\nconst immediateQueue = new ImmediateList();\n\nfunction incRefCount() {\n  if (timeoutInfo[0]++ === 0) {\n    // We need to use the binding as the receiver for fast API calls.\n    binding.toggleTimerRef(true);\n  }\n}\n\nfunction decRefCount() {\n  if (--timeoutInfo[0] === 0) {\n    // We need to use the binding as the receiver for fast API calls.\n    binding.toggleTimerRef(false);\n  }\n}\n\n// Schedule or re-schedule a timer.\n// The item must have been enroll()'d first.\nfunction active(item) {\n  insertGuarded(item, true);\n}\n\n// Internal APIs that need timeouts should use `unrefActive()` instead of\n// `active()` so that they do not unnecessarily keep the process open.\nfunction unrefActive(item) {\n  insertGuarded(item, false);\n}\n\n// The underlying logic for scheduling or re-scheduling a timer.\n//\n// Appends a timer onto the end of an existing timers list, or creates a new\n// list if one does not already exist for the specified timeout duration.\nfunction insertGuarded(item, refed, start) {\n  const msecs = item._idleTimeout;\n  if (msecs < 0 || msecs === undefined)\n    return;\n\n  insert(item, msecs, start);\n\n  const isDestroyed = item._destroyed;\n  if (isDestroyed || !item[async_id_symbol]) {\n    item._destroyed = false;\n    initAsyncResource(item, 'Timeout');\n  }\n\n  if (isDestroyed) {\n    if (refed)\n      incRefCount();\n  } else if (refed === !item[kRefed]) {\n    if (refed)\n      incRefCount();\n    else\n      decRefCount();\n  }\n  item[kRefed] = refed;\n}\n\n// We need to use the binding as the receiver for fast API calls.\nfunction insert(item, msecs, start = binding.getLibuvNow()) {\n  // Truncate so that accuracy of sub-millisecond timers is not assumed.\n  msecs = MathTrunc(msecs);\n  item._idleStart = start;\n\n  // Use an existing list if there is one, otherwise we need to make a new one.\n  let list = timerListMap[msecs];\n  if (list === undefined) {\n    debug('no %d list was found in insert, creating a new one', msecs);\n    const expiry = start + msecs;\n    timerListMap[msecs] = list = new TimersList(expiry, msecs);\n    timerListQueue.insert(list);\n\n    if (nextExpiry > expiry) {\n      // We need to use the binding as the receiver for fast API calls.\n      binding.scheduleTimer(msecs);\n      nextExpiry = expiry;\n    }\n  }\n\n  L.append(list, item);\n}\n\nfunction setUnrefTimeout(callback, after) {\n  // Type checking identical to setTimeout()\n  validateFunction(callback, 'callback');\n\n  const timer = new Timeout(callback, after, undefined, false, false);\n  insert(timer, timer._idleTimeout);\n\n  return timer;\n}\n\n// Type checking used by timers.enroll() and Socket#setTimeout()\nfunction getTimerDuration(msecs, name) {\n  validateNumber(msecs, name);\n  if (msecs < 0 || !NumberIsFinite(msecs)) {\n    throw new ERR_OUT_OF_RANGE(name, 'a non-negative finite number', msecs);\n  }\n\n  // Ensure that msecs fits into signed int32\n  if (msecs > TIMEOUT_MAX) {\n    process.emitWarning(`${msecs} does not fit into a 32-bit signed integer.` +\n                        `\\nTimer duration was truncated to ${TIMEOUT_MAX}.`,\n                        'TimeoutOverflowWarning');\n    return TIMEOUT_MAX;\n  }\n\n  return msecs;\n}\n\nfunction compareTimersLists(a, b) {\n  const expiryDiff = a.expiry - b.expiry;\n  if (expiryDiff === 0) {\n    if (a.id < b.id)\n      return -1;\n    if (a.id > b.id)\n      return 1;\n  }\n  return expiryDiff;\n}\n\nfunction setPosition(node, pos) {\n  node.priorityQueuePosition = pos;\n}\n\nfunction getTimerCallbacks(runNextTicks) {\n  // If an uncaught exception was thrown during execution of immediateQueue,\n  // this queue will store all remaining Immediates that need to run upon\n  // resolution of all error handling (if process is still alive).\n  const outstandingQueue = new ImmediateList();\n\n  function processImmediate() {\n    const queue = outstandingQueue.head !== null ?\n      outstandingQueue : immediateQueue;\n    let immediate = queue.head;\n\n    // Clear the linked list early in case new `setImmediate()`\n    // calls occur while immediate callbacks are executed\n    if (queue !== outstandingQueue) {\n      queue.head = queue.tail = null;\n      immediateInfo[kHasOutstanding] = 1;\n    }\n\n    let prevImmediate;\n    let ranAtLeastOneImmediate = false;\n    while (immediate !== null) {\n      if (ranAtLeastOneImmediate)\n        runNextTicks();\n      else\n        ranAtLeastOneImmediate = true;\n\n      // It's possible for this current Immediate to be cleared while executing\n      // the next tick queue above, which means we need to use the previous\n      // Immediate's _idleNext which is guaranteed to not have been cleared.\n      if (immediate._destroyed) {\n        outstandingQueue.head = immediate = prevImmediate._idleNext;\n        continue;\n      }\n\n      // TODO(RaisinTen): Destroy and unref the Immediate after _onImmediate()\n      // gets executed, just like how Timeouts work.\n      immediate._destroyed = true;\n\n      immediateInfo[kCount]--;\n      if (immediate[kRefed])\n        immediateInfo[kRefCount]--;\n      immediate[kRefed] = null;\n\n      prevImmediate = immediate;\n\n      const asyncId = immediate[async_id_symbol];\n      emitBefore(asyncId, immediate[trigger_async_id_symbol], immediate);\n\n      try {\n        const argv = immediate._argv;\n        if (!argv)\n          immediate._onImmediate();\n        else\n          immediate._onImmediate(...argv);\n      } finally {\n        immediate._onImmediate = null;\n\n        if (destroyHooksExist())\n          emitDestroy(asyncId);\n\n        outstandingQueue.head = immediate = immediate._idleNext;\n      }\n\n      emitAfter(asyncId);\n    }\n\n    if (queue === outstandingQueue)\n      outstandingQueue.head = null;\n    immediateInfo[kHasOutstanding] = 0;\n  }\n\n\n  function processTimers(now) {\n    debug('process timer lists %d', now);\n    nextExpiry = Infinity;\n\n    let list;\n    let ranAtLeastOneList = false;\n    while ((list = timerListQueue.peek()) != null) {\n      if (list.expiry > now) {\n        nextExpiry = list.expiry;\n        return timeoutInfo[0] > 0 ? nextExpiry : -nextExpiry;\n      }\n      if (ranAtLeastOneList)\n        runNextTicks();\n      else\n        ranAtLeastOneList = true;\n      listOnTimeout(list, now);\n    }\n    return 0;\n  }\n\n  function listOnTimeout(list, now) {\n    const msecs = list.msecs;\n\n    debug('timeout callback %d', msecs);\n\n    let ranAtLeastOneTimer = false;\n    let timer;\n    while ((timer = L.peek(list)) != null) {\n      const diff = now - timer._idleStart;\n\n      // Check if this loop iteration is too early for the next timer.\n      // This happens if there are more timers scheduled for later in the list.\n      if (diff < msecs) {\n        list.expiry = MathMax(timer._idleStart + msecs, now + 1);\n        list.id = timerListId++;\n        timerListQueue.percolateDown(1);\n        debug('%d list wait because diff is %d', msecs, diff);\n        return;\n      }\n\n      if (ranAtLeastOneTimer)\n        runNextTicks();\n      else\n        ranAtLeastOneTimer = true;\n\n      // The actual logic for when a timeout happens.\n      L.remove(timer);\n\n      const asyncId = timer[async_id_symbol];\n\n      if (!timer._onTimeout) {\n        if (!timer._destroyed) {\n          timer._destroyed = true;\n\n          if (timer[kRefed])\n            timeoutInfo[0]--;\n\n          if (destroyHooksExist())\n            emitDestroy(asyncId);\n        }\n        continue;\n      }\n\n      emitBefore(asyncId, timer[trigger_async_id_symbol], timer);\n\n      let start;\n      if (timer._repeat) {\n        // We need to use the binding as the receiver for fast API calls.\n        start = binding.getLibuvNow();\n      }\n\n      try {\n        const args = timer._timerArgs;\n        if (args === undefined)\n          timer._onTimeout();\n        else\n          ReflectApply(timer._onTimeout, timer, args);\n      } finally {\n        if (timer._repeat && timer._idleTimeout !== -1) {\n          timer._idleTimeout = timer._repeat;\n          insert(timer, timer._idleTimeout, start);\n        } else if (!timer._idleNext && !timer._idlePrev && !timer._destroyed) {\n          timer._destroyed = true;\n\n          if (timer[kRefed])\n            timeoutInfo[0]--;\n\n          if (destroyHooksExist())\n            emitDestroy(asyncId);\n        }\n      }\n\n      emitAfter(asyncId);\n    }\n\n    // If `L.peek(list)` returned nothing, the list was either empty or we have\n    // called all of the timer timeouts.\n    // As such, we can remove the list from the object map and\n    // the PriorityQueue.\n    debug('%d list empty', msecs);\n\n    // The current list may have been removed and recreated since the reference\n    // to `list` was created. Make sure they're the same instance of the list\n    // before destroying.\n    if (list === timerListMap[msecs]) {\n      delete timerListMap[msecs];\n      timerListQueue.shift();\n    }\n  }\n\n  return {\n    processImmediate,\n    processTimers,\n  };\n}\n\nclass Immediate {\n  constructor(callback, args) {\n    this._idleNext = null;\n    this._idlePrev = null;\n    this._onImmediate = callback;\n    this._argv = args;\n    this._destroyed = false;\n    this[kRefed] = false;\n\n    initAsyncResource(this, 'Immediate');\n\n    this.ref();\n    immediateInfo[kCount]++;\n\n    immediateQueue.append(this);\n  }\n\n  ref() {\n    if (this[kRefed] === false) {\n      this[kRefed] = true;\n\n      if (immediateInfo[kRefCount]++ === 0) {\n        // We need to use the binding as the receiver for fast API calls.\n        binding.toggleImmediateRef(true);\n      }\n    }\n    return this;\n  }\n\n  unref() {\n    if (this[kRefed] === true) {\n      this[kRefed] = false;\n      if (--immediateInfo[kRefCount] === 0) {\n        // We need to use the binding as the receiver for fast API calls.\n        binding.toggleImmediateRef(false);\n      }\n    }\n    return this;\n  }\n\n  hasRef() {\n    return !!this[kRefed];\n  }\n}\n\nmodule.exports = {\n  TIMEOUT_MAX,\n  kTimeout: Symbol('timeout'), // For hiding Timeouts on other internals.\n  async_id_symbol,\n  trigger_async_id_symbol,\n  Timeout,\n  Immediate,\n  kRefed,\n  kHasPrimitive,\n  initAsyncResource,\n  setUnrefTimeout,\n  getTimerDuration,\n  immediateQueue,\n  getTimerCallbacks,\n  immediateInfoFields: {\n    kCount,\n    kRefCount,\n    kHasOutstanding,\n  },\n  active,\n  unrefActive,\n  insert,\n  timerListMap,\n  timerListQueue,\n  decRefCount,\n  incRefCount,\n};\n"
    },
    "14": {
      "sourceCode": "'use strict';\n\nconst {\n  ArrayPrototypeSlice,\n  ErrorCaptureStackTrace,\n  ObjectPrototypeHasOwnProperty,\n  ObjectDefineProperty,\n  Symbol,\n} = primordials;\n\nconst { exitCodes: { kGenericUserError } } = internalBinding('errors');\n\nconst async_wrap = internalBinding('async_wrap');\nconst { setCallbackTrampoline } = async_wrap;\n/* async_hook_fields is a Uint32Array wrapping the uint32_t array of\n * Environment::AsyncHooks::fields_[]. Each index tracks the number of active\n * hooks for each type.\n *\n * async_id_fields is a Float64Array wrapping the double array of\n * Environment::AsyncHooks::async_id_fields_[]. Each index contains the ids for\n * the various asynchronous states of the application. These are:\n *  kExecutionAsyncId: The async_id assigned to the resource responsible for the\n *    current execution stack.\n *  kTriggerAsyncId: The async_id of the resource that caused (or 'triggered')\n *    the resource corresponding to the current execution stack.\n *  kAsyncIdCounter: Incremental counter tracking the next assigned async_id.\n *  kDefaultTriggerAsyncId: Written immediately before a resource's constructor\n *    that sets the value of the init()'s triggerAsyncId. The precedence order\n *    of retrieving the triggerAsyncId value is:\n *    1. the value passed directly to the constructor\n *    2. value set in kDefaultTriggerAsyncId\n *    3. executionAsyncId of the current resource.\n *\n * async_ids_stack is a Float64Array that contains part of the async ID\n * stack. Each pushAsyncContext() call adds two doubles to it, and each\n * popAsyncContext() call removes two doubles from it.\n * It has a fixed size, so if that is exceeded, calls to the native\n * side are used instead in pushAsyncContext() and popAsyncContext().\n */\nconst {\n  async_hook_fields,\n  async_id_fields,\n  execution_async_resources,\n} = async_wrap;\n// Store the pair executionAsyncId and triggerAsyncId in a AliasedFloat64Array\n// in Environment::AsyncHooks::async_ids_stack_ which tracks the resource\n// responsible for the current execution stack. This is unwound as each resource\n// exits. In the case of a fatal exception this stack is emptied after calling\n// each hook's after() callback.\nconst {\n  pushAsyncContext: pushAsyncContext_,\n  popAsyncContext: popAsyncContext_,\n  executionAsyncResource: executionAsyncResource_,\n  clearAsyncIdStack,\n} = async_wrap;\n// Properties in active_hooks are used to keep track of the set of hooks being\n// executed in case another hook is enabled/disabled. The new set of hooks is\n// then restored once the active set of hooks is finished executing.\nconst active_hooks = {\n  // Array of all AsyncHooks that will be iterated whenever an async event\n  // fires. Using var instead of (preferably const) in order to assign\n  // active_hooks.tmp_array if a hook is enabled/disabled during hook\n  // execution.\n  array: [],\n  // Use a counter to track nested calls of async hook callbacks and make sure\n  // the active_hooks.array isn't altered mid execution.\n  call_depth: 0,\n  // Use to temporarily store and updated active_hooks.array if the user\n  // enables or disables a hook while hooks are being processed. If a hook is\n  // enabled() or disabled() during hook execution then the current set of\n  // active hooks is duplicated and set equal to active_hooks.tmp_array. Any\n  // subsequent changes are on the duplicated array. When all hooks have\n  // completed executing active_hooks.tmp_array is assigned to\n  // active_hooks.array.\n  tmp_array: null,\n  // Keep track of the field counts held in active_hooks.tmp_array. Because the\n  // async_hook_fields can't be reassigned, store each uint32 in an array that\n  // is written back to async_hook_fields when active_hooks.array is restored.\n  tmp_fields: null,\n};\n\nconst { registerDestroyHook } = async_wrap;\nconst { enqueueMicrotask } = internalBinding('task_queue');\nconst { resource_symbol, owner_symbol } = internalBinding('symbols');\n\n// Each constant tracks how many callbacks there are for any given step of\n// async execution. These are tracked so if the user didn't include callbacks\n// for a given step, that step can bail out early.\nconst {\n  kInit, kBefore, kAfter, kDestroy, kTotals, kPromiseResolve,\n  kCheck, kExecutionAsyncId, kAsyncIdCounter, kTriggerAsyncId,\n  kDefaultTriggerAsyncId, kStackLength, kUsesExecutionAsyncResource,\n} = async_wrap.constants;\n\nconst { async_id_symbol,\n        trigger_async_id_symbol } = internalBinding('symbols');\n\n// Lazy load of internal/util/inspect;\nlet inspect;\n\n// Used in AsyncHook and AsyncResource.\nconst init_symbol = Symbol('init');\nconst before_symbol = Symbol('before');\nconst after_symbol = Symbol('after');\nconst destroy_symbol = Symbol('destroy');\nconst promise_resolve_symbol = Symbol('promiseResolve');\nconst emitBeforeNative = emitHookFactory(before_symbol, 'emitBeforeNative');\nconst emitAfterNative = emitHookFactory(after_symbol, 'emitAfterNative');\nconst emitDestroyNative = emitHookFactory(destroy_symbol, 'emitDestroyNative');\nconst emitPromiseResolveNative =\n    emitHookFactory(promise_resolve_symbol, 'emitPromiseResolveNative');\n\nlet domain_cb;\nfunction useDomainTrampoline(fn) {\n  domain_cb = fn;\n}\n\nfunction callbackTrampoline(asyncId, resource, cb, ...args) {\n  const index = async_hook_fields[kStackLength] - 1;\n  execution_async_resources[index] = resource;\n\n  if (asyncId !== 0 && hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n\n  let result;\n  if (asyncId === 0 && typeof domain_cb === 'function') {\n    args.unshift(cb);\n    result = domain_cb.apply(this, args);\n  } else {\n    result = cb.apply(this, args);\n  }\n\n  if (asyncId !== 0 && hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  execution_async_resources.pop();\n  return result;\n}\n\nconst topLevelResource = {};\n\nfunction executionAsyncResource() {\n  // Indicate to the native layer that this function is likely to be used,\n  // in which case it will inform JS about the current async resource via\n  // the trampoline above.\n  async_hook_fields[kUsesExecutionAsyncResource] = 1;\n\n  const index = async_hook_fields[kStackLength] - 1;\n  if (index === -1) return topLevelResource;\n  const resource = execution_async_resources[index] ||\n    executionAsyncResource_(index);\n  return lookupPublicResource(resource);\n}\n\nfunction inspectExceptionValue(e) {\n  inspect ??= require('internal/util/inspect').inspect;\n  return { message: inspect(e) };\n}\n\n// Used to fatally abort the process if a callback throws.\nfunction fatalError(e) {\n  if (typeof e?.stack === 'string') {\n    process._rawDebug(e.stack);\n  } else {\n    const o = inspectExceptionValue(e);\n    ErrorCaptureStackTrace(o, fatalError);\n    process._rawDebug(o.stack);\n  }\n\n  const { getOptionValue } = require('internal/options');\n  if (getOptionValue('--abort-on-uncaught-exception')) {\n    process.abort();\n  }\n  process.exit(kGenericUserError);\n}\n\nfunction lookupPublicResource(resource) {\n  if (typeof resource !== 'object' || resource === null) return resource;\n  // TODO(addaleax): Merge this with owner_symbol and use it across all\n  // AsyncWrap instances.\n  const publicResource = resource[resource_symbol];\n  if (publicResource !== undefined)\n    return publicResource;\n  return resource;\n}\n\n// Emit From Native //\n\n// Used by C++ to call all init() callbacks. Because some state can be setup\n// from C++ there's no need to perform all the same operations as in\n// emitInitScript.\nfunction emitInitNative(asyncId, type, triggerAsyncId, resource) {\n  active_hooks.call_depth += 1;\n  resource = lookupPublicResource(resource);\n  // Use a single try/catch for all hooks to avoid setting up one per iteration.\n  try {\n    // Using var here instead of let because \"for (var ...)\" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    // eslint-disable-next-line no-var\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][init_symbol] === 'function') {\n        active_hooks.array[i][init_symbol](\n          asyncId, type, triggerAsyncId,\n          resource,\n        );\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution, in which case active_hooks.tmp_array\n  // will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\n// Called from native. The asyncId stack handling is taken care of there\n// before this is called.\nfunction emitHook(symbol, asyncId) {\n  active_hooks.call_depth += 1;\n  // Use a single try/catch for all hook to avoid setting up one per\n  // iteration.\n  try {\n    // Using var here instead of let because \"for (var ...)\" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    // eslint-disable-next-line no-var\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][symbol] === 'function') {\n        active_hooks.array[i][symbol](asyncId);\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution, in which case\n  // active_hooks.tmp_array will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\nfunction emitHookFactory(symbol, name) {\n  const fn = emitHook.bind(undefined, symbol);\n\n  // Set the name property of the function as it looks good in the stack trace.\n  ObjectDefineProperty(fn, 'name', {\n    __proto__: null,\n    value: name,\n  });\n  return fn;\n}\n\n// Manage Active Hooks //\n\nfunction getHookArrays() {\n  if (active_hooks.call_depth === 0)\n    return [active_hooks.array, async_hook_fields];\n  // If this hook is being enabled while in the middle of processing the array\n  // of currently active hooks then duplicate the current set of active hooks\n  // and store this there. This shouldn't fire until the next time hooks are\n  // processed.\n  if (active_hooks.tmp_array === null)\n    storeActiveHooks();\n  return [active_hooks.tmp_array, active_hooks.tmp_fields];\n}\n\n\nfunction storeActiveHooks() {\n  active_hooks.tmp_array = ArrayPrototypeSlice(active_hooks.array);\n  // Don't want to make the assumption that kInit to kDestroy are indexes 0 to\n  // 4. So do this the long way.\n  active_hooks.tmp_fields = [];\n  copyHooks(active_hooks.tmp_fields, async_hook_fields);\n}\n\nfunction copyHooks(destination, source) {\n  destination[kInit] = source[kInit];\n  destination[kBefore] = source[kBefore];\n  destination[kAfter] = source[kAfter];\n  destination[kDestroy] = source[kDestroy];\n  destination[kPromiseResolve] = source[kPromiseResolve];\n}\n\n\n// Then restore the correct hooks array in case any hooks were added/removed\n// during hook callback execution.\nfunction restoreActiveHooks() {\n  active_hooks.array = active_hooks.tmp_array;\n  copyHooks(async_hook_fields, active_hooks.tmp_fields);\n\n  active_hooks.tmp_array = null;\n  active_hooks.tmp_fields = null;\n}\n\nfunction trackPromise(promise, parent) {\n  if (promise[async_id_symbol]) {\n    return;\n  }\n\n  // Get trigger id from parent async id before making the async id of the\n  // child so if a new one must be made it will be lower than the child.\n  const triggerAsyncId = parent ? getOrSetAsyncId(parent) :\n    getDefaultTriggerAsyncId();\n\n  promise[async_id_symbol] = newAsyncId();\n  promise[trigger_async_id_symbol] = triggerAsyncId;\n}\n\nfunction promiseInitHook(promise, parent) {\n  trackPromise(promise, parent);\n  const asyncId = promise[async_id_symbol];\n  const triggerAsyncId = promise[trigger_async_id_symbol];\n  emitInitScript(asyncId, 'PROMISE', triggerAsyncId, promise);\n}\n\nfunction promiseInitHookWithDestroyTracking(promise, parent) {\n  promiseInitHook(promise, parent);\n  destroyTracking(promise, parent);\n}\n\nfunction destroyTracking(promise, parent) {\n  trackPromise(promise, parent);\n  const asyncId = promise[async_id_symbol];\n  registerDestroyHook(promise, asyncId);\n}\n\nfunction promiseBeforeHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  const triggerId = promise[trigger_async_id_symbol];\n  emitBeforeScript(asyncId, triggerId, promise);\n}\n\nfunction promiseAfterHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  if (hasHooks(kAfter)) {\n    emitAfterNative(asyncId);\n  }\n  if (asyncId === executionAsyncId()) {\n    // This condition might not be true if async_hooks was enabled during\n    // the promise callback execution.\n    // Popping it off the stack can be skipped in that case, because it is\n    // known that it would correspond to exactly one call with\n    // PromiseHookType::kBefore that was not witnessed by the PromiseHook.\n    popAsyncContext(asyncId);\n  }\n}\n\nfunction promiseResolveHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  emitPromiseResolveNative(asyncId);\n}\n\nlet wantPromiseHook = false;\nfunction enableHooks() {\n  async_hook_fields[kCheck] += 1;\n\n  setCallbackTrampoline(callbackTrampoline);\n}\n\nlet stopPromiseHook;\nfunction updatePromiseHookMode() {\n  wantPromiseHook = true;\n  let initHook;\n  if (initHooksExist()) {\n    initHook = destroyHooksExist() ? promiseInitHookWithDestroyTracking :\n      promiseInitHook;\n  } else if (destroyHooksExist()) {\n    initHook = destroyTracking;\n  }\n  if (stopPromiseHook) stopPromiseHook();\n  const promiseHooks = require('internal/promise_hooks');\n  stopPromiseHook = promiseHooks.createHook({\n    init: initHook,\n    before: promiseBeforeHook,\n    after: promiseAfterHook,\n    settled: promiseResolveHooksExist() ? promiseResolveHook : undefined,\n  });\n}\n\nfunction disableHooks() {\n  async_hook_fields[kCheck] -= 1;\n\n  wantPromiseHook = false;\n\n  setCallbackTrampoline();\n\n  // Delay the call to `disablePromiseHook()` because we might currently be\n  // between the `before` and `after` calls of a Promise.\n  enqueueMicrotask(disablePromiseHookIfNecessary);\n}\n\nfunction disablePromiseHookIfNecessary() {\n  if (!wantPromiseHook && stopPromiseHook) {\n    stopPromiseHook();\n  }\n}\n\n// Internal Embedder API //\n\n// Increment the internal id counter and return the value. Important that the\n// counter increment first. Since it's done the same way in\n// Environment::new_async_uid()\nfunction newAsyncId() {\n  return ++async_id_fields[kAsyncIdCounter];\n}\n\nfunction getOrSetAsyncId(object) {\n  if (ObjectPrototypeHasOwnProperty(object, async_id_symbol)) {\n    return object[async_id_symbol];\n  }\n\n  return object[async_id_symbol] = newAsyncId();\n}\n\n\n// Return the triggerAsyncId meant for the constructor calling it. It's up to\n// the user to safeguard this call and make sure it's zero'd out when the\n// constructor is complete.\nfunction getDefaultTriggerAsyncId() {\n  const defaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  // If defaultTriggerAsyncId isn't set, use the executionAsyncId\n  if (defaultTriggerAsyncId < 0)\n    return async_id_fields[kExecutionAsyncId];\n  return defaultTriggerAsyncId;\n}\n\n\nfunction clearDefaultTriggerAsyncId() {\n  async_id_fields[kDefaultTriggerAsyncId] = -1;\n}\n\n/**\n * Sets a default top level trigger ID to be used\n * @template {Array<unknown>} T\n * @template {unknown} R\n * @param {number} triggerAsyncId\n * @param { (...T: args) => R } block\n * @param  {T} args\n * @returns {R}\n */\nfunction defaultTriggerAsyncIdScope(triggerAsyncId, block, ...args) {\n  if (triggerAsyncId === undefined)\n    return block.apply(null, args);\n  // CHECK(NumberIsSafeInteger(triggerAsyncId))\n  // CHECK(triggerAsyncId > 0)\n  const oldDefaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  async_id_fields[kDefaultTriggerAsyncId] = triggerAsyncId;\n\n  try {\n    return block.apply(null, args);\n  } finally {\n    async_id_fields[kDefaultTriggerAsyncId] = oldDefaultTriggerAsyncId;\n  }\n}\n\nfunction hasHooks(key) {\n  return async_hook_fields[key] > 0;\n}\n\nfunction enabledHooksExist() {\n  return hasHooks(kCheck);\n}\n\nfunction initHooksExist() {\n  return hasHooks(kInit);\n}\n\nfunction afterHooksExist() {\n  return hasHooks(kAfter);\n}\n\nfunction destroyHooksExist() {\n  return hasHooks(kDestroy);\n}\n\nfunction promiseResolveHooksExist() {\n  return hasHooks(kPromiseResolve);\n}\n\n\nfunction emitInitScript(asyncId, type, triggerAsyncId, resource) {\n  // Short circuit all checks for the common case. Which is that no hooks have\n  // been set. Do this to remove performance impact for embedders (and core).\n  if (!hasHooks(kInit))\n    return;\n\n  if (triggerAsyncId === null) {\n    triggerAsyncId = getDefaultTriggerAsyncId();\n  }\n\n  emitInitNative(asyncId, type, triggerAsyncId, resource);\n}\n\n\nfunction emitBeforeScript(asyncId, triggerAsyncId, resource) {\n  pushAsyncContext(asyncId, triggerAsyncId, resource);\n\n  if (hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n}\n\n\nfunction emitAfterScript(asyncId) {\n  if (hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  popAsyncContext(asyncId);\n}\n\n\nfunction emitDestroyScript(asyncId) {\n  // Return early if there are no destroy callbacks, or invalid asyncId.\n  if (!hasHooks(kDestroy) || asyncId <= 0)\n    return;\n  async_wrap.queueDestroyAsyncId(asyncId);\n}\n\n\nfunction hasAsyncIdStack() {\n  return hasHooks(kStackLength);\n}\n\n\n// This is the equivalent of the native push_async_ids() call.\nfunction pushAsyncContext(asyncId, triggerAsyncId, resource) {\n  const offset = async_hook_fields[kStackLength];\n  execution_async_resources[offset] = resource;\n  if (offset * 2 >= async_wrap.async_ids_stack.length)\n    return pushAsyncContext_(asyncId, triggerAsyncId);\n  async_wrap.async_ids_stack[offset * 2] = async_id_fields[kExecutionAsyncId];\n  async_wrap.async_ids_stack[offset * 2 + 1] = async_id_fields[kTriggerAsyncId];\n  async_hook_fields[kStackLength]++;\n  async_id_fields[kExecutionAsyncId] = asyncId;\n  async_id_fields[kTriggerAsyncId] = triggerAsyncId;\n}\n\n\n// This is the equivalent of the native pop_async_ids() call.\nfunction popAsyncContext(asyncId) {\n  const stackLength = async_hook_fields[kStackLength];\n  if (stackLength === 0) return false;\n\n  if (enabledHooksExist() && async_id_fields[kExecutionAsyncId] !== asyncId) {\n    // Do the same thing as the native code (i.e. crash hard).\n    return popAsyncContext_(asyncId);\n  }\n\n  const offset = stackLength - 1;\n  async_id_fields[kExecutionAsyncId] = async_wrap.async_ids_stack[2 * offset];\n  async_id_fields[kTriggerAsyncId] = async_wrap.async_ids_stack[2 * offset + 1];\n  execution_async_resources.pop();\n  async_hook_fields[kStackLength] = offset;\n  return offset > 0;\n}\n\n\nfunction executionAsyncId() {\n  return async_id_fields[kExecutionAsyncId];\n}\n\nfunction triggerAsyncId() {\n  return async_id_fields[kTriggerAsyncId];\n}\n\n\nmodule.exports = {\n  executionAsyncId,\n  triggerAsyncId,\n  // Private API\n  getHookArrays,\n  symbols: {\n    async_id_symbol, trigger_async_id_symbol,\n    init_symbol, before_symbol, after_symbol, destroy_symbol,\n    promise_resolve_symbol, owner_symbol,\n  },\n  constants: {\n    kInit, kBefore, kAfter, kDestroy, kTotals, kPromiseResolve,\n  },\n  enableHooks,\n  disableHooks,\n  updatePromiseHookMode,\n  clearDefaultTriggerAsyncId,\n  clearAsyncIdStack,\n  hasAsyncIdStack,\n  executionAsyncResource,\n  // Internal Embedder API\n  newAsyncId,\n  getOrSetAsyncId,\n  getDefaultTriggerAsyncId,\n  defaultTriggerAsyncIdScope,\n  enabledHooksExist,\n  initHooksExist,\n  afterHooksExist,\n  destroyHooksExist,\n  emitInit: emitInitScript,\n  emitBefore: emitBeforeScript,\n  emitAfter: emitAfterScript,\n  emitDestroy: emitDestroyScript,\n  pushAsyncContext,\n  popAsyncContext,\n  registerDestroyHook,\n  useDomainTrampoline,\n  nativeHooks: {\n    init: emitInitNative,\n    before: emitBeforeNative,\n    after: emitAfterNative,\n    destroy: emitDestroyNative,\n    promise_resolve: emitPromiseResolveNative,\n  },\n  asyncWrap: {\n    Providers: async_wrap.Providers,\n  },\n};\n"
    },
    "15": {
      "sourceCode": "/* eslint jsdoc/require-jsdoc: \"error\" */\n\n'use strict';\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberMAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER,\n  NumberParseInt,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeExec,\n  String,\n  StringPrototypeToUpperCase,\n  StringPrototypeTrim,\n} = primordials;\n\nconst {\n  hideStackFrames,\n  codes: {\n    ERR_SOCKET_BAD_PORT,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_OUT_OF_RANGE,\n    ERR_UNKNOWN_SIGNAL,\n  },\n} = require('internal/errors');\nconst { normalizeEncoding } = require('internal/util');\nconst {\n  isAsyncFunction,\n  isArrayBufferView,\n} = require('internal/util/types');\nconst { signals } = internalBinding('constants').os;\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isInt32(value) {\n  return value === (value | 0);\n}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isUint32(value) {\n  return value === (value >>> 0);\n}\n\nconst octalReg = /^[0-7]+$/;\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string';\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land, but any value higher than 0o777 will result in platform-specific\n * behaviors.\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified, will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value, name, def) {\n  value ??= def;\n  if (typeof value === 'string') {\n    if (RegExpPrototypeExec(octalReg, value) === null) {\n      throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);\n    }\n    value = NumberParseInt(value, 8);\n  }\n\n  validateUint32(value, name);\n  return value;\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInteger} */\nconst validateInteger = hideStackFrames(\n  (value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n    if (typeof value !== 'number')\n      throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n    if (!NumberIsInteger(value))\n      throw new ERR_OUT_OF_RANGE(name, 'an integer', value);\n    if (value < min || value > max)\n      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n  },\n);\n\n/**\n * @callback validateInt32\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInt32} */\nconst validateInt32 = hideStackFrames(\n  (value, name, min = -2147483648, max = 2147483647) => {\n    // The defaults for min and max correspond to the limits of 32-bit integers.\n    if (typeof value !== 'number') {\n      throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n    }\n    if (!NumberIsInteger(value)) {\n      throw new ERR_OUT_OF_RANGE(name, 'an integer', value);\n    }\n    if (value < min || value > max) {\n      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n    }\n  },\n);\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\n\n/** @type {validateUint32} */\nconst validateUint32 = hideStackFrames((value, name, positive = false) => {\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, 'an integer', value);\n  }\n  const min = positive ? 1 : 0;\n  // 2 ** 32 === 4294967296\n  const max = 4_294_967_295;\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n  }\n});\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== 'string')\n    throw new ERR_INVALID_ARG_TYPE(name, 'string', value);\n}\n\n/**\n * @callback validateNumber\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateNumber} */\nfunction validateNumber(value, name, min = undefined, max) {\n  if (typeof value !== 'number')\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n\n  if ((min != null && value < min) || (max != null && value > max) ||\n    ((min != null || max != null) && NumberIsNaN(value))) {\n    throw new ERR_OUT_OF_RANGE(\n      name,\n      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`,\n      value);\n  }\n}\n\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */\n\n/** @type {validateOneOf} */\nconst validateOneOf = hideStackFrames((value, name, oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf, value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf, (v) =>\n        (typeof v === 'string' ? `'${v}'` : String(v))),\n      ', ');\n    const reason = 'must be one of: ' + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n});\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\n\n/** @type {validateBoolean} */\nfunction validateBoolean(value, name) {\n  if (typeof value !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value);\n}\n\nconst kValidateObjectNone = 0;\nconst kValidateObjectAllowNullable = 1 << 0;\nconst kValidateObjectAllowArray = 1 << 1;\nconst kValidateObjectAllowFunction = 1 << 2;\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {number} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = hideStackFrames(\n  (value, name, options = kValidateObjectNone) => {\n    if (options === kValidateObjectNone) {\n      if (value === null || ArrayIsArray(value)) {\n        throw new ERR_INVALID_ARG_TYPE(name, 'Object', value);\n      }\n\n      if (typeof value !== 'object') {\n        throw new ERR_INVALID_ARG_TYPE(name, 'Object', value);\n      }\n    } else {\n      const throwOnNullable = (kValidateObjectAllowNullable & options) === 0;\n\n      if (throwOnNullable && value === null) {\n        throw new ERR_INVALID_ARG_TYPE(name, 'Object', value);\n      }\n\n      const throwOnArray = (kValidateObjectAllowArray & options) === 0;\n\n      if (throwOnArray && ArrayIsArray(value)) {\n        throw new ERR_INVALID_ARG_TYPE(name, 'Object', value);\n      }\n\n      const throwOnFunction = (kValidateObjectAllowFunction & options) === 0;\n      const typeofValue = typeof value;\n\n      if (typeofValue !== 'object' && (throwOnFunction || typeofValue !== 'function')) {\n        throw new ERR_INVALID_ARG_TYPE(name, 'Object', value);\n      }\n    }\n  });\n\n/**\n * @callback validateDictionary - We are using the Web IDL Standard definition\n *                                of \"dictionary\" here, which means any value\n *                                whose Type is either Undefined, Null, or\n *                                Object (which includes functions).\n * @param {*} value\n * @param {string} name\n * @see https://webidl.spec.whatwg.org/#es-dictionary\n * @see https://tc39.es/ecma262/#table-typeof-operator-results\n */\n\n/** @type {validateDictionary} */\nconst validateDictionary = hideStackFrames(\n  (value, name) => {\n    if (value != null && typeof value !== 'object' && typeof value !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(name, 'a dictionary', value);\n    }\n  });\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\n\n/** @type {validateArray} */\nconst validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Array', value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n});\n\n/**\n * @callback validateStringArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string[]}\n */\n\n/** @type {validateStringArray} */\nfunction validateStringArray(value, name) {\n  validateArray(value, name);\n  for (let i = 0; i < value.length; ++i) {\n    // Don't use validateString here for performance reasons, as\n    // we would generate intermediate strings for the name.\n    if (typeof value[i] !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE(`${name}[${i}]`, 'string', value[i]);\n    }\n  }\n}\n\n/**\n * @callback validateBooleanArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean[]}\n */\n\n/** @type {validateBooleanArray} */\nfunction validateBooleanArray(value, name) {\n  validateArray(value, name);\n  for (let i = 0; i < value.length; ++i) {\n    // Don't use validateBoolean here for performance reasons, as\n    // we would generate intermediate strings for the name.\n    if (value[i] !== true && value[i] !== false) {\n      throw new ERR_INVALID_ARG_TYPE(`${name}[${i}]`, 'boolean', value[i]);\n    }\n  }\n}\n\n/**\n * @callback validateAbortSignalArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is AbortSignal[]}\n */\n\n/** @type {validateAbortSignalArray} */\nfunction validateAbortSignalArray(value, name) {\n  validateArray(value, name);\n  for (let i = 0; i < value.length; i++) {\n    const signal = value[i];\n    const indexedName = `${name}[${i}]`;\n    if (signal == null) {\n      throw new ERR_INVALID_ARG_TYPE(indexedName, 'AbortSignal', signal);\n    }\n    validateAbortSignal(signal, indexedName);\n  }\n}\n\n/**\n * @param {*} signal\n * @param {string} [name='signal']\n * @returns {asserts signal is keyof signals}\n */\nfunction validateSignalName(signal, name = 'signal') {\n  validateString(signal, name);\n\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal +\n                                   ' (signals must use all capital letters)');\n    }\n\n    throw new ERR_UNKNOWN_SIGNAL(signal);\n  }\n}\n\n/**\n * @callback validateBuffer\n * @param {*} buffer\n * @param {string} [name='buffer']\n * @returns {asserts buffer is ArrayBufferView}\n */\n\n/** @type {validateBuffer} */\nconst validateBuffer = hideStackFrames((buffer, name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name,\n                                   ['Buffer', 'TypedArray', 'DataView'],\n                                   buffer);\n  }\n});\n\n/**\n * @param {string} data\n * @param {string} encoding\n */\nfunction validateEncoding(data, encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding);\n  const length = data.length;\n\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding', encoding,\n                                    `is invalid for data of length ${length}`);\n  }\n}\n\n/**\n * Check that the port number is not NaN when coerced to a number,\n * is an integer and that it falls within the legal range of port numbers.\n * @param {*} port\n * @param {string} [name='Port']\n * @param {boolean} [allowZero=true]\n * @returns {number}\n */\nfunction validatePort(port, name = 'Port', allowZero = true) {\n  if ((typeof port !== 'number' && typeof port !== 'string') ||\n      (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n      +port !== (+port >>> 0) ||\n      port > 0xFFFF ||\n      (port === 0 && !allowZero)) {\n    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);\n  }\n  return port | 0;\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\n\n/** @type {validateAbortSignal} */\nconst validateAbortSignal = hideStackFrames((signal, name) => {\n  if (signal !== undefined &&\n      (signal === null ||\n       typeof signal !== 'object' ||\n       !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal);\n  }\n});\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validateFunction} */\nconst validateFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function')\n    throw new ERR_INVALID_ARG_TYPE(name, 'Function', value);\n});\n\n/**\n * @callback validatePlainFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validatePlainFunction} */\nconst validatePlainFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function' || isAsyncFunction(value))\n    throw new ERR_INVALID_ARG_TYPE(name, 'Function', value);\n});\n\n/**\n * @callback validateUndefined\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is undefined}\n */\n\n/** @type {validateUndefined} */\nconst validateUndefined = hideStackFrames((value, name) => {\n  if (value !== undefined)\n    throw new ERR_INVALID_ARG_TYPE(name, 'undefined', value);\n});\n\n/**\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} union\n */\nfunction validateUnion(value, name, union) {\n  if (!ArrayPrototypeIncludes(union, value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, '|')}')`, value);\n  }\n}\n\n/*\n  The rules for the Link header field are described here:\n  https://www.rfc-editor.org/rfc/rfc8288.html#section-3\n\n  This regex validates any string surrounded by angle brackets\n  (not necessarily a valid URI reference) followed by zero or more\n  link-params separated by semicolons.\n*/\nconst linkValueRegExp = /^(?:<[^>]*>)(?:\\s*;\\s*[^;\"\\s]+(?:=(\")?[^;\"\\s]*\\1)?)*$/;\n\n/**\n * @param {any} value\n * @param {string} name\n */\nfunction validateLinkHeaderFormat(value, name) {\n  if (\n    typeof value === 'undefined' ||\n    !RegExpPrototypeExec(linkValueRegExp, value)\n  ) {\n    throw new ERR_INVALID_ARG_VALUE(\n      name,\n      value,\n      'must be an array or string of format \"</styles.css>; rel=preload; as=style\"',\n    );\n  }\n}\n\nconst validateInternalField = hideStackFrames((object, fieldKey, className) => {\n  if (typeof object !== 'object' || object === null || !ObjectPrototypeHasOwnProperty(object, fieldKey)) {\n    throw new ERR_INVALID_ARG_TYPE('this', className, object);\n  }\n});\n\n/**\n * @param {any} hints\n * @return {string}\n */\nfunction validateLinkHeaderValue(hints) {\n  if (typeof hints === 'string') {\n    validateLinkHeaderFormat(hints, 'hints');\n    return hints;\n  } else if (ArrayIsArray(hints)) {\n    const hintsLength = hints.length;\n    let result = '';\n\n    if (hintsLength === 0) {\n      return result;\n    }\n\n    for (let i = 0; i < hintsLength; i++) {\n      const link = hints[i];\n      validateLinkHeaderFormat(link, 'hints');\n      result += link;\n\n      if (i !== hintsLength - 1) {\n        result += ', ';\n      }\n    }\n\n    return result;\n  }\n\n  throw new ERR_INVALID_ARG_VALUE(\n    'hints',\n    hints,\n    'must be an array or string of format \"</styles.css>; rel=preload; as=style\"',\n  );\n}\n\nmodule.exports = {\n  isInt32,\n  isUint32,\n  parseFileMode,\n  validateArray,\n  validateStringArray,\n  validateBooleanArray,\n  validateAbortSignalArray,\n  validateBoolean,\n  validateBuffer,\n  validateDictionary,\n  validateEncoding,\n  validateFunction,\n  validateInt32,\n  validateInteger,\n  validateNumber,\n  validateObject,\n  kValidateObjectNone,\n  kValidateObjectAllowNullable,\n  kValidateObjectAllowArray,\n  kValidateObjectAllowFunction,\n  validateOneOf,\n  validatePlainFunction,\n  validatePort,\n  validateSignalName,\n  validateString,\n  validateUint32,\n  validateUndefined,\n  validateUnion,\n  validateAbortSignal,\n  validateLinkHeaderValue,\n  validateInternalField,\n};\n"
    },
    "19": {
      "sourceCode": "'use strict';\n\nfunction init(list) {\n  list._idleNext = list;\n  list._idlePrev = list;\n  return list;\n}\n\n// Show the most idle item.\nfunction peek(list) {\n  if (list._idlePrev === list) return null;\n  return list._idlePrev;\n}\n\n// Remove an item from its list.\nfunction remove(item) {\n  if (item._idleNext) {\n    item._idleNext._idlePrev = item._idlePrev;\n  }\n\n  if (item._idlePrev) {\n    item._idlePrev._idleNext = item._idleNext;\n  }\n\n  item._idleNext = null;\n  item._idlePrev = null;\n}\n\n// Remove an item from its list and place at the end.\nfunction append(list, item) {\n  if (item._idleNext || item._idlePrev) {\n    remove(item);\n  }\n\n  // Items are linked  with _idleNext -> (older) and _idlePrev -> (newer).\n  // Note: This linkage (next being older) may seem counter-intuitive at first.\n  item._idleNext = list._idleNext;\n  item._idlePrev = list;\n\n  // The list _idleNext points to tail (newest) and _idlePrev to head (oldest).\n  list._idleNext._idlePrev = item;\n  list._idleNext = item;\n}\n\nfunction isEmpty(list) {\n  return list._idleNext === list;\n}\n\nmodule.exports = {\n  init,\n  peek,\n  remove,\n  append,\n  isEmpty,\n};\n"
    },
    "20": {
      "sourceCode": "'use strict';\n\nconst {\n  Array,\n} = primordials;\n\n// The PriorityQueue is a basic implementation of a binary heap that accepts\n// a custom sorting function via its constructor. This function is passed\n// the two nodes to compare, similar to the native Array#sort. Crucially\n// this enables priority queues that are based on a comparison of more than\n// just a single criteria.\n\nmodule.exports = class PriorityQueue {\n  #compare = (a, b) => a - b;\n  #heap = new Array(64);\n  #setPosition;\n  #size = 0;\n\n  constructor(comparator, setPosition) {\n    if (comparator !== undefined)\n      this.#compare = comparator;\n    if (setPosition !== undefined)\n      this.#setPosition = setPosition;\n  }\n\n  insert(value) {\n    const heap = this.#heap;\n    const pos = ++this.#size;\n    heap[pos] = value;\n\n    if (heap.length === pos)\n      heap.length *= 2;\n\n    this.percolateUp(pos);\n  }\n\n  peek() {\n    return this.#heap[1];\n  }\n\n  peekBottom() {\n    return this.#heap[this.#size];\n  }\n\n  percolateDown(pos) {\n    const compare = this.#compare;\n    const setPosition = this.#setPosition;\n    const heap = this.#heap;\n    const size = this.#size;\n    const item = heap[pos];\n\n    while (pos * 2 <= size) {\n      let childIndex = pos * 2 + 1;\n      if (childIndex > size || compare(heap[pos * 2], heap[childIndex]) < 0)\n        childIndex = pos * 2;\n      const child = heap[childIndex];\n      if (compare(item, child) <= 0)\n        break;\n      if (setPosition !== undefined)\n        setPosition(child, pos);\n      heap[pos] = child;\n      pos = childIndex;\n    }\n    heap[pos] = item;\n    if (setPosition !== undefined)\n      setPosition(item, pos);\n  }\n\n  percolateUp(pos) {\n    const heap = this.#heap;\n    const compare = this.#compare;\n    const setPosition = this.#setPosition;\n    const item = heap[pos];\n\n    while (pos > 1) {\n      const parent = heap[pos / 2 | 0];\n      if (compare(parent, item) <= 0)\n        break;\n      heap[pos] = parent;\n      if (setPosition !== undefined)\n        setPosition(parent, pos);\n      pos = pos / 2 | 0;\n    }\n    heap[pos] = item;\n    if (setPosition !== undefined)\n      setPosition(item, pos);\n  }\n\n  removeAt(pos) {\n    const heap = this.#heap;\n    const size = --this.#size;\n    heap[pos] = heap[size + 1];\n    heap[size + 1] = undefined;\n\n    if (size > 0 && pos <= size) {\n      if (pos > 1 && this.#compare(heap[pos / 2 | 0], heap[pos]) > 0)\n        this.percolateUp(pos);\n      else\n        this.percolateDown(pos);\n    }\n  }\n\n  shift() {\n    const heap = this.#heap;\n    const value = heap[1];\n    if (value === undefined)\n      return;\n\n    this.removeAt(1);\n\n    return value;\n  }\n};\n"
    },
    "21": {
      "sourceCode": "'use strict';\n\nconst {\n  Array,\n  ArrayIsArray,\n  ArrayPrototypeFilter,\n  ArrayPrototypeForEach,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeIndexOf,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  ArrayPrototypePop,\n  ArrayPrototypePush,\n  ArrayPrototypePushApply,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSplice,\n  ArrayPrototypeSort,\n  ArrayPrototypeUnshift,\n  BigIntPrototypeValueOf,\n  BooleanPrototypeValueOf,\n  DatePrototypeGetTime,\n  DatePrototypeToISOString,\n  DatePrototypeToString,\n  ErrorPrototypeToString,\n  FunctionPrototypeBind,\n  FunctionPrototypeCall,\n  FunctionPrototypeToString,\n  JSONStringify,\n  MapPrototypeGetSize,\n  MapPrototypeEntries,\n  MathFloor,\n  MathMax,\n  MathMin,\n  MathRound,\n  MathSqrt,\n  MathTrunc,\n  Number,\n  NumberIsFinite,\n  NumberIsNaN,\n  NumberParseFloat,\n  NumberParseInt,\n  NumberPrototypeToString,\n  NumberPrototypeValueOf,\n  Object,\n  ObjectAssign,\n  ObjectDefineProperty,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectGetOwnPropertyNames,\n  ObjectGetOwnPropertySymbols,\n  ObjectGetPrototypeOf,\n  ObjectIs,\n  ObjectKeys,\n  ObjectPrototypeHasOwnProperty,\n  ObjectPrototypePropertyIsEnumerable,\n  ObjectSeal,\n  ObjectSetPrototypeOf,\n  ReflectApply,\n  ReflectOwnKeys,\n  RegExp,\n  RegExpPrototypeExec,\n  RegExpPrototypeSymbolReplace,\n  RegExpPrototypeSymbolSplit,\n  RegExpPrototypeToString,\n  SafeStringIterator,\n  SafeMap,\n  SafeSet,\n  SetPrototypeGetSize,\n  SetPrototypeValues,\n  String,\n  StringPrototypeCharCodeAt,\n  StringPrototypeCodePointAt,\n  StringPrototypeIncludes,\n  StringPrototypeIndexOf,\n  StringPrototypeLastIndexOf,\n  StringPrototypeNormalize,\n  StringPrototypePadEnd,\n  StringPrototypePadStart,\n  StringPrototypeRepeat,\n  StringPrototypeReplaceAll,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeEndsWith,\n  StringPrototypeStartsWith,\n  StringPrototypeToLowerCase,\n  StringPrototypeTrim,\n  StringPrototypeValueOf,\n  SymbolPrototypeToString,\n  SymbolPrototypeValueOf,\n  SymbolIterator,\n  SymbolToStringTag,\n  TypedArrayPrototypeGetLength,\n  TypedArrayPrototypeGetSymbolToStringTag,\n  Uint8Array,\n  globalThis,\n  uncurryThis,\n} = primordials;\n\nconst {\n  constants: {\n    ALL_PROPERTIES,\n    ONLY_ENUMERABLE,\n    kPending,\n    kRejected,\n  },\n  getOwnNonIndexProperties,\n  getPromiseDetails,\n  getProxyDetails,\n  previewEntries,\n  getConstructorName: internalGetConstructorName,\n  getExternalValue,\n} = internalBinding('util');\n\nconst {\n  customInspectSymbol,\n  isError,\n  join,\n  removeColors,\n} = require('internal/util');\n\nconst {\n  isStackOverflowError,\n} = require('internal/errors');\n\nconst {\n  isAsyncFunction,\n  isGeneratorFunction,\n  isAnyArrayBuffer,\n  isArrayBuffer,\n  isArgumentsObject,\n  isBoxedPrimitive,\n  isDataView,\n  isExternal,\n  isMap,\n  isMapIterator,\n  isModuleNamespaceObject,\n  isNativeError,\n  isPromise,\n  isSet,\n  isSetIterator,\n  isWeakMap,\n  isWeakSet,\n  isRegExp,\n  isDate,\n  isTypedArray,\n  isStringObject,\n  isNumberObject,\n  isBooleanObject,\n  isBigIntObject,\n} = require('internal/util/types');\n\nconst assert = require('internal/assert');\n\nconst { BuiltinModule } = require('internal/bootstrap/realm');\nconst {\n  validateObject,\n  validateString,\n  kValidateObjectAllowArray,\n} = require('internal/validators');\n\nlet hexSlice;\nlet internalUrl;\n\nfunction pathToFileUrlHref(filepath) {\n  internalUrl ??= require('internal/url');\n  return internalUrl.pathToFileURL(filepath).href;\n}\n\nconst builtInObjects = new SafeSet(\n  ArrayPrototypeFilter(\n    ObjectGetOwnPropertyNames(globalThis),\n    (e) => RegExpPrototypeExec(/^[A-Z][a-zA-Z0-9]+$/, e) !== null,\n  ),\n);\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nconst isUndetectableObject = (v) => typeof v === 'undefined' && v !== undefined;\n\n// These options must stay in sync with `getUserOptions`. So if any option will\n// be added or removed, `getUserOptions` must also be updated accordingly.\nconst inspectDefaultOptions = ObjectSeal({\n  showHidden: false,\n  depth: 2,\n  colors: false,\n  customInspect: true,\n  showProxy: false,\n  maxArrayLength: 100,\n  maxStringLength: 10000,\n  breakLength: 80,\n  compact: 3,\n  sorted: false,\n  getters: false,\n  numericSeparator: false,\n});\n\nconst kObjectType = 0;\nconst kArrayType = 1;\nconst kArrayExtrasType = 2;\n\n/* eslint-disable no-control-regex */\nconst strEscapeSequencesRegExp = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/;\nconst strEscapeSequencesReplacer = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/g;\nconst strEscapeSequencesRegExpSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/;\nconst strEscapeSequencesReplacerSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/g;\n/* eslint-enable no-control-regex */\n\nconst keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\nconst numberRegExp = /^(0|[1-9][0-9]*)$/;\n\nconst coreModuleRegExp = /^ {4}at (?:[^/\\\\(]+ \\(|)node:(.+):\\d+:\\d+\\)?$/;\nconst nodeModulesRegExp = /[/\\\\]node_modules[/\\\\](.+?)(?=[/\\\\])/g;\n\nconst classRegExp = /^(\\s+[^(]*?)\\s*{/;\n// eslint-disable-next-line node-core/no-unescaped-regexp-dot\nconst stripCommentsRegExp = /(\\/\\/.*?\\n)|(\\/\\*(.|\\n)*?\\*\\/)/g;\n\nconst kMinLineLength = 16;\n\n// Constants to map the iterator state.\nconst kWeak = 0;\nconst kIterator = 1;\nconst kMapEntries = 2;\n\n// Escaped control characters (plus the single quote and the backslash). Use\n// empty strings to fill up unused entries.\nconst meta = [\n  '\\\\x00', '\\\\x01', '\\\\x02', '\\\\x03', '\\\\x04', '\\\\x05', '\\\\x06', '\\\\x07', // x07\n  '\\\\b', '\\\\t', '\\\\n', '\\\\x0B', '\\\\f', '\\\\r', '\\\\x0E', '\\\\x0F',           // x0F\n  '\\\\x10', '\\\\x11', '\\\\x12', '\\\\x13', '\\\\x14', '\\\\x15', '\\\\x16', '\\\\x17', // x17\n  '\\\\x18', '\\\\x19', '\\\\x1A', '\\\\x1B', '\\\\x1C', '\\\\x1D', '\\\\x1E', '\\\\x1F', // x1F\n  '', '', '', '', '', '', '', \"\\\\'\", '', '', '', '', '', '', '', '',      // x2F\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',         // x3F\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',         // x4F\n  '', '', '', '', '', '', '', '', '', '', '', '', '\\\\\\\\', '', '', '',     // x5F\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',         // x6F\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '\\\\x7F',    // x7F\n  '\\\\x80', '\\\\x81', '\\\\x82', '\\\\x83', '\\\\x84', '\\\\x85', '\\\\x86', '\\\\x87', // x87\n  '\\\\x88', '\\\\x89', '\\\\x8A', '\\\\x8B', '\\\\x8C', '\\\\x8D', '\\\\x8E', '\\\\x8F', // x8F\n  '\\\\x90', '\\\\x91', '\\\\x92', '\\\\x93', '\\\\x94', '\\\\x95', '\\\\x96', '\\\\x97', // x97\n  '\\\\x98', '\\\\x99', '\\\\x9A', '\\\\x9B', '\\\\x9C', '\\\\x9D', '\\\\x9E', '\\\\x9F', // x9F\n];\n\n// Regex used for ansi escape code splitting\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\n// License: MIT, authors: @sindresorhus, Qix-, arjunmehta and LitoMore\n// Matches all ansi escape code sequences in a string\nconst ansiPattern = '[\\\\u001B\\\\u009B][[\\\\]()#;?]*' +\n  '(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*' +\n  '|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)' +\n  '|(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))';\nconst ansi = new RegExp(ansiPattern, 'g');\n\nlet getStringWidth;\n\nfunction getUserOptions(ctx, isCrossContext) {\n  const ret = {\n    stylize: ctx.stylize,\n    showHidden: ctx.showHidden,\n    depth: ctx.depth,\n    colors: ctx.colors,\n    customInspect: ctx.customInspect,\n    showProxy: ctx.showProxy,\n    maxArrayLength: ctx.maxArrayLength,\n    maxStringLength: ctx.maxStringLength,\n    breakLength: ctx.breakLength,\n    compact: ctx.compact,\n    sorted: ctx.sorted,\n    getters: ctx.getters,\n    numericSeparator: ctx.numericSeparator,\n    ...ctx.userOptions,\n  };\n\n  // Typically, the target value will be an instance of `Object`. If that is\n  // *not* the case, the object may come from another vm.Context, and we want\n  // to avoid passing it objects from this Context in that case, so we remove\n  // the prototype from the returned object itself + the `stylize()` function,\n  // and remove all other non-primitives, including non-primitive user options.\n  if (isCrossContext) {\n    ObjectSetPrototypeOf(ret, null);\n    for (const key of ObjectKeys(ret)) {\n      if ((typeof ret[key] === 'object' || typeof ret[key] === 'function') &&\n          ret[key] !== null) {\n        delete ret[key];\n      }\n    }\n    ret.stylize = ObjectSetPrototypeOf((value, flavour) => {\n      let stylized;\n      try {\n        stylized = `${ctx.stylize(value, flavour)}`;\n      } catch {\n        // Continue regardless of error.\n      }\n\n      if (typeof stylized !== 'string') return value;\n      // `stylized` is a string as it should be, which is safe to pass along.\n      return stylized;\n    }, null);\n  }\n\n  return ret;\n}\n\n/**\n * Echos the value of any input. Tries to print the value out\n * in the best way possible given the different types.\n * @param {any} value The value to print out.\n * @param {object} opts Optional options object that alters the output.\n */\n/* Legacy: value, showHidden, depth, colors */\nfunction inspect(value, opts) {\n  // Default options\n  const ctx = {\n    budget: {},\n    indentationLvl: 0,\n    seen: [],\n    currentDepth: 0,\n    stylize: stylizeNoColor,\n    showHidden: inspectDefaultOptions.showHidden,\n    depth: inspectDefaultOptions.depth,\n    colors: inspectDefaultOptions.colors,\n    customInspect: inspectDefaultOptions.customInspect,\n    showProxy: inspectDefaultOptions.showProxy,\n    maxArrayLength: inspectDefaultOptions.maxArrayLength,\n    maxStringLength: inspectDefaultOptions.maxStringLength,\n    breakLength: inspectDefaultOptions.breakLength,\n    compact: inspectDefaultOptions.compact,\n    sorted: inspectDefaultOptions.sorted,\n    getters: inspectDefaultOptions.getters,\n    numericSeparator: inspectDefaultOptions.numericSeparator,\n  };\n  if (arguments.length > 1) {\n    // Legacy...\n    if (arguments.length > 2) {\n      if (arguments[2] !== undefined) {\n        ctx.depth = arguments[2];\n      }\n      if (arguments.length > 3 && arguments[3] !== undefined) {\n        ctx.colors = arguments[3];\n      }\n    }\n    // Set user-specified options\n    if (typeof opts === 'boolean') {\n      ctx.showHidden = opts;\n    } else if (opts) {\n      const optKeys = ObjectKeys(opts);\n      for (let i = 0; i < optKeys.length; ++i) {\n        const key = optKeys[i];\n        // TODO(BridgeAR): Find a solution what to do about stylize. Either make\n        // this function public or add a new API with a similar or better\n        // functionality.\n        if (\n          ObjectPrototypeHasOwnProperty(inspectDefaultOptions, key) ||\n          key === 'stylize') {\n          ctx[key] = opts[key];\n        } else if (ctx.userOptions === undefined) {\n          // This is required to pass through the actual user input.\n          ctx.userOptions = opts;\n        }\n      }\n    }\n  }\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\n  if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;\n  return formatValue(ctx, value, 0);\n}\ninspect.custom = customInspectSymbol;\n\nObjectDefineProperty(inspect, 'defaultOptions', {\n  __proto__: null,\n  get() {\n    return inspectDefaultOptions;\n  },\n  set(options) {\n    validateObject(options, 'options');\n    return ObjectAssign(inspectDefaultOptions, options);\n  },\n});\n\n// Set Graphics Rendition https://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n// Each color consists of an array with the color code as first entry and the\n// reset code as second entry.\nconst defaultFG = 39;\nconst defaultBG = 49;\ninspect.colors = {\n  __proto__: null,\n  reset: [0, 0],\n  bold: [1, 22],\n  dim: [2, 22], // Alias: faint\n  italic: [3, 23],\n  underline: [4, 24],\n  blink: [5, 25],\n  // Swap foreground and background colors\n  inverse: [7, 27], // Alias: swapcolors, swapColors\n  hidden: [8, 28], // Alias: conceal\n  strikethrough: [9, 29], // Alias: strikeThrough, crossedout, crossedOut\n  doubleunderline: [21, 24], // Alias: doubleUnderline\n  black: [30, defaultFG],\n  red: [31, defaultFG],\n  green: [32, defaultFG],\n  yellow: [33, defaultFG],\n  blue: [34, defaultFG],\n  magenta: [35, defaultFG],\n  cyan: [36, defaultFG],\n  white: [37, defaultFG],\n  bgBlack: [40, defaultBG],\n  bgRed: [41, defaultBG],\n  bgGreen: [42, defaultBG],\n  bgYellow: [43, defaultBG],\n  bgBlue: [44, defaultBG],\n  bgMagenta: [45, defaultBG],\n  bgCyan: [46, defaultBG],\n  bgWhite: [47, defaultBG],\n  framed: [51, 54],\n  overlined: [53, 55],\n  gray: [90, defaultFG], // Alias: grey, blackBright\n  redBright: [91, defaultFG],\n  greenBright: [92, defaultFG],\n  yellowBright: [93, defaultFG],\n  blueBright: [94, defaultFG],\n  magentaBright: [95, defaultFG],\n  cyanBright: [96, defaultFG],\n  whiteBright: [97, defaultFG],\n  bgGray: [100, defaultBG], // Alias: bgGrey, bgBlackBright\n  bgRedBright: [101, defaultBG],\n  bgGreenBright: [102, defaultBG],\n  bgYellowBright: [103, defaultBG],\n  bgBlueBright: [104, defaultBG],\n  bgMagentaBright: [105, defaultBG],\n  bgCyanBright: [106, defaultBG],\n  bgWhiteBright: [107, defaultBG],\n};\n\nfunction defineColorAlias(target, alias) {\n  ObjectDefineProperty(inspect.colors, alias, {\n    __proto__: null,\n    get() {\n      return this[target];\n    },\n    set(value) {\n      this[target] = value;\n    },\n    configurable: true,\n    enumerable: false,\n  });\n}\n\ndefineColorAlias('gray', 'grey');\ndefineColorAlias('gray', 'blackBright');\ndefineColorAlias('bgGray', 'bgGrey');\ndefineColorAlias('bgGray', 'bgBlackBright');\ndefineColorAlias('dim', 'faint');\ndefineColorAlias('strikethrough', 'crossedout');\ndefineColorAlias('strikethrough', 'strikeThrough');\ndefineColorAlias('strikethrough', 'crossedOut');\ndefineColorAlias('hidden', 'conceal');\ndefineColorAlias('inverse', 'swapColors');\ndefineColorAlias('inverse', 'swapcolors');\ndefineColorAlias('doubleunderline', 'doubleUnderline');\n\n// TODO(BridgeAR): Add function style support for more complex styles.\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = ObjectAssign({ __proto__: null }, {\n  special: 'cyan',\n  number: 'yellow',\n  bigint: 'yellow',\n  boolean: 'yellow',\n  undefined: 'grey',\n  null: 'bold',\n  string: 'green',\n  symbol: 'green',\n  date: 'magenta',\n  // \"name\": intentionally not styling\n  // TODO(BridgeAR): Highlight regular expressions properly.\n  regexp: 'red',\n  module: 'underline',\n});\n\nfunction addQuotes(str, quotes) {\n  if (quotes === -1) {\n    return `\"${str}\"`;\n  }\n  if (quotes === -2) {\n    return `\\`${str}\\``;\n  }\n  return `'${str}'`;\n}\n\nfunction escapeFn(str) {\n  const charCode = StringPrototypeCharCodeAt(str);\n  return meta.length > charCode ? meta[charCode] : `\\\\u${NumberPrototypeToString(charCode, 16)}`;\n}\n\n// Escape control characters, single quotes and the backslash.\n// This is similar to JSON stringify escaping.\nfunction strEscape(str) {\n  let escapeTest = strEscapeSequencesRegExp;\n  let escapeReplace = strEscapeSequencesReplacer;\n  let singleQuote = 39;\n\n  // Check for double quotes. If not present, do not escape single quotes and\n  // instead wrap the text in double quotes. If double quotes exist, check for\n  // backticks. If they do not exist, use those as fallback instead of the\n  // double quotes.\n  if (StringPrototypeIncludes(str, \"'\")) {\n    // This invalidates the charCode and therefore can not be matched for\n    // anymore.\n    if (!StringPrototypeIncludes(str, '\"')) {\n      singleQuote = -1;\n    } else if (!StringPrototypeIncludes(str, '`') &&\n               !StringPrototypeIncludes(str, '${')) {\n      singleQuote = -2;\n    }\n    if (singleQuote !== 39) {\n      escapeTest = strEscapeSequencesRegExpSingle;\n      escapeReplace = strEscapeSequencesReplacerSingle;\n    }\n  }\n\n  // Some magic numbers that worked out fine while benchmarking with v8 6.0\n  if (str.length < 5000 && RegExpPrototypeExec(escapeTest, str) === null)\n    return addQuotes(str, singleQuote);\n  if (str.length > 100) {\n    str = RegExpPrototypeSymbolReplace(escapeReplace, str, escapeFn);\n    return addQuotes(str, singleQuote);\n  }\n\n  let result = '';\n  let last = 0;\n  for (let i = 0; i < str.length; i++) {\n    const point = StringPrototypeCharCodeAt(str, i);\n    if (point === singleQuote ||\n        point === 92 ||\n        point < 32 ||\n        (point > 126 && point < 160)) {\n      if (last === i) {\n        result += meta[point];\n      } else {\n        result += `${StringPrototypeSlice(str, last, i)}${meta[point]}`;\n      }\n      last = i + 1;\n    } else if (point >= 0xd800 && point <= 0xdfff) {\n      if (point <= 0xdbff && i + 1 < str.length) {\n        const point = StringPrototypeCharCodeAt(str, i + 1);\n        if (point >= 0xdc00 && point <= 0xdfff) {\n          i++;\n          continue;\n        }\n      }\n      result += `${StringPrototypeSlice(str, last, i)}\\\\u${NumberPrototypeToString(point, 16)}`;\n      last = i + 1;\n    }\n  }\n\n  if (last !== str.length) {\n    result += StringPrototypeSlice(str, last);\n  }\n  return addQuotes(result, singleQuote);\n}\n\nfunction stylizeWithColor(str, styleType) {\n  const style = inspect.styles[styleType];\n  if (style !== undefined) {\n    const color = inspect.colors[style];\n    if (color !== undefined)\n      return `\\u001b[${color[0]}m${str}\\u001b[${color[1]}m`;\n  }\n  return str;\n}\n\nfunction stylizeNoColor(str) {\n  return str;\n}\n\n// Return a new empty array to push in the results of the default formatter.\nfunction getEmptyFormatArray() {\n  return [];\n}\n\nfunction isInstanceof(object, proto) {\n  try {\n    return object instanceof proto;\n  } catch {\n    return false;\n  }\n}\n\nfunction getConstructorName(obj, ctx, recurseTimes, protoProps) {\n  let firstProto;\n  const tmp = obj;\n  while (obj || isUndetectableObject(obj)) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj, 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '' &&\n        isInstanceof(tmp, descriptor.value)) {\n      if (protoProps !== undefined &&\n         (firstProto !== obj ||\n         !builtInObjects.has(descriptor.value.name))) {\n        addPrototypeProperties(\n          ctx, tmp, firstProto || tmp, recurseTimes, protoProps);\n      }\n      return String(descriptor.value.name);\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n    if (firstProto === undefined) {\n      firstProto = obj;\n    }\n  }\n\n  if (firstProto === null) {\n    return null;\n  }\n\n  const res = internalGetConstructorName(tmp);\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return `${res} <Complex prototype>`;\n  }\n\n  const protoConstr = getConstructorName(\n    firstProto, ctx, recurseTimes + 1, protoProps);\n\n  if (protoConstr === null) {\n    return `${res} <${inspect(firstProto, {\n      ...ctx,\n      customInspect: false,\n      depth: -1,\n    })}>`;\n  }\n\n  return `${res} <${protoConstr}>`;\n}\n\n// This function has the side effect of adding prototype properties to the\n// `output` argument (which is an array). This is intended to highlight user\n// defined prototype properties.\nfunction addPrototypeProperties(ctx, main, obj, recurseTimes, output) {\n  let depth = 0;\n  let keys;\n  let keySet;\n  do {\n    if (depth !== 0 || main === obj) {\n      obj = ObjectGetPrototypeOf(obj);\n      // Stop as soon as a null prototype is encountered.\n      if (obj === null) {\n        return;\n      }\n      // Stop as soon as a built-in object type is detected.\n      const descriptor = ObjectGetOwnPropertyDescriptor(obj, 'constructor');\n      if (descriptor !== undefined &&\n          typeof descriptor.value === 'function' &&\n          builtInObjects.has(descriptor.value.name)) {\n        return;\n      }\n    }\n\n    if (depth === 0) {\n      keySet = new SafeSet();\n    } else {\n      ArrayPrototypeForEach(keys, (key) => keySet.add(key));\n    }\n    // Get all own property names and symbols.\n    keys = ReflectOwnKeys(obj);\n    ArrayPrototypePush(ctx.seen, main);\n    for (const key of keys) {\n      // Ignore the `constructor` property and keys that exist on layers above.\n      if (key === 'constructor' ||\n          ObjectPrototypeHasOwnProperty(main, key) ||\n          (depth !== 0 && keySet.has(key))) {\n        continue;\n      }\n      const desc = ObjectGetOwnPropertyDescriptor(obj, key);\n      if (typeof desc.value === 'function') {\n        continue;\n      }\n      const value = formatProperty(\n        ctx, obj, recurseTimes, key, kObjectType, desc, main);\n      if (ctx.colors) {\n        // Faint!\n        ArrayPrototypePush(output, `\\u001b[2m${value}\\u001b[22m`);\n      } else {\n        ArrayPrototypePush(output, value);\n      }\n    }\n    ArrayPrototypePop(ctx.seen);\n  // Limit the inspection to up to three prototype layers. Using `recurseTimes`\n  // is not a good choice here, because it's as if the properties are declared\n  // on the current object from the users perspective.\n  } while (++depth !== 3);\n}\n\nfunction getPrefix(constructor, tag, fallback, size = '') {\n  if (constructor === null) {\n    if (tag !== '' && fallback !== tag) {\n      return `[${fallback}${size}: null prototype] [${tag}] `;\n    }\n    return `[${fallback}${size}: null prototype] `;\n  }\n\n  if (tag !== '' && constructor !== tag) {\n    return `${constructor}${size} [${tag}] `;\n  }\n  return `${constructor}${size} `;\n}\n\n// Look up the keys of the object.\nfunction getKeys(value, showHidden) {\n  let keys;\n  const symbols = ObjectGetOwnPropertySymbols(value);\n  if (showHidden) {\n    keys = ObjectGetOwnPropertyNames(value);\n    if (symbols.length !== 0)\n      ArrayPrototypePushApply(keys, symbols);\n  } else {\n    // This might throw if `value` is a Module Namespace Object from an\n    // unevaluated module, but we don't want to perform the actual type\n    // check because it's expensive.\n    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\n    // and modify this logic as needed.\n    try {\n      keys = ObjectKeys(value);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError' &&\n             isModuleNamespaceObject(value));\n      keys = ObjectGetOwnPropertyNames(value);\n    }\n    if (symbols.length !== 0) {\n      const filter = (key) => ObjectPrototypePropertyIsEnumerable(value, key);\n      ArrayPrototypePushApply(keys, ArrayPrototypeFilter(symbols, filter));\n    }\n  }\n  return keys;\n}\n\nfunction getCtxStyle(value, constructor, tag) {\n  let fallback = '';\n  if (constructor === null) {\n    fallback = internalGetConstructorName(value);\n    if (fallback === tag) {\n      fallback = 'Object';\n    }\n  }\n  return getPrefix(constructor, tag, fallback);\n}\n\nfunction formatProxy(ctx, proxy, recurseTimes) {\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return ctx.stylize('Proxy [Array]', 'special');\n  }\n  recurseTimes += 1;\n  ctx.indentationLvl += 2;\n  const res = [\n    formatValue(ctx, proxy[0], recurseTimes),\n    formatValue(ctx, proxy[1], recurseTimes),\n  ];\n  ctx.indentationLvl -= 2;\n  return reduceToSingleString(\n    ctx, res, '', ['Proxy [', ']'], kArrayExtrasType, recurseTimes);\n}\n\n// Note: using `formatValue` directly requires the indentation level to be\n// corrected by setting `ctx.indentationLvL += diff` and then to decrease the\n// value afterwards again.\nfunction formatValue(ctx, value, recurseTimes, typedArray) {\n  // Primitive types cannot have properties.\n  if (typeof value !== 'object' &&\n      typeof value !== 'function' &&\n      !isUndetectableObject(value)) {\n    return formatPrimitive(ctx.stylize, value, ctx);\n  }\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n\n  // Memorize the context for custom inspection on proxies.\n  const context = value;\n  // Always check for proxies to prevent side effects and to prevent triggering\n  // any proxy handlers.\n  const proxy = getProxyDetails(value, !!ctx.showProxy);\n  if (proxy !== undefined) {\n    if (proxy === null || proxy[0] === null) {\n      return ctx.stylize('<Revoked Proxy>', 'special');\n    }\n    if (ctx.showProxy) {\n      return formatProxy(ctx, proxy, recurseTimes);\n    }\n    value = proxy;\n  }\n\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it.\n  if (ctx.customInspect) {\n    const maybeCustom = value[customInspectSymbol];\n    if (typeof maybeCustom === 'function' &&\n        // Filter out the util module, its inspect function is special.\n        maybeCustom !== inspect &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      // This makes sure the recurseTimes are reported as before while using\n      // a counter internally.\n      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;\n      const isCrossContext =\n        proxy !== undefined || !(context instanceof Object);\n      const ret = FunctionPrototypeCall(\n        maybeCustom,\n        context,\n        depth,\n        getUserOptions(ctx, isCrossContext),\n        inspect,\n      );\n      // If the custom inspection method returned `this`, don't go into\n      // infinite recursion.\n      if (ret !== context) {\n        if (typeof ret !== 'string') {\n          return formatValue(ctx, ret, recurseTimes);\n        }\n        return StringPrototypeReplaceAll(ret, '\\n', `\\n${StringPrototypeRepeat(' ', ctx.indentationLvl)}`);\n      }\n    }\n  }\n\n  // Using an array here is actually better for the average case than using\n  // a Set. `seen` will only check for the depth and will never grow too large.\n  if (ctx.seen.includes(value)) {\n    let index = 1;\n    if (ctx.circular === undefined) {\n      ctx.circular = new SafeMap();\n      ctx.circular.set(value, index);\n    } else {\n      index = ctx.circular.get(value);\n      if (index === undefined) {\n        index = ctx.circular.size + 1;\n        ctx.circular.set(value, index);\n      }\n    }\n    return ctx.stylize(`[Circular *${index}]`, 'special');\n  }\n\n  return formatRaw(ctx, value, recurseTimes, typedArray);\n}\n\nfunction formatRaw(ctx, value, recurseTimes, typedArray) {\n  let keys;\n  let protoProps;\n  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {\n    protoProps = [];\n  }\n\n  const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);\n  // Reset the variable to check for this later on.\n  if (protoProps !== undefined && protoProps.length === 0) {\n    protoProps = undefined;\n  }\n\n  let tag = value[SymbolToStringTag];\n  // Only list the tag in case it's non-enumerable / not an own property.\n  // Otherwise we'd print this twice.\n  if (typeof tag !== 'string' ||\n      (tag !== '' &&\n      (ctx.showHidden ?\n        ObjectPrototypeHasOwnProperty :\n        ObjectPrototypePropertyIsEnumerable)(\n        value, SymbolToStringTag,\n      ))) {\n    tag = '';\n  }\n  let base = '';\n  let formatter = getEmptyFormatArray;\n  let braces;\n  let noIterator = true;\n  let i = 0;\n  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n\n  let extrasType = kObjectType;\n\n  // Iterators and the rest are split to reduce checks.\n  // We have to check all values in case the constructor is set to null.\n  // Otherwise it would not possible to identify all types properly.\n  if (SymbolIterator in value || constructor === null) {\n    noIterator = false;\n    if (ArrayIsArray(value)) {\n      // Only set the constructor for non ordinary (\"Array [...]\") arrays.\n      const prefix = (constructor !== 'Array' || tag !== '') ?\n        getPrefix(constructor, tag, 'Array', `(${value.length})`) :\n        '';\n      keys = getOwnNonIndexProperties(value, filter);\n      braces = [`${prefix}[`, ']'];\n      if (value.length === 0 && keys.length === 0 && protoProps === undefined)\n        return `${braces[0]}]`;\n      extrasType = kArrayExtrasType;\n      formatter = formatArray;\n    } else if (isSet(value)) {\n      const size = SetPrototypeGetSize(value);\n      const prefix = getPrefix(constructor, tag, 'Set', `(${size})`);\n      keys = getKeys(value, ctx.showHidden);\n      formatter = constructor !== null ?\n        FunctionPrototypeBind(formatSet, null, value) :\n        FunctionPrototypeBind(formatSet, null, SetPrototypeValues(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`, '}'];\n    } else if (isMap(value)) {\n      const size = MapPrototypeGetSize(value);\n      const prefix = getPrefix(constructor, tag, 'Map', `(${size})`);\n      keys = getKeys(value, ctx.showHidden);\n      formatter = constructor !== null ?\n        FunctionPrototypeBind(formatMap, null, value) :\n        FunctionPrototypeBind(formatMap, null, MapPrototypeEntries(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`, '}'];\n    } else if (isTypedArray(value)) {\n      keys = getOwnNonIndexProperties(value, filter);\n      let bound = value;\n      let fallback = '';\n      if (constructor === null) {\n        fallback = TypedArrayPrototypeGetSymbolToStringTag(value);\n        // Reconstruct the array information.\n        bound = new primordials[fallback](value);\n      }\n      const size = TypedArrayPrototypeGetLength(value);\n      const prefix = getPrefix(constructor, tag, fallback, `(${size})`);\n      braces = [`${prefix}[`, ']'];\n      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\n        return `${braces[0]}]`;\n      // Special handle the value. The original value is required below. The\n      // bound function is required to reconstruct missing information.\n      formatter = FunctionPrototypeBind(formatTypedArray, null, bound, size);\n      extrasType = kArrayExtrasType;\n    } else if (isMapIterator(value)) {\n      keys = getKeys(value, ctx.showHidden);\n      braces = getIteratorBraces('Map', tag);\n      // Add braces to the formatter parameters.\n      formatter = FunctionPrototypeBind(formatIterator, null, braces);\n    } else if (isSetIterator(value)) {\n      keys = getKeys(value, ctx.showHidden);\n      braces = getIteratorBraces('Set', tag);\n      // Add braces to the formatter parameters.\n      formatter = FunctionPrototypeBind(formatIterator, null, braces);\n    } else {\n      noIterator = true;\n    }\n  }\n  if (noIterator) {\n    keys = getKeys(value, ctx.showHidden);\n    braces = ['{', '}'];\n    if (constructor === 'Object') {\n      if (isArgumentsObject(value)) {\n        braces[0] = '[Arguments] {';\n      } else if (tag !== '') {\n        braces[0] = `${getPrefix(constructor, tag, 'Object')}{`;\n      }\n      if (keys.length === 0 && protoProps === undefined) {\n        return `${braces[0]}}`;\n      }\n    } else if (typeof value === 'function') {\n      base = getFunctionBase(value, constructor, tag);\n      if (keys.length === 0 && protoProps === undefined)\n        return ctx.stylize(base, 'special');\n    } else if (isRegExp(value)) {\n      // Make RegExps say that they are RegExps\n      base = RegExpPrototypeToString(\n        constructor !== null ? value : new RegExp(value),\n      );\n      const prefix = getPrefix(constructor, tag, 'RegExp');\n      if (prefix !== 'RegExp ')\n        base = `${prefix}${base}`;\n      if ((keys.length === 0 && protoProps === undefined) ||\n          (recurseTimes > ctx.depth && ctx.depth !== null)) {\n        return ctx.stylize(base, 'regexp');\n      }\n    } else if (isDate(value)) {\n      // Make dates with properties first say the date\n      base = NumberIsNaN(DatePrototypeGetTime(value)) ?\n        DatePrototypeToString(value) :\n        DatePrototypeToISOString(value);\n      const prefix = getPrefix(constructor, tag, 'Date');\n      if (prefix !== 'Date ')\n        base = `${prefix}${base}`;\n      if (keys.length === 0 && protoProps === undefined) {\n        return ctx.stylize(base, 'date');\n      }\n    } else if (isError(value)) {\n      base = formatError(value, constructor, tag, ctx, keys);\n      if (keys.length === 0 && protoProps === undefined)\n        return base;\n    } else if (isAnyArrayBuffer(value)) {\n      // Fast path for ArrayBuffer and SharedArrayBuffer.\n      // Can't do the same for DataView because it has a non-primitive\n      // .buffer property that we need to recurse for.\n      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' :\n        'SharedArrayBuffer';\n      const prefix = getPrefix(constructor, tag, arrayType);\n      if (typedArray === undefined) {\n        formatter = formatArrayBuffer;\n      } else if (keys.length === 0 && protoProps === undefined) {\n        return prefix +\n              `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength, false)} }`;\n      }\n      braces[0] = `${prefix}{`;\n      ArrayPrototypeUnshift(keys, 'byteLength');\n    } else if (isDataView(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'DataView')}{`;\n      // .buffer goes last, it's not a primitive like the others.\n      ArrayPrototypeUnshift(keys, 'byteLength', 'byteOffset', 'buffer');\n    } else if (isPromise(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'Promise')}{`;\n      formatter = formatPromise;\n    } else if (isWeakSet(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'WeakSet')}{`;\n      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\n    } else if (isWeakMap(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'WeakMap')}{`;\n      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\n    } else if (isModuleNamespaceObject(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'Module')}{`;\n      // Special handle keys for namespace objects.\n      formatter = formatNamespaceObject.bind(null, keys);\n    } else if (isBoxedPrimitive(value)) {\n      base = getBoxedBase(value, ctx, keys, constructor, tag);\n      if (keys.length === 0 && protoProps === undefined) {\n        return base;\n      }\n    } else {\n      if (keys.length === 0 && protoProps === undefined) {\n        if (isExternal(value)) {\n          const address = getExternalValue(value).toString(16);\n          return ctx.stylize(`[External: ${address}]`, 'special');\n        }\n        return `${getCtxStyle(value, constructor, tag)}{}`;\n      }\n      braces[0] = `${getCtxStyle(value, constructor, tag)}{`;\n    }\n  }\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    let constructorName = StringPrototypeSlice(getCtxStyle(value, constructor, tag), 0, -1);\n    if (constructor !== null)\n      constructorName = `[${constructorName}]`;\n    return ctx.stylize(constructorName, 'special');\n  }\n  recurseTimes += 1;\n\n  ctx.seen.push(value);\n  ctx.currentDepth = recurseTimes;\n  let output;\n  const indentationLvl = ctx.indentationLvl;\n  try {\n    output = formatter(ctx, value, recurseTimes);\n    for (i = 0; i < keys.length; i++) {\n      ArrayPrototypePush(\n        output,\n        formatProperty(ctx, value, recurseTimes, keys[i], extrasType),\n      );\n    }\n    if (protoProps !== undefined) {\n      ArrayPrototypePushApply(output, protoProps);\n    }\n  } catch (err) {\n    const constructorName = StringPrototypeSlice(getCtxStyle(value, constructor, tag), 0, -1);\n    return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);\n  }\n  if (ctx.circular !== undefined) {\n    const index = ctx.circular.get(value);\n    if (index !== undefined) {\n      const reference = ctx.stylize(`<ref *${index}>`, 'special');\n      // Add reference always to the very beginning of the output.\n      if (ctx.compact !== true) {\n        base = base === '' ? reference : `${reference} ${base}`;\n      } else {\n        braces[0] = `${reference} ${braces[0]}`;\n      }\n    }\n  }\n  ctx.seen.pop();\n\n  if (ctx.sorted) {\n    const comparator = ctx.sorted === true ? undefined : ctx.sorted;\n    if (extrasType === kObjectType) {\n      ArrayPrototypeSort(output, comparator);\n    } else if (keys.length > 1) {\n      const sorted = ArrayPrototypeSort(ArrayPrototypeSlice(output, output.length - keys.length), comparator);\n      ArrayPrototypeUnshift(sorted, output, output.length - keys.length, keys.length);\n      ReflectApply(ArrayPrototypeSplice, null, sorted);\n    }\n  }\n\n  const res = reduceToSingleString(\n    ctx, output, base, braces, extrasType, recurseTimes, value);\n  const budget = ctx.budget[ctx.indentationLvl] || 0;\n  const newLength = budget + res.length;\n  ctx.budget[ctx.indentationLvl] = newLength;\n  // If any indentationLvl exceeds this limit, limit further inspecting to the\n  // minimum. Otherwise the recursive algorithm might continue inspecting the\n  // object even though the maximum string size (~2 ** 28 on 32 bit systems and\n  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at\n  // exactly 2 ** 27 but a bit higher. This depends on the object shape.\n  // This limit also makes sure that huge objects don't block the event loop\n  // significantly.\n  if (newLength > 2 ** 27) {\n    ctx.depth = -1;\n  }\n  return res;\n}\n\nfunction getIteratorBraces(type, tag) {\n  if (tag !== `${type} Iterator`) {\n    if (tag !== '')\n      tag += '] [';\n    tag += `${type} Iterator`;\n  }\n  return [`[${tag}] {`, '}'];\n}\n\nfunction getBoxedBase(value, ctx, keys, constructor, tag) {\n  let fn;\n  let type;\n  if (isNumberObject(value)) {\n    fn = NumberPrototypeValueOf;\n    type = 'Number';\n  } else if (isStringObject(value)) {\n    fn = StringPrototypeValueOf;\n    type = 'String';\n    // For boxed Strings, we have to remove the 0-n indexed entries,\n    // since they just noisy up the output and are redundant\n    // Make boxed primitive Strings look like such\n    keys.splice(0, value.length);\n  } else if (isBooleanObject(value)) {\n    fn = BooleanPrototypeValueOf;\n    type = 'Boolean';\n  } else if (isBigIntObject(value)) {\n    fn = BigIntPrototypeValueOf;\n    type = 'BigInt';\n  } else {\n    fn = SymbolPrototypeValueOf;\n    type = 'Symbol';\n  }\n  let base = `[${type}`;\n  if (type !== constructor) {\n    if (constructor === null) {\n      base += ' (null prototype)';\n    } else {\n      base += ` (${constructor})`;\n    }\n  }\n  base += `: ${formatPrimitive(stylizeNoColor, fn(value), ctx)}]`;\n  if (tag !== '' && tag !== constructor) {\n    base += ` [${tag}]`;\n  }\n  if (keys.length !== 0 || ctx.stylize === stylizeNoColor)\n    return base;\n  return ctx.stylize(base, StringPrototypeToLowerCase(type));\n}\n\nfunction getClassBase(value, constructor, tag) {\n  const hasName = ObjectPrototypeHasOwnProperty(value, 'name');\n  const name = (hasName && value.name) || '(anonymous)';\n  let base = `class ${name}`;\n  if (constructor !== 'Function' && constructor !== null) {\n    base += ` [${constructor}]`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  if (constructor !== null) {\n    const superName = ObjectGetPrototypeOf(value).name;\n    if (superName) {\n      base += ` extends ${superName}`;\n    }\n  } else {\n    base += ' extends [null prototype]';\n  }\n  return `[${base}]`;\n}\n\nfunction getFunctionBase(value, constructor, tag) {\n  const stringified = FunctionPrototypeToString(value);\n  if (StringPrototypeStartsWith(stringified, 'class') && StringPrototypeEndsWith(stringified, '}')) {\n    const slice = StringPrototypeSlice(stringified, 5, -1);\n    const bracketIndex = StringPrototypeIndexOf(slice, '{');\n    if (bracketIndex !== -1 &&\n        (!StringPrototypeIncludes(StringPrototypeSlice(slice, 0, bracketIndex), '(') ||\n        // Slow path to guarantee that it's indeed a class.\n        RegExpPrototypeExec(classRegExp, RegExpPrototypeSymbolReplace(stripCommentsRegExp, slice)) !== null)\n    ) {\n      return getClassBase(value, constructor, tag);\n    }\n  }\n  let type = 'Function';\n  if (isGeneratorFunction(value)) {\n    type = `Generator${type}`;\n  }\n  if (isAsyncFunction(value)) {\n    type = `Async${type}`;\n  }\n  let base = `[${type}`;\n  if (constructor === null) {\n    base += ' (null prototype)';\n  }\n  if (value.name === '') {\n    base += ' (anonymous)';\n  } else {\n    base += `: ${value.name}`;\n  }\n  base += ']';\n  if (constructor !== type && constructor !== null) {\n    base += ` ${constructor}`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  return base;\n}\n\nfunction identicalSequenceRange(a, b) {\n  for (let i = 0; i < a.length - 3; i++) {\n    // Find the first entry of b that matches the current entry of a.\n    const pos = ArrayPrototypeIndexOf(b, a[i]);\n    if (pos !== -1) {\n      const rest = b.length - pos;\n      if (rest > 3) {\n        let len = 1;\n        const maxLen = MathMin(a.length - i, rest);\n        // Count the number of consecutive entries.\n        while (maxLen > len && a[i + len] === b[pos + len]) {\n          len++;\n        }\n        if (len > 3) {\n          return { len, offset: i };\n        }\n      }\n    }\n  }\n\n  return { len: 0, offset: 0 };\n}\n\nfunction getStackString(error) {\n  return error.stack ? String(error.stack) : ErrorPrototypeToString(error);\n}\n\nfunction getStackFrames(ctx, err, stack) {\n  const frames = StringPrototypeSplit(stack, '\\n');\n\n  let cause;\n  try {\n    ({ cause } = err);\n  } catch {\n    // If 'cause' is a getter that throws, ignore it.\n  }\n\n  // Remove stack frames identical to frames in cause.\n  if (cause != null && isError(cause)) {\n    const causeStack = getStackString(cause);\n    const causeStackStart = StringPrototypeIndexOf(causeStack, '\\n    at');\n    if (causeStackStart !== -1) {\n      const causeFrames = StringPrototypeSplit(StringPrototypeSlice(causeStack, causeStackStart + 1), '\\n');\n      const { len, offset } = identicalSequenceRange(frames, causeFrames);\n      if (len > 0) {\n        const skipped = len - 2;\n        const msg = `    ... ${skipped} lines matching cause stack trace ...`;\n        frames.splice(offset + 1, skipped, ctx.stylize(msg, 'undefined'));\n      }\n    }\n  }\n  return frames;\n}\n\nfunction improveStack(stack, constructor, name, tag) {\n  // A stack trace may contain arbitrary data. Only manipulate the output\n  // for \"regular errors\" (errors that \"look normal\") for now.\n  let len = name.length;\n\n  if (constructor === null ||\n      (StringPrototypeEndsWith(name, 'Error') &&\n      StringPrototypeStartsWith(stack, name) &&\n      (stack.length === len || stack[len] === ':' || stack[len] === '\\n'))) {\n    let fallback = 'Error';\n    if (constructor === null) {\n      const start = RegExpPrototypeExec(/^([A-Z][a-z_ A-Z0-9[\\]()-]+)(?::|\\n {4}at)/, stack) ||\n      RegExpPrototypeExec(/^([a-z_A-Z0-9-]*Error)$/, stack);\n      fallback = (start && start[1]) || '';\n      len = fallback.length;\n      fallback = fallback || 'Error';\n    }\n    const prefix = StringPrototypeSlice(getPrefix(constructor, tag, fallback), 0, -1);\n    if (name !== prefix) {\n      if (StringPrototypeIncludes(prefix, name)) {\n        if (len === 0) {\n          stack = `${prefix}: ${stack}`;\n        } else {\n          stack = `${prefix}${StringPrototypeSlice(stack, len)}`;\n        }\n      } else {\n        stack = `${prefix} [${name}]${StringPrototypeSlice(stack, len)}`;\n      }\n    }\n  }\n  return stack;\n}\n\nfunction removeDuplicateErrorKeys(ctx, keys, err, stack) {\n  if (!ctx.showHidden && keys.length !== 0) {\n    for (const name of ['name', 'message', 'stack']) {\n      const index = ArrayPrototypeIndexOf(keys, name);\n      // Only hide the property in case it's part of the original stack\n      if (index !== -1 && StringPrototypeIncludes(stack, err[name])) {\n        ArrayPrototypeSplice(keys, index, 1);\n      }\n    }\n  }\n}\n\nfunction markNodeModules(ctx, line) {\n  let tempLine = '';\n  let nodeModule;\n  let pos = 0;\n  while ((nodeModule = nodeModulesRegExp.exec(line)) !== null) {\n    // '/node_modules/'.length === 14\n    tempLine += StringPrototypeSlice(line, pos, nodeModule.index + 14);\n    tempLine += ctx.stylize(nodeModule[1], 'module');\n    pos = nodeModule.index + nodeModule[0].length;\n  }\n  if (pos !== 0) {\n    line = tempLine + StringPrototypeSlice(line, pos);\n  }\n  return line;\n}\n\nfunction markCwd(ctx, line, workingDirectory) {\n  let cwdStartPos = StringPrototypeIndexOf(line, workingDirectory);\n  let tempLine = '';\n  let cwdLength = workingDirectory.length;\n  if (cwdStartPos !== -1) {\n    if (StringPrototypeSlice(line, cwdStartPos - 7, cwdStartPos) === 'file://') {\n      cwdLength += 7;\n      cwdStartPos -= 7;\n    }\n    const start = line[cwdStartPos - 1] === '(' ? cwdStartPos - 1 : cwdStartPos;\n    const end = start !== cwdStartPos && StringPrototypeEndsWith(line, ')') ? -1 : line.length;\n    const workingDirectoryEndPos = cwdStartPos + cwdLength + 1;\n    const cwdSlice = StringPrototypeSlice(line, start, workingDirectoryEndPos);\n\n    tempLine += StringPrototypeSlice(line, 0, start);\n    tempLine += ctx.stylize(cwdSlice, 'undefined');\n    tempLine += StringPrototypeSlice(line, workingDirectoryEndPos, end);\n    if (end === -1) {\n      tempLine += ctx.stylize(')', 'undefined');\n    }\n  } else {\n    tempLine += line;\n  }\n  return tempLine;\n}\n\nfunction safeGetCWD() {\n  let workingDirectory;\n  try {\n    workingDirectory = process.cwd();\n  } catch {\n    return;\n  }\n  return workingDirectory;\n}\n\nfunction formatError(err, constructor, tag, ctx, keys) {\n  const name = err.name != null ? String(err.name) : 'Error';\n  let stack = getStackString(err);\n\n  removeDuplicateErrorKeys(ctx, keys, err, stack);\n\n  if ('cause' in err &&\n      (keys.length === 0 || !ArrayPrototypeIncludes(keys, 'cause'))) {\n    ArrayPrototypePush(keys, 'cause');\n  }\n\n  // Print errors aggregated into AggregateError\n  if (ArrayIsArray(err.errors) &&\n      (keys.length === 0 || !ArrayPrototypeIncludes(keys, 'errors'))) {\n    ArrayPrototypePush(keys, 'errors');\n  }\n\n  stack = improveStack(stack, constructor, name, tag);\n\n  // Ignore the error message if it's contained in the stack.\n  let pos = (err.message && StringPrototypeIndexOf(stack, err.message)) || -1;\n  if (pos !== -1)\n    pos += err.message.length;\n  // Wrap the error in brackets in case it has no stack trace.\n  const stackStart = StringPrototypeIndexOf(stack, '\\n    at', pos);\n  if (stackStart === -1) {\n    stack = `[${stack}]`;\n  } else {\n    let newStack = StringPrototypeSlice(stack, 0, stackStart);\n    const stackFramePart = StringPrototypeSlice(stack, stackStart + 1);\n    const lines = getStackFrames(ctx, err, stackFramePart);\n    if (ctx.colors) {\n      // Highlight userland code and node modules.\n      const workingDirectory = safeGetCWD();\n      let esmWorkingDirectory;\n      for (let line of lines) {\n        const core = RegExpPrototypeExec(coreModuleRegExp, line);\n        if (core !== null && BuiltinModule.exists(core[1])) {\n          newStack += `\\n${ctx.stylize(line, 'undefined')}`;\n        } else {\n          newStack += '\\n';\n\n          line = markNodeModules(ctx, line);\n          if (workingDirectory !== undefined) {\n            let newLine = markCwd(ctx, line, workingDirectory);\n            if (newLine === line) {\n              esmWorkingDirectory ??= pathToFileUrlHref(workingDirectory);\n              newLine = markCwd(ctx, line, esmWorkingDirectory);\n            }\n            line = newLine;\n          }\n\n          newStack += line;\n        }\n      }\n    } else {\n      newStack += `\\n${ArrayPrototypeJoin(lines, '\\n')}`;\n    }\n    stack = newStack;\n  }\n  // The message and the stack have to be indented as well!\n  if (ctx.indentationLvl !== 0) {\n    const indentation = StringPrototypeRepeat(' ', ctx.indentationLvl);\n    stack = StringPrototypeReplaceAll(stack, '\\n', `\\n${indentation}`);\n  }\n  return stack;\n}\n\nfunction groupArrayElements(ctx, output, value) {\n  let totalLength = 0;\n  let maxLength = 0;\n  let i = 0;\n  let outputLength = output.length;\n  if (ctx.maxArrayLength < output.length) {\n    // This makes sure the \"... n more items\" part is not taken into account.\n    outputLength--;\n  }\n  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.\n  const dataLen = new Array(outputLength);\n  // Calculate the total length of all output entries and the individual max\n  // entries length of all output entries. We have to remove colors first,\n  // otherwise the length would not be calculated properly.\n  for (; i < outputLength; i++) {\n    const len = getStringWidth(output[i], ctx.colors);\n    dataLen[i] = len;\n    totalLength += len + separatorSpace;\n    if (maxLength < len)\n      maxLength = len;\n  }\n  // Add two to `maxLength` as we add a single whitespace character plus a comma\n  // in-between two entries.\n  const actualMax = maxLength + separatorSpace;\n  // Check if at least three entries fit next to each other and prevent grouping\n  // of arrays that contains entries of very different length (i.e., if a single\n  // entry is longer than 1/5 of all other entries combined). Otherwise the\n  // space in-between small entries would be enormous.\n  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength &&\n      (totalLength / actualMax > 5 || maxLength <= 6)) {\n\n    const approxCharHeights = 2.5;\n    const averageBias = MathSqrt(actualMax - totalLength / output.length);\n    const biasedMax = MathMax(actualMax - 3 - averageBias, 1);\n    // Dynamically check how many columns seem possible.\n    const columns = MathMin(\n      // Ideally a square should be drawn. We expect a character to be about 2.5\n      // times as high as wide. This is the area formula to calculate a square\n      // which contains n rectangles of size `actualMax * approxCharHeights`.\n      // Divide that by `actualMax` to receive the correct number of columns.\n      // The added bias increases the columns for short entries.\n      MathRound(\n        MathSqrt(\n          approxCharHeights * biasedMax * outputLength,\n        ) / biasedMax,\n      ),\n      // Do not exceed the breakLength.\n      MathFloor((ctx.breakLength - ctx.indentationLvl) / actualMax),\n      // Limit array grouping for small `compact` modes as the user requested\n      // minimal grouping.\n      ctx.compact * 4,\n      // Limit the columns to a maximum of fifteen.\n      15,\n    );\n    // Return with the original output if no grouping should happen.\n    if (columns <= 1) {\n      return output;\n    }\n    const tmp = [];\n    const maxLineLength = [];\n    for (let i = 0; i < columns; i++) {\n      let lineMaxLength = 0;\n      for (let j = i; j < output.length; j += columns) {\n        if (dataLen[j] > lineMaxLength)\n          lineMaxLength = dataLen[j];\n      }\n      lineMaxLength += separatorSpace;\n      maxLineLength[i] = lineMaxLength;\n    }\n    let order = StringPrototypePadStart;\n    if (value !== undefined) {\n      for (let i = 0; i < output.length; i++) {\n        if (typeof value[i] !== 'number' && typeof value[i] !== 'bigint') {\n          order = StringPrototypePadEnd;\n          break;\n        }\n      }\n    }\n    // Each iteration creates a single line of grouped entries.\n    for (let i = 0; i < outputLength; i += columns) {\n      // The last lines may contain less entries than columns.\n      const max = MathMin(i + columns, outputLength);\n      let str = '';\n      let j = i;\n      for (; j < max - 1; j++) {\n        // Calculate extra color padding in case it's active. This has to be\n        // done line by line as some lines might contain more colors than\n        // others.\n        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];\n        str += order(`${output[j]}, `, padding, ' ');\n      }\n      if (order === StringPrototypePadStart) {\n        const padding = maxLineLength[j - i] +\n                        output[j].length -\n                        dataLen[j] -\n                        separatorSpace;\n        str += StringPrototypePadStart(output[j], padding, ' ');\n      } else {\n        str += output[j];\n      }\n      ArrayPrototypePush(tmp, str);\n    }\n    if (ctx.maxArrayLength < output.length) {\n      ArrayPrototypePush(tmp, output[outputLength]);\n    }\n    output = tmp;\n  }\n  return output;\n}\n\nfunction handleMaxCallStackSize(ctx, err, constructorName, indentationLvl) {\n  if (isStackOverflowError(err)) {\n    ctx.seen.pop();\n    ctx.indentationLvl = indentationLvl;\n    return ctx.stylize(\n      `[${constructorName}: Inspection interrupted ` +\n        'prematurely. Maximum call stack size exceeded.]',\n      'special',\n    );\n  }\n  /* c8 ignore next */\n  assert.fail(err.stack);\n}\n\nfunction addNumericSeparator(integerString) {\n  let result = '';\n  let i = integerString.length;\n  const start = StringPrototypeStartsWith(integerString, '-') ? 1 : 0;\n  for (; i >= start + 4; i -= 3) {\n    result = `_${StringPrototypeSlice(integerString, i - 3, i)}${result}`;\n  }\n  return i === integerString.length ?\n    integerString :\n    `${StringPrototypeSlice(integerString, 0, i)}${result}`;\n}\n\nfunction addNumericSeparatorEnd(integerString) {\n  let result = '';\n  let i = 0;\n  for (; i < integerString.length - 3; i += 3) {\n    result += `${StringPrototypeSlice(integerString, i, i + 3)}_`;\n  }\n  return i === 0 ?\n    integerString :\n    `${result}${StringPrototypeSlice(integerString, i)}`;\n}\n\nconst remainingText = (remaining) => `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\n\nfunction formatNumber(fn, number, numericSeparator) {\n  if (!numericSeparator) {\n    // Format -0 as '-0'. Checking `number === -0` won't distinguish 0 from -0.\n    if (ObjectIs(number, -0)) {\n      return fn('-0', 'number');\n    }\n    return fn(`${number}`, 'number');\n  }\n  const integer = MathTrunc(number);\n  const string = String(integer);\n  if (integer === number) {\n    if (!NumberIsFinite(number) || StringPrototypeIncludes(string, 'e')) {\n      return fn(string, 'number');\n    }\n    return fn(`${addNumericSeparator(string)}`, 'number');\n  }\n  if (NumberIsNaN(number)) {\n    return fn(string, 'number');\n  }\n  return fn(`${\n    addNumericSeparator(string)\n  }.${\n    addNumericSeparatorEnd(\n      StringPrototypeSlice(String(number), string.length + 1),\n    )\n  }`, 'number');\n}\n\nfunction formatBigInt(fn, bigint, numericSeparator) {\n  const string = String(bigint);\n  if (!numericSeparator) {\n    return fn(`${string}n`, 'bigint');\n  }\n  return fn(`${addNumericSeparator(string)}n`, 'bigint');\n}\n\nfunction formatPrimitive(fn, value, ctx) {\n  if (typeof value === 'string') {\n    let trailer = '';\n    if (value.length > ctx.maxStringLength) {\n      const remaining = value.length - ctx.maxStringLength;\n      value = StringPrototypeSlice(value, 0, ctx.maxStringLength);\n      trailer = `... ${remaining} more character${remaining > 1 ? 's' : ''}`;\n    }\n    if (ctx.compact !== true &&\n        // We do not support handling unicode characters width with\n        // the readline getStringWidth function as there are\n        // performance implications.\n        value.length > kMinLineLength &&\n        value.length > ctx.breakLength - ctx.indentationLvl - 4) {\n      return ArrayPrototypeJoin(\n        ArrayPrototypeMap(\n          RegExpPrototypeSymbolSplit(/(?<=\\n)/, value),\n          (line) => fn(strEscape(line), 'string'),\n        ),\n        ` +\\n${StringPrototypeRepeat(' ', ctx.indentationLvl + 2)}`,\n      ) + trailer;\n    }\n    return fn(strEscape(value), 'string') + trailer;\n  }\n  if (typeof value === 'number')\n    return formatNumber(fn, value, ctx.numericSeparator);\n  if (typeof value === 'bigint')\n    return formatBigInt(fn, value, ctx.numericSeparator);\n  if (typeof value === 'boolean')\n    return fn(`${value}`, 'boolean');\n  if (typeof value === 'undefined')\n    return fn('undefined', 'undefined');\n  // es6 symbol primitive\n  return fn(SymbolPrototypeToString(value), 'symbol');\n}\n\nfunction formatNamespaceObject(keys, ctx, value, recurseTimes) {\n  const output = new Array(keys.length);\n  for (let i = 0; i < keys.length; i++) {\n    try {\n      output[i] = formatProperty(ctx, value, recurseTimes, keys[i],\n                                 kObjectType);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError');\n      // Use the existing functionality. This makes sure the indentation and\n      // line breaks are always correct. Otherwise it is very difficult to keep\n      // this aligned, even though this is a hacky way of dealing with this.\n      const tmp = { [keys[i]]: '' };\n      output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);\n      const pos = StringPrototypeLastIndexOf(output[i], ' ');\n      // We have to find the last whitespace and have to replace that value as\n      // it will be visualized as a regular string.\n      output[i] = StringPrototypeSlice(output[i], 0, pos + 1) +\n                  ctx.stylize('<uninitialized>', 'special');\n    }\n  }\n  // Reset the keys to an empty array. This prevents duplicated inspection.\n  keys.length = 0;\n  return output;\n}\n\n// The array is sparse and/or has extra keys\nfunction formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {\n  const keys = ObjectKeys(value);\n  let index = i;\n  for (; i < keys.length && output.length < maxLength; i++) {\n    const key = keys[i];\n    const tmp = +key;\n    // Arrays can only have up to 2^32 - 1 entries\n    if (tmp > 2 ** 32 - 2) {\n      break;\n    }\n    if (`${index}` !== key) {\n      if (RegExpPrototypeExec(numberRegExp, key) === null) {\n        break;\n      }\n      const emptyItems = tmp - index;\n      const ending = emptyItems > 1 ? 's' : '';\n      const message = `<${emptyItems} empty item${ending}>`;\n      ArrayPrototypePush(output, ctx.stylize(message, 'undefined'));\n      index = tmp;\n      if (output.length === maxLength) {\n        break;\n      }\n    }\n    ArrayPrototypePush(output, formatProperty(ctx, value, recurseTimes, key, kArrayType));\n    index++;\n  }\n  const remaining = value.length - index;\n  if (output.length !== maxLength) {\n    if (remaining > 0) {\n      const ending = remaining > 1 ? 's' : '';\n      const message = `<${remaining} empty item${ending}>`;\n      ArrayPrototypePush(output, ctx.stylize(message, 'undefined'));\n    }\n  } else if (remaining > 0) {\n    ArrayPrototypePush(output, remainingText(remaining));\n  }\n  return output;\n}\n\nfunction formatArrayBuffer(ctx, value) {\n  let buffer;\n  try {\n    buffer = new Uint8Array(value);\n  } catch {\n    return [ctx.stylize('(detached)', 'special')];\n  }\n  if (hexSlice === undefined)\n    hexSlice = uncurryThis(require('buffer').Buffer.prototype.hexSlice);\n  let str = StringPrototypeTrim(RegExpPrototypeSymbolReplace(\n    /(.{2})/g,\n    hexSlice(buffer, 0, MathMin(ctx.maxArrayLength, buffer.length)),\n    '$1 ',\n  ));\n  const remaining = buffer.length - ctx.maxArrayLength;\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  return [`${ctx.stylize('[Uint8Contents]', 'special')}: <${str}>`];\n}\n\nfunction formatArray(ctx, value, recurseTimes) {\n  const valLen = value.length;\n  const len = MathMin(MathMax(0, ctx.maxArrayLength), valLen);\n\n  const remaining = valLen - len;\n  const output = [];\n  for (let i = 0; i < len; i++) {\n    // Special handle sparse arrays.\n    if (!ObjectPrototypeHasOwnProperty(value, i)) {\n      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);\n    }\n    ArrayPrototypePush(output, formatProperty(ctx, value, recurseTimes, i, kArrayType));\n  }\n  if (remaining > 0) {\n    ArrayPrototypePush(output, remainingText(remaining));\n  }\n  return output;\n}\n\nfunction formatTypedArray(value, length, ctx, ignored, recurseTimes) {\n  const maxLength = MathMin(MathMax(0, ctx.maxArrayLength), length);\n  const remaining = value.length - maxLength;\n  const output = new Array(maxLength);\n  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ?\n    formatNumber :\n    formatBigInt;\n  for (let i = 0; i < maxLength; ++i) {\n    output[i] = elementFormatter(ctx.stylize, value[i], ctx.numericSeparator);\n  }\n  if (remaining > 0) {\n    output[maxLength] = remainingText(remaining);\n  }\n  if (ctx.showHidden) {\n    // .buffer goes last, it's not a primitive like the others.\n    // All besides `BYTES_PER_ELEMENT` are actually getters.\n    ctx.indentationLvl += 2;\n    for (const key of [\n      'BYTES_PER_ELEMENT',\n      'length',\n      'byteLength',\n      'byteOffset',\n      'buffer',\n    ]) {\n      const str = formatValue(ctx, value[key], recurseTimes, true);\n      ArrayPrototypePush(output, `[${key}]: ${str}`);\n    }\n    ctx.indentationLvl -= 2;\n  }\n  return output;\n}\n\nfunction formatSet(value, ctx, ignored, recurseTimes) {\n  const length = value.size;\n  const maxLength = MathMin(MathMax(0, ctx.maxArrayLength), length);\n  const remaining = length - maxLength;\n  const output = [];\n  ctx.indentationLvl += 2;\n  let i = 0;\n  for (const v of value) {\n    if (i >= maxLength) break;\n    ArrayPrototypePush(output, formatValue(ctx, v, recurseTimes));\n    i++;\n  }\n  if (remaining > 0) {\n    ArrayPrototypePush(output, remainingText(remaining));\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatMap(value, ctx, ignored, recurseTimes) {\n  const length = value.size;\n  const maxLength = MathMin(MathMax(0, ctx.maxArrayLength), length);\n  const remaining = length - maxLength;\n  const output = [];\n  ctx.indentationLvl += 2;\n  let i = 0;\n  for (const { 0: k, 1: v } of value) {\n    if (i >= maxLength) break;\n    ArrayPrototypePush(\n      output,\n      `${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`,\n    );\n    i++;\n  }\n  if (remaining > 0) {\n    ArrayPrototypePush(output, remainingText(remaining));\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatSetIterInner(ctx, recurseTimes, entries, state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength, 0);\n  const maxLength = MathMin(maxArrayLength, entries.length);\n  const output = new Array(maxLength);\n  ctx.indentationLvl += 2;\n  for (let i = 0; i < maxLength; i++) {\n    output[i] = formatValue(ctx, entries[i], recurseTimes);\n  }\n  ctx.indentationLvl -= 2;\n  if (state === kWeak && !ctx.sorted) {\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist, we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    ArrayPrototypeSort(output);\n  }\n  const remaining = entries.length - maxLength;\n  if (remaining > 0) {\n    ArrayPrototypePush(output, remainingText(remaining));\n  }\n  return output;\n}\n\nfunction formatMapIterInner(ctx, recurseTimes, entries, state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength, 0);\n  // Entries exist as [key1, val1, key2, val2, ...]\n  const len = entries.length / 2;\n  const remaining = len - maxArrayLength;\n  const maxLength = MathMin(maxArrayLength, len);\n  const output = new Array(maxLength);\n  let i = 0;\n  ctx.indentationLvl += 2;\n  if (state === kWeak) {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      output[i] =\n        `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;\n    }\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist, we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    if (!ctx.sorted)\n      ArrayPrototypeSort(output);\n  } else {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      const res = [\n        formatValue(ctx, entries[pos], recurseTimes),\n        formatValue(ctx, entries[pos + 1], recurseTimes),\n      ];\n      output[i] = reduceToSingleString(\n        ctx, res, '', ['[', ']'], kArrayExtrasType, recurseTimes);\n    }\n  }\n  ctx.indentationLvl -= 2;\n  if (remaining > 0) {\n    ArrayPrototypePush(output, remainingText(remaining));\n  }\n  return output;\n}\n\nfunction formatWeakCollection(ctx) {\n  return [ctx.stylize('<items unknown>', 'special')];\n}\n\nfunction formatWeakSet(ctx, value, recurseTimes) {\n  const entries = previewEntries(value);\n  return formatSetIterInner(ctx, recurseTimes, entries, kWeak);\n}\n\nfunction formatWeakMap(ctx, value, recurseTimes) {\n  const entries = previewEntries(value);\n  return formatMapIterInner(ctx, recurseTimes, entries, kWeak);\n}\n\nfunction formatIterator(braces, ctx, value, recurseTimes) {\n  const { 0: entries, 1: isKeyValue } = previewEntries(value, true);\n  if (isKeyValue) {\n    // Mark entry iterators as such.\n    braces[0] = RegExpPrototypeSymbolReplace(/ Iterator] {$/, braces[0], ' Entries] {');\n    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);\n  }\n\n  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);\n}\n\nfunction formatPromise(ctx, value, recurseTimes) {\n  let output;\n  const { 0: state, 1: result } = getPromiseDetails(value);\n  if (state === kPending) {\n    output = [ctx.stylize('<pending>', 'special')];\n  } else {\n    ctx.indentationLvl += 2;\n    const str = formatValue(ctx, result, recurseTimes);\n    ctx.indentationLvl -= 2;\n    output = [\n      state === kRejected ?\n        `${ctx.stylize('<rejected>', 'special')} ${str}` :\n        str,\n    ];\n  }\n  return output;\n}\n\nfunction formatProperty(ctx, value, recurseTimes, key, type, desc,\n                        original = value) {\n  let name, str;\n  let extra = ' ';\n  desc = desc || ObjectGetOwnPropertyDescriptor(value, key) ||\n    { value: value[key], enumerable: true };\n  if (desc.value !== undefined) {\n    const diff = (ctx.compact !== true || type !== kObjectType) ? 2 : 3;\n    ctx.indentationLvl += diff;\n    str = formatValue(ctx, desc.value, recurseTimes);\n    if (diff === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {\n      extra = `\\n${StringPrototypeRepeat(' ', ctx.indentationLvl)}`;\n    }\n    ctx.indentationLvl -= diff;\n  } else if (desc.get !== undefined) {\n    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';\n    const s = ctx.stylize;\n    const sp = 'special';\n    if (ctx.getters && (ctx.getters === true ||\n          (ctx.getters === 'get' && desc.set === undefined) ||\n          (ctx.getters === 'set' && desc.set !== undefined))) {\n      try {\n        const tmp = FunctionPrototypeCall(desc.get, original);\n        ctx.indentationLvl += 2;\n        if (tmp === null) {\n          str = `${s(`[${label}:`, sp)} ${s('null', 'null')}${s(']', sp)}`;\n        } else if (typeof tmp === 'object') {\n          str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;\n        } else {\n          const primitive = formatPrimitive(s, tmp, ctx);\n          str = `${s(`[${label}:`, sp)} ${primitive}${s(']', sp)}`;\n        }\n        ctx.indentationLvl -= 2;\n      } catch (err) {\n        const message = `<Inspection threw (${err.message})>`;\n        str = `${s(`[${label}:`, sp)} ${message}${s(']', sp)}`;\n      }\n    } else {\n      str = ctx.stylize(`[${label}]`, sp);\n    }\n  } else if (desc.set !== undefined) {\n    str = ctx.stylize('[Setter]', 'special');\n  } else {\n    str = ctx.stylize('undefined', 'undefined');\n  }\n  if (type === kArrayType) {\n    return str;\n  }\n  if (typeof key === 'symbol') {\n    const tmp = RegExpPrototypeSymbolReplace(\n      strEscapeSequencesReplacer,\n      SymbolPrototypeToString(key),\n      escapeFn,\n    );\n    name = `[${ctx.stylize(tmp, 'symbol')}]`;\n  } else if (key === '__proto__') {\n    name = \"['__proto__']\";\n  } else if (desc.enumerable === false) {\n    const tmp = RegExpPrototypeSymbolReplace(\n      strEscapeSequencesReplacer,\n      key,\n      escapeFn,\n    );\n    name = `[${tmp}]`;\n  } else if (RegExpPrototypeExec(keyStrRegExp, key) !== null) {\n    name = ctx.stylize(key, 'name');\n  } else {\n    name = ctx.stylize(strEscape(key), 'string');\n  }\n  return `${name}:${extra}${str}`;\n}\n\nfunction isBelowBreakLength(ctx, output, start, base) {\n  // Each entry is separated by at least a comma. Thus, we start with a total\n  // length of at least `output.length`. In addition, some cases have a\n  // whitespace in-between each other that is added to the total as well.\n  // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\n  // function. Check the performance overhead and make it an opt-in in case it's\n  // significant.\n  let totalLength = output.length + start;\n  if (totalLength + output.length > ctx.breakLength)\n    return false;\n  for (let i = 0; i < output.length; i++) {\n    if (ctx.colors) {\n      totalLength += removeColors(output[i]).length;\n    } else {\n      totalLength += output[i].length;\n    }\n    if (totalLength > ctx.breakLength) {\n      return false;\n    }\n  }\n  // Do not line up properties on the same line if `base` contains line breaks.\n  return base === '' || !StringPrototypeIncludes(base, '\\n');\n}\n\nfunction reduceToSingleString(\n  ctx, output, base, braces, extrasType, recurseTimes, value) {\n  if (ctx.compact !== true) {\n    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {\n      // Memorize the original output length. In case the output is grouped,\n      // prevent lining up the entries on a single line.\n      const entries = output.length;\n      // Group array elements together if the array contains at least six\n      // separate entries.\n      if (extrasType === kArrayExtrasType && entries > 6) {\n        output = groupArrayElements(ctx, output, value);\n      }\n      // `ctx.currentDepth` is set to the most inner depth of the currently\n      // inspected object part while `recurseTimes` is the actual current depth\n      // that is inspected.\n      //\n      // Example:\n      //\n      // const a = { first: [ 1, 2, 3 ], second: { inner: [ 1, 2, 3 ] } }\n      //\n      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max\n      // depth of 1.\n      //\n      // Consolidate all entries of the local most inner depth up to\n      // `ctx.compact`, as long as the properties are smaller than\n      // `ctx.breakLength`.\n      if (ctx.currentDepth - recurseTimes < ctx.compact &&\n          entries === output.length) {\n        // Line up all entries on a single line in case the entries do not\n        // exceed `breakLength`. Add 10 as constant to start next to all other\n        // factors that may reduce `breakLength`.\n        const start = output.length + ctx.indentationLvl +\n                      braces[0].length + base.length + 10;\n        if (isBelowBreakLength(ctx, output, start, base)) {\n          const joinedOutput = join(output, ', ');\n          if (!StringPrototypeIncludes(joinedOutput, '\\n')) {\n            return `${base ? `${base} ` : ''}${braces[0]} ${joinedOutput}` +\n              ` ${braces[1]}`;\n          }\n        }\n      }\n    }\n    // Line up each entry on an individual line.\n    const indentation = `\\n${StringPrototypeRepeat(' ', ctx.indentationLvl)}`;\n    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` +\n      `${join(output, `,${indentation}  `)}${indentation}${braces[1]}`;\n  }\n  // Line up all entries on a single line in case the entries do not exceed\n  // `breakLength`.\n  if (isBelowBreakLength(ctx, output, 0, base)) {\n    return `${braces[0]}${base ? ` ${base}` : ''} ${join(output, ', ')} ` +\n      braces[1];\n  }\n  const indentation = StringPrototypeRepeat(' ', ctx.indentationLvl);\n  // If the opening \"brace\" is too large, like in the case of \"Set {\",\n  // we need to force the first item to be on the next line or the\n  // items will not line up correctly.\n  const ln = base === '' && braces[0].length === 1 ?\n    ' ' : `${base ? ` ${base}` : ''}\\n${indentation}  `;\n  // Line up each entry on an individual line.\n  return `${braces[0]}${ln}${join(output, `,\\n${indentation}  `)} ${braces[1]}`;\n}\n\nfunction hasBuiltInToString(value) {\n  // Prevent triggering proxy traps.\n  const getFullProxy = false;\n  const proxyTarget = getProxyDetails(value, getFullProxy);\n  if (proxyTarget !== undefined) {\n    if (proxyTarget === null) {\n      return true;\n    }\n    value = proxyTarget;\n  }\n\n  // Count objects that have no `toString` function as built-in.\n  if (typeof value.toString !== 'function') {\n    return true;\n  }\n\n  // The object has a own `toString` property. Thus it's not not a built-in one.\n  if (ObjectPrototypeHasOwnProperty(value, 'toString')) {\n    return false;\n  }\n\n  // Find the object that has the `toString` property as own property in the\n  // prototype chain.\n  let pointer = value;\n  do {\n    pointer = ObjectGetPrototypeOf(pointer);\n  } while (!ObjectPrototypeHasOwnProperty(pointer, 'toString'));\n\n  // Check closer if the object is a built-in.\n  const descriptor = ObjectGetOwnPropertyDescriptor(pointer, 'constructor');\n  return descriptor !== undefined &&\n    typeof descriptor.value === 'function' &&\n    builtInObjects.has(descriptor.value.name);\n}\n\nconst firstErrorLine = (error) => StringPrototypeSplit(error.message, '\\n', 1)[0];\nlet CIRCULAR_ERROR_MESSAGE;\nfunction tryStringify(arg) {\n  try {\n    return JSONStringify(arg);\n  } catch (err) {\n    // Populate the circular error message lazily\n    if (!CIRCULAR_ERROR_MESSAGE) {\n      try {\n        const a = {};\n        a.a = a;\n        JSONStringify(a);\n      } catch (circularError) {\n        CIRCULAR_ERROR_MESSAGE = firstErrorLine(circularError);\n      }\n    }\n    if (err.name === 'TypeError' &&\n        firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {\n      return '[Circular]';\n    }\n    throw err;\n  }\n}\n\nfunction format(...args) {\n  return formatWithOptionsInternal(undefined, args);\n}\n\nfunction formatWithOptions(inspectOptions, ...args) {\n  validateObject(inspectOptions, 'inspectOptions', kValidateObjectAllowArray);\n  return formatWithOptionsInternal(inspectOptions, args);\n}\n\nfunction formatNumberNoColor(number, options) {\n  return formatNumber(\n    stylizeNoColor,\n    number,\n    options?.numericSeparator ?? inspectDefaultOptions.numericSeparator,\n  );\n}\n\nfunction formatBigIntNoColor(bigint, options) {\n  return formatBigInt(\n    stylizeNoColor,\n    bigint,\n    options?.numericSeparator ?? inspectDefaultOptions.numericSeparator,\n  );\n}\n\nfunction formatWithOptionsInternal(inspectOptions, args) {\n  const first = args[0];\n  let a = 0;\n  let str = '';\n  let join = '';\n\n  if (typeof first === 'string') {\n    if (args.length === 1) {\n      return first;\n    }\n    let tempStr;\n    let lastPos = 0;\n\n    for (let i = 0; i < first.length - 1; i++) {\n      if (StringPrototypeCharCodeAt(first, i) === 37) { // '%'\n        const nextChar = StringPrototypeCharCodeAt(first, ++i);\n        if (a + 1 !== args.length) {\n          switch (nextChar) {\n            case 115: { // 's'\n              const tempArg = args[++a];\n              if (typeof tempArg === 'number') {\n                tempStr = formatNumberNoColor(tempArg, inspectOptions);\n              } else if (typeof tempArg === 'bigint') {\n                tempStr = formatBigIntNoColor(tempArg, inspectOptions);\n              } else if (typeof tempArg !== 'object' ||\n                         tempArg === null ||\n                         !hasBuiltInToString(tempArg)) {\n                tempStr = String(tempArg);\n              } else {\n                tempStr = inspect(tempArg, {\n                  ...inspectOptions,\n                  compact: 3,\n                  colors: false,\n                  depth: 0,\n                });\n              }\n              break;\n            }\n            case 106: // 'j'\n              tempStr = tryStringify(args[++a]);\n              break;\n            case 100: { // 'd'\n              const tempNum = args[++a];\n              if (typeof tempNum === 'bigint') {\n                tempStr = formatBigIntNoColor(tempNum, inspectOptions);\n              } else if (typeof tempNum === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumberNoColor(Number(tempNum), inspectOptions);\n              }\n              break;\n            }\n            case 79: // 'O'\n              tempStr = inspect(args[++a], inspectOptions);\n              break;\n            case 111: // 'o'\n              tempStr = inspect(args[++a], {\n                ...inspectOptions,\n                showHidden: true,\n                showProxy: true,\n                depth: 4,\n              });\n              break;\n            case 105: { // 'i'\n              const tempInteger = args[++a];\n              if (typeof tempInteger === 'bigint') {\n                tempStr = formatBigIntNoColor(tempInteger, inspectOptions);\n              } else if (typeof tempInteger === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumberNoColor(\n                  NumberParseInt(tempInteger), inspectOptions);\n              }\n              break;\n            }\n            case 102: { // 'f'\n              const tempFloat = args[++a];\n              if (typeof tempFloat === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumberNoColor(\n                  NumberParseFloat(tempFloat), inspectOptions);\n              }\n              break;\n            }\n            case 99: // 'c'\n              a += 1;\n              tempStr = '';\n              break;\n            case 37: // '%'\n              str += StringPrototypeSlice(first, lastPos, i);\n              lastPos = i + 1;\n              continue;\n            default: // Any other character is not a correct placeholder\n              continue;\n          }\n          if (lastPos !== i - 1) {\n            str += StringPrototypeSlice(first, lastPos, i - 1);\n          }\n          str += tempStr;\n          lastPos = i + 1;\n        } else if (nextChar === 37) {\n          str += StringPrototypeSlice(first, lastPos, i);\n          lastPos = i + 1;\n        }\n      }\n    }\n    if (lastPos !== 0) {\n      a++;\n      join = ' ';\n      if (lastPos < first.length) {\n        str += StringPrototypeSlice(first, lastPos);\n      }\n    }\n  }\n\n  while (a < args.length) {\n    const value = args[a];\n    str += join;\n    str += typeof value !== 'string' ? inspect(value, inspectOptions) : value;\n    join = ' ';\n    a++;\n  }\n  return str;\n}\n\nfunction isZeroWidthCodePoint(code) {\n  return code <= 0x1F || // C0 control codes\n    (code >= 0x7F && code <= 0x9F) || // C1 control codes\n    (code >= 0x300 && code <= 0x36F) || // Combining Diacritical Marks\n    (code >= 0x200B && code <= 0x200F) || // Modifying Invisible Characters\n    // Combining Diacritical Marks for Symbols\n    (code >= 0x20D0 && code <= 0x20FF) ||\n    (code >= 0xFE00 && code <= 0xFE0F) || // Variation Selectors\n    (code >= 0xFE20 && code <= 0xFE2F) || // Combining Half Marks\n    (code >= 0xE0100 && code <= 0xE01EF); // Variation Selectors\n}\n\nif (internalBinding('config').hasIntl) {\n  const icu = internalBinding('icu');\n  // icu.getStringWidth(string, ambiguousAsFullWidth, expandEmojiSequence)\n  // Defaults: ambiguousAsFullWidth = false; expandEmojiSequence = true;\n  // TODO(BridgeAR): Expose the options to the user. That is probably the\n  // best thing possible at the moment, since it's difficult to know what\n  // the receiving end supports.\n  getStringWidth = function getStringWidth(str, removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars) {\n      str = stripVTControlCharacters(str);\n    }\n    for (let i = 0; i < str.length; i++) {\n      // Try to avoid calling into C++ by first handling the ASCII portion of\n      // the string. If it is fully ASCII, we skip the C++ part.\n      const code = str.charCodeAt(i);\n      if (code >= 127) {\n        width += icu.getStringWidth(StringPrototypeNormalize(StringPrototypeSlice(str, i), 'NFC'));\n        break;\n      }\n      width += code >= 32 ? 1 : 0;\n    }\n    return width;\n  };\n} else {\n  /**\n   * Returns the number of columns required to display the given string.\n   */\n  getStringWidth = function getStringWidth(str, removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    str = StringPrototypeNormalize(str, 'NFC');\n    for (const char of new SafeStringIterator(str)) {\n      const code = StringPrototypeCodePointAt(char, 0);\n      if (isFullWidthCodePoint(code)) {\n        width += 2;\n      } else if (!isZeroWidthCodePoint(code)) {\n        width++;\n      }\n    }\n\n    return width;\n  };\n\n  /**\n   * Returns true if the character represented by a given\n   * Unicode code point is full-width. Otherwise returns false.\n   */\n  const isFullWidthCodePoint = (code) => {\n    // Code points are partially derived from:\n    // https://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n    return code >= 0x1100 && (\n      code <= 0x115f ||  // Hangul Jamo\n      code === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n      code === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n      (code >= 0x2e80 && code <= 0x3247 && code !== 0x303f) ||\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n      (code >= 0x3250 && code <= 0x4dbf) ||\n      // CJK Unified Ideographs .. Yi Radicals\n      (code >= 0x4e00 && code <= 0xa4c6) ||\n      // Hangul Jamo Extended-A\n      (code >= 0xa960 && code <= 0xa97c) ||\n      // Hangul Syllables\n      (code >= 0xac00 && code <= 0xd7a3) ||\n      // CJK Compatibility Ideographs\n      (code >= 0xf900 && code <= 0xfaff) ||\n      // Vertical Forms\n      (code >= 0xfe10 && code <= 0xfe19) ||\n      // CJK Compatibility Forms .. Small Form Variants\n      (code >= 0xfe30 && code <= 0xfe6b) ||\n      // Halfwidth and Fullwidth Forms\n      (code >= 0xff01 && code <= 0xff60) ||\n      (code >= 0xffe0 && code <= 0xffe6) ||\n      // Kana Supplement\n      (code >= 0x1b000 && code <= 0x1b001) ||\n      // Enclosed Ideographic Supplement\n      (code >= 0x1f200 && code <= 0x1f251) ||\n      // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff\n      // Emoticons 0x1f600 - 0x1f64f\n      (code >= 0x1f300 && code <= 0x1f64f) ||\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n      (code >= 0x20000 && code <= 0x3fffd)\n    );\n  };\n\n}\n\n/**\n * Remove all VT control characters. Use to estimate displayed string width.\n */\nfunction stripVTControlCharacters(str) {\n  validateString(str, 'str');\n\n  return RegExpPrototypeSymbolReplace(ansi, str, '');\n}\n\nmodule.exports = {\n  identicalSequenceRange,\n  inspect,\n  inspectDefaultOptions,\n  format,\n  formatWithOptions,\n  getStringWidth,\n  stripVTControlCharacters,\n  isZeroWidthCodePoint,\n};\n"
    },
    "22": {
      "sourceCode": "'use strict';\n\nconst {\n  ObjectDefineProperty,\n  RegExp,\n  RegExpPrototypeExec,\n  SafeArrayIterator,\n  StringPrototypeToLowerCase,\n  StringPrototypeToUpperCase,\n} = primordials;\n\nconst { inspect, format, formatWithOptions } = require('internal/util/inspect');\n\n// `debugImpls` and `testEnabled` are deliberately not initialized so any call\n// to `debuglog()` before `initializeDebugEnv()` is called will throw.\nlet debugImpls;\nlet testEnabled;\n\n\n// `debugEnv` is initial value of process.env.NODE_DEBUG\nfunction initializeDebugEnv(debugEnv) {\n  debugImpls = { __proto__: null };\n  if (debugEnv) {\n    // This is run before any user code, it's OK not to use primordials.\n    debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n      .replaceAll('*', '.*')\n      .replaceAll(',', '$|^');\n    const debugEnvRegex = new RegExp(`^${debugEnv}$`, 'i');\n    testEnabled = (str) => RegExpPrototypeExec(debugEnvRegex, str) !== null;\n  } else {\n    testEnabled = () => false;\n  }\n}\n\n// Emits warning when user sets\n// NODE_DEBUG=http or NODE_DEBUG=http2.\nfunction emitWarningIfNeeded(set) {\n  if ('HTTP' === set || 'HTTP2' === set) {\n    process.emitWarning('Setting the NODE_DEBUG environment variable ' +\n      'to \\'' + StringPrototypeToLowerCase(set) + '\\' can expose sensitive ' +\n      'data (such as passwords, tokens and authentication headers) ' +\n      'in the resulting log.');\n  }\n}\n\nconst noop = () => {};\n\nlet utilColors;\nfunction lazyUtilColors() {\n  utilColors ??= require('internal/util/colors');\n  return utilColors;\n}\n\nfunction debuglogImpl(enabled, set) {\n  if (debugImpls[set] === undefined) {\n    if (enabled) {\n      const pid = process.pid;\n      emitWarningIfNeeded(set);\n      debugImpls[set] = function debug(...args) {\n        const colors = lazyUtilColors().shouldColorize(process.stderr);\n        const msg = formatWithOptions({ colors }, ...args);\n        const coloredPID = inspect(pid, { colors });\n        process.stderr.write(format('%s %s: %s\\n', set, coloredPID, msg));\n      };\n    } else {\n      debugImpls[set] = noop;\n    }\n  }\n  return debugImpls[set];\n}\n\n// debuglogImpl depends on process.pid and process.env.NODE_DEBUG,\n// so it needs to be called lazily in top scopes of internal modules\n// that may be loaded before these run time states are allowed to\n// be accessed.\nfunction debuglog(set, cb) {\n  function init() {\n    set = StringPrototypeToUpperCase(set);\n    enabled = testEnabled(set);\n  }\n  let debug = (...args) => {\n    init();\n    // Only invokes debuglogImpl() when the debug function is\n    // called for the first time.\n    debug = debuglogImpl(enabled, set);\n    if (typeof cb === 'function')\n      cb(debug);\n    switch (args.length) {\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0], args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  let enabled;\n  let test = () => {\n    init();\n    test = () => enabled;\n    return enabled;\n  };\n  const logger = (...args) => {\n    switch (args.length) {\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0], args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  ObjectDefineProperty(logger, 'enabled', {\n    __proto__: null,\n    get() {\n      return test();\n    },\n    configurable: true,\n    enumerable: true,\n  });\n  return logger;\n}\n\nmodule.exports = {\n  debuglog,\n  initializeDebugEnv,\n};\n"
    },
    "23": {
      "sourceCode": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeJoin,\n  ArrayPrototypePop,\n  ArrayPrototypePush,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSplice,\n  ArrayPrototypeUnshift,\n  Boolean,\n  Error,\n  ErrorCaptureStackTrace,\n  FunctionPrototypeBind,\n  FunctionPrototypeCall,\n  NumberMAX_SAFE_INTEGER,\n  ObjectDefineProperty,\n  ObjectDefineProperties,\n  ObjectGetPrototypeOf,\n  ObjectSetPrototypeOf,\n  Promise,\n  PromiseReject,\n  PromiseResolve,\n  ReflectApply,\n  ReflectOwnKeys,\n  String,\n  StringPrototypeSplit,\n  Symbol,\n  SymbolFor,\n  SymbolAsyncIterator,\n  SymbolDispose,\n} = primordials;\nconst kRejection = SymbolFor('nodejs.rejection');\n\nconst { kEmptyObject } = require('internal/util');\n\nconst {\n  inspect,\n  identicalSequenceRange,\n} = require('internal/util/inspect');\n\nlet spliceOne;\nlet FixedQueue;\nlet kFirstEventParam;\nlet kResistStopPropagation;\n\nconst {\n  AbortError,\n  kEnhanceStackBeforeInspector,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_THIS,\n    ERR_UNHANDLED_ERROR,\n  },\n  genericNodeError,\n} = require('internal/errors');\n\nconst {\n  validateInteger,\n  validateAbortSignal,\n  validateBoolean,\n  validateFunction,\n  validateNumber,\n  validateString,\n} = require('internal/validators');\n\nconst kCapture = Symbol('kCapture');\nconst kErrorMonitor = Symbol('events.errorMonitor');\nconst kShapeMode = Symbol('shapeMode');\nconst kMaxEventTargetListeners = Symbol('events.maxEventTargetListeners');\nconst kMaxEventTargetListenersWarned =\n  Symbol('events.maxEventTargetListenersWarned');\nconst kWatermarkData = SymbolFor('nodejs.watermarkData');\n\nlet EventEmitterAsyncResource;\n// The EventEmitterAsyncResource has to be initialized lazily because event.js\n// is loaded so early in the bootstrap process, before async_hooks is available.\n//\n// This implementation was adapted straight from addaleax's\n// eventemitter-asyncresource MIT-licensed userland module.\n// https://github.com/addaleax/eventemitter-asyncresource\nfunction lazyEventEmitterAsyncResource() {\n  if (EventEmitterAsyncResource === undefined) {\n    const {\n      AsyncResource,\n    } = require('async_hooks');\n\n    const kEventEmitter = Symbol('kEventEmitter');\n    const kAsyncResource = Symbol('kAsyncResource');\n    class EventEmitterReferencingAsyncResource extends AsyncResource {\n      /**\n       * @param {EventEmitter} ee\n       * @param {string} [type]\n       * @param {{\n       *   triggerAsyncId?: number,\n       *   requireManualDestroy?: boolean,\n       * }} [options]\n       */\n      constructor(ee, type, options) {\n        super(type, options);\n        this[kEventEmitter] = ee;\n      }\n\n      /**\n       * @type {EventEmitter}\n       */\n      get eventEmitter() {\n        if (this[kEventEmitter] === undefined)\n          throw new ERR_INVALID_THIS('EventEmitterReferencingAsyncResource');\n        return this[kEventEmitter];\n      }\n    }\n\n    EventEmitterAsyncResource =\n      class EventEmitterAsyncResource extends EventEmitter {\n        /**\n         * @param {{\n         *   name?: string,\n         *   triggerAsyncId?: number,\n         *   requireManualDestroy?: boolean,\n         * }} [options]\n         */\n        constructor(options = undefined) {\n          let name;\n          if (typeof options === 'string') {\n            name = options;\n            options = undefined;\n          } else {\n            if (new.target === EventEmitterAsyncResource) {\n              validateString(options?.name, 'options.name');\n            }\n            name = options?.name || new.target.name;\n          }\n          super(options);\n\n          this[kAsyncResource] =\n            new EventEmitterReferencingAsyncResource(this, name, options);\n        }\n\n        /**\n         * @param {symbol,string} event\n         * @param  {...any} args\n         * @returns {boolean}\n         */\n        emit(event, ...args) {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          const { asyncResource } = this;\n          ArrayPrototypeUnshift(args, super.emit, this, event);\n          return ReflectApply(asyncResource.runInAsyncScope, asyncResource,\n                              args);\n        }\n\n        /**\n         * @returns {void}\n         */\n        emitDestroy() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          this.asyncResource.emitDestroy();\n        }\n\n        /**\n         * @type {number}\n         */\n        get asyncId() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this.asyncResource.asyncId();\n        }\n\n        /**\n         * @type {number}\n         */\n        get triggerAsyncId() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this.asyncResource.triggerAsyncId();\n        }\n\n        /**\n         * @type {EventEmitterReferencingAsyncResource}\n         */\n        get asyncResource() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this[kAsyncResource];\n        }\n      };\n  }\n  return EventEmitterAsyncResource;\n}\n\n/**\n * Creates a new `EventEmitter` instance.\n * @param {{ captureRejections?: boolean; }} [opts]\n * @constructs {EventEmitter}\n */\nfunction EventEmitter(opts) {\n  EventEmitter.init.call(this, opts);\n}\nmodule.exports = EventEmitter;\nmodule.exports.addAbortListener = addAbortListener;\nmodule.exports.once = once;\nmodule.exports.on = on;\nmodule.exports.getEventListeners = getEventListeners;\nmodule.exports.getMaxListeners = getMaxListeners;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.captureRejectionSymbol = kRejection;\nObjectDefineProperty(EventEmitter, 'captureRejections', {\n  __proto__: null,\n  get() {\n    return EventEmitter.prototype[kCapture];\n  },\n  set(value) {\n    validateBoolean(value, 'EventEmitter.captureRejections');\n\n    EventEmitter.prototype[kCapture] = value;\n  },\n  enumerable: true,\n});\n\nObjectDefineProperty(EventEmitter, 'EventEmitterAsyncResource', {\n  __proto__: null,\n  enumerable: true,\n  get: lazyEventEmitterAsyncResource,\n  set: undefined,\n  configurable: true,\n});\n\nEventEmitter.errorMonitor = kErrorMonitor;\n\n// The default for captureRejections is false\nObjectDefineProperty(EventEmitter.prototype, kCapture, {\n  __proto__: null,\n  value: false,\n  writable: true,\n  enumerable: false,\n});\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nlet defaultMaxListeners = 10;\nlet isEventTarget;\n\nfunction checkListener(listener) {\n  validateFunction(listener, 'listener');\n}\n\nObjectDefineProperty(EventEmitter, 'defaultMaxListeners', {\n  __proto__: null,\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    validateNumber(arg, 'defaultMaxListeners', 0);\n    defaultMaxListeners = arg;\n  },\n});\n\nObjectDefineProperties(EventEmitter, {\n  kMaxEventTargetListeners: {\n    __proto__: null,\n    value: kMaxEventTargetListeners,\n    enumerable: false,\n    configurable: false,\n    writable: false,\n  },\n  kMaxEventTargetListenersWarned: {\n    __proto__: null,\n    value: kMaxEventTargetListenersWarned,\n    enumerable: false,\n    configurable: false,\n    writable: false,\n  },\n});\n\n/**\n * Sets the max listeners.\n * @param {number} n\n * @param {EventTarget[] | EventEmitter[]} [eventTargets]\n * @returns {void}\n */\nEventEmitter.setMaxListeners =\n  function(n = defaultMaxListeners, ...eventTargets) {\n    validateNumber(n, 'setMaxListeners', 0);\n    if (eventTargets.length === 0) {\n      defaultMaxListeners = n;\n    } else {\n      if (isEventTarget === undefined)\n        isEventTarget = require('internal/event_target').isEventTarget;\n\n      for (let i = 0; i < eventTargets.length; i++) {\n        const target = eventTargets[i];\n        if (isEventTarget(target)) {\n          target[kMaxEventTargetListeners] = n;\n          target[kMaxEventTargetListenersWarned] = false;\n        } else if (typeof target.setMaxListeners === 'function') {\n          target.setMaxListeners(n);\n        } else {\n          throw new ERR_INVALID_ARG_TYPE(\n            'eventTargets',\n            ['EventEmitter', 'EventTarget'],\n            target);\n        }\n      }\n    }\n  };\n\n// If you're updating this function definition, please also update any\n// re-definitions, such as the one in the Domain module (lib/domain.js).\nEventEmitter.init = function(opts) {\n\n  if (this._events === undefined ||\n      this._events === ObjectGetPrototypeOf(this)._events) {\n    this._events = { __proto__: null };\n    this._eventsCount = 0;\n    this[kShapeMode] = false;\n  } else {\n    this[kShapeMode] = true;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n\n\n  if (opts?.captureRejections) {\n    validateBoolean(opts.captureRejections, 'options.captureRejections');\n    this[kCapture] = Boolean(opts.captureRejections);\n  } else {\n    // Assigning the kCapture property directly saves an expensive\n    // prototype lookup in a very sensitive hot path.\n    this[kCapture] = EventEmitter.prototype[kCapture];\n  }\n};\n\nfunction addCatch(that, promise, type, args) {\n  if (!that[kCapture]) {\n    return;\n  }\n\n  // Handle Promises/A+ spec, then could be a getter\n  // that throws on second use.\n  try {\n    const then = promise.then;\n\n    if (typeof then === 'function') {\n      then.call(promise, undefined, function(err) {\n        // The callback is called with nextTick to avoid a follow-up\n        // rejection from this promise.\n        process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args);\n      });\n    }\n  } catch (err) {\n    that.emit('error', err);\n  }\n}\n\nfunction emitUnhandledRejectionOrErr(ee, err, type, args) {\n  if (typeof ee[kRejection] === 'function') {\n    ee[kRejection](err, type, ...args);\n  } else {\n    // We have to disable the capture rejections mechanism, otherwise\n    // we might end up in an infinite loop.\n    const prev = ee[kCapture];\n\n    // If the error handler throws, it is not catchable and it\n    // will end up in 'uncaughtException'. We restore the previous\n    // value of kCapture in case the uncaughtException is present\n    // and the exception is handled.\n    try {\n      ee[kCapture] = false;\n      ee.emit('error', err);\n    } finally {\n      ee[kCapture] = prev;\n    }\n  }\n}\n\n/**\n * Increases the max listeners of the event emitter.\n * @param {number} n\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  validateNumber(n, 'setMaxListeners', 0);\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\n/**\n * Returns the current max listener value for the event emitter.\n * @returns {number}\n */\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nfunction enhanceStackTrace(err, own) {\n  let ctorInfo = '';\n  try {\n    const { name } = this.constructor;\n    if (name !== 'EventEmitter')\n      ctorInfo = ` on ${name} instance`;\n  } catch {\n    // Continue regardless of error.\n  }\n  const sep = `\\nEmitted 'error' event${ctorInfo} at:\\n`;\n\n  const errStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(err.stack, '\\n'), 1);\n  const ownStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(own.stack, '\\n'), 1);\n\n  const { len, offset } = identicalSequenceRange(ownStack, errStack);\n  if (len > 0) {\n    ArrayPrototypeSplice(ownStack, offset + 1, len - 2,\n                         '    [... lines matching original stack trace ...]');\n  }\n\n  return err.stack + sep + ArrayPrototypeJoin(ownStack, '\\n');\n}\n\n/**\n * Synchronously calls each of the listeners registered\n * for the event.\n * @param {string | symbol} type\n * @param {...any} [args]\n * @returns {boolean}\n */\nEventEmitter.prototype.emit = function emit(type, ...args) {\n  let doError = (type === 'error');\n\n  const events = this._events;\n  if (events !== undefined) {\n    if (doError && events[kErrorMonitor] !== undefined)\n      this.emit(kErrorMonitor, ...args);\n    doError = (doError && events.error === undefined);\n  } else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    let er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      try {\n        const capture = {};\n        ErrorCaptureStackTrace(capture, EventEmitter.prototype.emit);\n        ObjectDefineProperty(er, kEnhanceStackBeforeInspector, {\n          __proto__: null,\n          value: FunctionPrototypeBind(enhanceStackTrace, this, er, capture),\n          configurable: true,\n        });\n      } catch {\n        // Continue regardless of error.\n      }\n\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n\n    let stringifiedEr;\n    try {\n      stringifiedEr = inspect(er);\n    } catch {\n      stringifiedEr = er;\n    }\n\n    // At least give some kind of context to the user\n    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  const handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    const result = handler.apply(this, args);\n\n    // We check if result is undefined first because that\n    // is the most common case so we do not pay any perf\n    // penalty\n    if (result !== undefined && result !== null) {\n      addCatch(this, result, type, args);\n    }\n  } else {\n    const len = handler.length;\n    const listeners = arrayClone(handler);\n    for (let i = 0; i < len; ++i) {\n      const result = listeners[i].apply(this, args);\n\n      // We check if result is undefined first because that\n      // is the most common case so we do not pay any perf\n      // penalty.\n      // This code is duplicated because extracting it away\n      // would make it non-inlineable.\n      if (result !== undefined && result !== null) {\n        addCatch(this, result, type, args);\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  let m;\n  let events;\n  let existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = { __proto__: null };\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ?? listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      const w = genericNodeError(\n        `Possible EventEmitter memory leak detected. ${existing.length} ${String(type)} listeners ` +\n        `added to ${inspect(target, { depth: -1 })}. Use emitter.setMaxListeners() to increase limit`,\n        { name: 'MaxListenersExceededWarning', emitter: target, type: type, count: existing.length });\n      process.emitWarning(w);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Adds a listener to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n/**\n * Adds the `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  const state = { fired: false, wrapFn: undefined, target, type, listener };\n  const wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\n/**\n * Adds a one-time `listener` function to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n/**\n * Adds a one-time `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n/**\n * Removes the specified `listener` from the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      checkListener(listener);\n\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      const list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        this._eventsCount -= 1;\n\n        if (this[kShapeMode]) {\n          events[type] = undefined;\n        } else if (this._eventsCount === 0) {\n          this._events = { __proto__: null };\n        } else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        let position = -1;\n\n        for (let i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          if (spliceOne === undefined)\n            spliceOne = require('internal/util').spliceOne;\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n/**\n * Removes all listeners from the event emitter. (Only\n * removes listeners for a specific event name if specified\n * as `type`).\n * @param {string | symbol} [type]\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      // Not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = { __proto__: null };\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = { __proto__: null };\n          else\n            delete events[type];\n        }\n        this[kShapeMode] = false;\n        return this;\n      }\n\n      // Emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        for (const key of ReflectOwnKeys(events)) {\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = { __proto__: null };\n        this._eventsCount = 0;\n        this[kShapeMode] = false;\n        return this;\n      }\n\n      const listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  const events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  const evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener);\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\n/**\n * Returns a copy of the array of listeners and wrappers for\n * the event name specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\n/**\n * Returns the number of listeners listening to the event name\n * specified as `type`.\n * @deprecated since v3.2.0\n * @param {EventEmitter} emitter\n * @param {string | symbol} type\n * @returns {number}\n */\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  }\n  return FunctionPrototypeCall(listenerCount, emitter, type);\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\n/**\n * Returns the number of listeners listening to event name\n * specified as `type`.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {number}\n */\nfunction listenerCount(type, listener) {\n  const events = this._events;\n\n  if (events !== undefined) {\n    const evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      if (listener != null) {\n        return listener === evlistener || listener === evlistener.listener ? 1 : 0;\n      }\n\n      return 1;\n    } else if (evlistener !== undefined) {\n      if (listener != null) {\n        let matching = 0;\n\n        for (let i = 0, l = evlistener.length; i < l; i++) {\n          if (evlistener[i] === listener || evlistener[i].listener === listener) {\n            matching++;\n          }\n        }\n\n        return matching;\n      }\n\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Returns an array listing the events for which\n * the emitter has registered listeners.\n * @returns {any[]}\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr) {\n  // At least since V8 8.3, this implementation is faster than the previous\n  // which always used a simple for-loop\n  switch (arr.length) {\n    case 2: return [arr[0], arr[1]];\n    case 3: return [arr[0], arr[1], arr[2]];\n    case 4: return [arr[0], arr[1], arr[2], arr[3]];\n    case 5: return [arr[0], arr[1], arr[2], arr[3], arr[4]];\n    case 6: return [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]];\n  }\n  return ArrayPrototypeSlice(arr);\n}\n\nfunction unwrapListeners(arr) {\n  const ret = arrayClone(arr);\n  for (let i = 0; i < ret.length; ++i) {\n    const orig = ret[i].listener;\n    if (typeof orig === 'function')\n      ret[i] = orig;\n  }\n  return ret;\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {EventEmitter | EventTarget} emitterOrTarget\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nfunction getEventListeners(emitterOrTarget, type) {\n  // First check if EventEmitter\n  if (typeof emitterOrTarget.listeners === 'function') {\n    return emitterOrTarget.listeners(type);\n  }\n  // Require event target lazily to avoid always loading it\n  const { isEventTarget, kEvents } = require('internal/event_target');\n  if (isEventTarget(emitterOrTarget)) {\n    const root = emitterOrTarget[kEvents].get(type);\n    const listeners = [];\n    let handler = root?.next;\n    while (handler?.listener !== undefined) {\n      const listener = handler.listener?.deref ?\n        handler.listener.deref() : handler.listener;\n      listeners.push(listener);\n      handler = handler.next;\n    }\n    return listeners;\n  }\n  throw new ERR_INVALID_ARG_TYPE('emitter',\n                                 ['EventEmitter', 'EventTarget'],\n                                 emitterOrTarget);\n}\n\n/**\n * Returns the max listeners set.\n * @param {EventEmitter | EventTarget} emitterOrTarget\n * @returns {number}\n */\nfunction getMaxListeners(emitterOrTarget) {\n  if (typeof emitterOrTarget?.getMaxListeners === 'function') {\n    return _getMaxListeners(emitterOrTarget);\n  } else if (emitterOrTarget?.[kMaxEventTargetListeners]) {\n    return emitterOrTarget[kMaxEventTargetListeners];\n  }\n\n  throw new ERR_INVALID_ARG_TYPE('emitter',\n                                 ['EventEmitter', 'EventTarget'],\n                                 emitterOrTarget);\n}\n\n/**\n * Creates a `Promise` that is fulfilled when the emitter\n * emits the given event.\n * @param {EventEmitter} emitter\n * @param {string} name\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {Promise}\n */\nasync function once(emitter, name, options = kEmptyObject) {\n  const signal = options?.signal;\n  validateAbortSignal(signal, 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError(undefined, { cause: signal?.reason });\n  return new Promise((resolve, reject) => {\n    const errorListener = (err) => {\n      emitter.removeListener(name, resolver);\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal, 'abort', abortListener);\n      }\n      reject(err);\n    };\n    const resolver = (...args) => {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal, 'abort', abortListener);\n      }\n      resolve(args);\n    };\n\n    kResistStopPropagation ??= require('internal/event_target').kResistStopPropagation;\n    const opts = { __proto__: null, once: true, [kResistStopPropagation]: true };\n    eventTargetAgnosticAddListener(emitter, name, resolver, opts);\n    if (name !== 'error' && typeof emitter.once === 'function') {\n      // EventTarget does not have `error` event semantics like Node\n      // EventEmitters, we listen to `error` events only on EventEmitters.\n      emitter.once('error', errorListener);\n    }\n    function abortListener() {\n      eventTargetAgnosticRemoveListener(emitter, name, resolver);\n      eventTargetAgnosticRemoveListener(emitter, 'error', errorListener);\n      reject(new AbortError(undefined, { cause: signal?.reason }));\n    }\n    if (signal != null) {\n      eventTargetAgnosticAddListener(\n        signal, 'abort', abortListener, { __proto__: null, once: true, [kResistStopPropagation]: true });\n    }\n  });\n}\n\nconst AsyncIteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf(async function* () {}).prototype);\n\nfunction createIterResult(value, done) {\n  return { value, done };\n}\n\nfunction eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {\n  if (typeof emitter.removeListener === 'function') {\n    emitter.removeListener(name, listener);\n  } else if (typeof emitter.removeEventListener === 'function') {\n    emitter.removeEventListener(name, listener, flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter', 'EventEmitter', emitter);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags?.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    emitter.addEventListener(name, listener, flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter', 'EventEmitter', emitter);\n  }\n}\n\n/**\n * Returns an `AsyncIterator` that iterates `event` events.\n * @param {EventEmitter} emitter\n * @param {string | symbol} event\n * @param {{\n *    signal: AbortSignal;\n *    close?: string[];\n *    highWatermark?: number,\n *    lowWatermark?: number\n *   }} [options]\n * @returns {AsyncIterator}\n */\nfunction on(emitter, event, options = kEmptyObject) {\n  // Parameters validation\n  const signal = options.signal;\n  validateAbortSignal(signal, 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError(undefined, { cause: signal?.reason });\n  const highWatermark = options.highWatermark ?? NumberMAX_SAFE_INTEGER;\n  validateInteger(highWatermark, 'options.highWatermark', 1);\n  const lowWatermark = options.lowWatermark ?? 1;\n  validateInteger(lowWatermark, 'options.lowWatermark', 1);\n\n  // Preparing controlling queues and variables\n  FixedQueue ??= require('internal/fixed_queue');\n  const unconsumedEvents = new FixedQueue();\n  const unconsumedPromises = new FixedQueue();\n  let paused = false;\n  let error = null;\n  let finished = false;\n  let size = 0;\n\n  const iterator = ObjectSetPrototypeOf({\n    next() {\n      // First, we consume all unread events\n      if (size) {\n        const value = unconsumedEvents.shift();\n        size--;\n        if (paused && size < lowWatermark) {\n          emitter.resume();\n          paused = false;\n        }\n        return PromiseResolve(createIterResult(value, false));\n      }\n\n      // Then we error, if an error happened\n      // This happens one time if at all, because after 'error'\n      // we stop listening\n      if (error) {\n        const p = PromiseReject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n\n      // If the iterator is finished, resolve to done\n      if (finished) return closeHandler();\n\n      // Wait until an event happens\n      return new Promise(function(resolve, reject) {\n        unconsumedPromises.push({ resolve, reject });\n      });\n    },\n\n    return() {\n      return closeHandler();\n    },\n\n    throw(err) {\n      if (!err || !(err instanceof Error)) {\n        throw new ERR_INVALID_ARG_TYPE('EventEmitter.AsyncIterator',\n                                       'Error', err);\n      }\n      errorHandler(err);\n    },\n    [SymbolAsyncIterator]() {\n      return this;\n    },\n    [kWatermarkData]: {\n      /**\n       * The current queue size\n       */\n      get size() {\n        return size;\n      },\n      /**\n       * The low watermark. The emitter is resumed every time size is lower than it\n       */\n      get low() {\n        return lowWatermark;\n      },\n      /**\n       * The high watermark. The emitter is paused every time size is higher than it\n       */\n      get high() {\n        return highWatermark;\n      },\n      /**\n       * It checks whether the emitter is paused by the watermark controller or not\n       */\n      get isPaused() {\n        return paused;\n      },\n    },\n  }, AsyncIteratorPrototype);\n\n  // Adding event handlers\n  const { addEventListener, removeAll } = listenersController();\n  kFirstEventParam ??= require('internal/events/symbols').kFirstEventParam;\n  addEventListener(emitter, event, options[kFirstEventParam] ? eventHandler : function(...args) {\n    return eventHandler(args);\n  });\n  if (event !== 'error' && typeof emitter.on === 'function') {\n    addEventListener(emitter, 'error', errorHandler);\n  }\n  const closeEvents = options?.close;\n  if (closeEvents?.length) {\n    for (let i = 0; i < closeEvents.length; i++) {\n      addEventListener(emitter, closeEvents[i], closeHandler);\n    }\n  }\n  if (signal) {\n    kResistStopPropagation ??= require('internal/event_target').kResistStopPropagation;\n    eventTargetAgnosticAddListener(\n      signal,\n      'abort',\n      abortListener,\n      { __proto__: null, once: true, [kResistStopPropagation]: true });\n  }\n\n  return iterator;\n\n  function abortListener() {\n    errorHandler(new AbortError(undefined, { cause: signal?.reason }));\n  }\n\n  function eventHandler(value) {\n    if (unconsumedPromises.isEmpty()) {\n      size++;\n      if (!paused && size > highWatermark) {\n        paused = true;\n        emitter.pause();\n      }\n      unconsumedEvents.push(value);\n    } else unconsumedPromises.shift().resolve(createIterResult(value, false));\n  }\n\n  function errorHandler(err) {\n    if (unconsumedPromises.isEmpty()) error = err;\n    else unconsumedPromises.shift().reject(err);\n\n    closeHandler();\n  }\n\n  function closeHandler() {\n    removeAll();\n    finished = true;\n    const doneResult = createIterResult(undefined, true);\n    while (!unconsumedPromises.isEmpty()) {\n      unconsumedPromises.shift().resolve(doneResult);\n    }\n\n    return PromiseResolve(doneResult);\n  }\n}\n\nfunction listenersController() {\n  const listeners = [];\n\n  return {\n    addEventListener(emitter, event, handler, flags) {\n      eventTargetAgnosticAddListener(emitter, event, handler, flags);\n      ArrayPrototypePush(listeners, [emitter, event, handler, flags]);\n    },\n    removeAll() {\n      while (listeners.length > 0) {\n        ReflectApply(eventTargetAgnosticRemoveListener, undefined, ArrayPrototypePop(listeners));\n      }\n    },\n  };\n}\n\nlet queueMicrotask;\n\nfunction addAbortListener(signal, listener) {\n  if (signal === undefined) {\n    throw new ERR_INVALID_ARG_TYPE('signal', 'AbortSignal', signal);\n  }\n  validateAbortSignal(signal, 'signal');\n  validateFunction(listener, 'listener');\n\n  let removeEventListener;\n  if (signal.aborted) {\n    queueMicrotask ??= require('internal/process/task_queues').queueMicrotask;\n    queueMicrotask(() => listener());\n  } else {\n    kResistStopPropagation ??= require('internal/event_target').kResistStopPropagation;\n    // TODO(atlowChemi) add { subscription: true } and return directly\n    signal.addEventListener('abort', listener, { __proto__: null, once: true, [kResistStopPropagation]: true });\n    removeEventListener = () => {\n      signal.removeEventListener('abort', listener);\n    };\n  }\n  return {\n    __proto__: null,\n    [SymbolDispose]() {\n      removeEventListener?.();\n    },\n  };\n}\n"
    },
    "28": {
      "sourceCode": "'use strict';\n\nconst {\n  Array,\n  FunctionPrototypeBind,\n} = primordials;\n\nconst {\n  // For easy access to the nextTick state in the C++ land,\n  // and to avoid unnecessary calls into JS land.\n  tickInfo,\n  // Used to run V8's micro task queue.\n  runMicrotasks,\n  setTickCallback,\n  enqueueMicrotask,\n} = internalBinding('task_queue');\n\nconst {\n  setHasRejectionToWarn,\n  hasRejectionToWarn,\n  listenForRejections,\n  processPromiseRejections,\n} = require('internal/process/promises');\n\nconst {\n  getDefaultTriggerAsyncId,\n  newAsyncId,\n  initHooksExist,\n  destroyHooksExist,\n  emitInit,\n  emitBefore,\n  emitAfter,\n  emitDestroy,\n  symbols: { async_id_symbol, trigger_async_id_symbol },\n} = require('internal/async_hooks');\nconst FixedQueue = require('internal/fixed_queue');\n\nconst {\n  validateFunction,\n} = require('internal/validators');\n\nconst { AsyncResource } = require('async_hooks');\n\n// *Must* match Environment::TickInfo::Fields in src/env.h.\nconst kHasTickScheduled = 0;\n\nfunction hasTickScheduled() {\n  return tickInfo[kHasTickScheduled] === 1;\n}\n\nfunction setHasTickScheduled(value) {\n  tickInfo[kHasTickScheduled] = value ? 1 : 0;\n}\n\nconst queue = new FixedQueue();\n\n// Should be in sync with RunNextTicksNative in node_task_queue.cc\nfunction runNextTicks() {\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    runMicrotasks();\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    return;\n\n  processTicksAndRejections();\n}\n\nfunction processTicksAndRejections() {\n  let tock;\n  do {\n    while ((tock = queue.shift()) !== null) {\n      const asyncId = tock[async_id_symbol];\n      emitBefore(asyncId, tock[trigger_async_id_symbol], tock);\n\n      try {\n        const callback = tock.callback;\n        if (tock.args === undefined) {\n          callback();\n        } else {\n          const args = tock.args;\n          switch (args.length) {\n            case 1: callback(args[0]); break;\n            case 2: callback(args[0], args[1]); break;\n            case 3: callback(args[0], args[1], args[2]); break;\n            case 4: callback(args[0], args[1], args[2], args[3]); break;\n            default: callback(...args);\n          }\n        }\n      } finally {\n        if (destroyHooksExist())\n          emitDestroy(asyncId);\n      }\n\n      emitAfter(asyncId);\n    }\n    runMicrotasks();\n  } while (!queue.isEmpty() || processPromiseRejections());\n  setHasTickScheduled(false);\n  setHasRejectionToWarn(false);\n}\n\n// `nextTick()` will not enqueue any callback when the process is about to\n// exit since the callback would not have a chance to be executed.\nfunction nextTick(callback) {\n  validateFunction(callback, 'callback');\n\n  if (process._exiting)\n    return;\n\n  let args;\n  switch (arguments.length) {\n    case 1: break;\n    case 2: args = [arguments[1]]; break;\n    case 3: args = [arguments[1], arguments[2]]; break;\n    case 4: args = [arguments[1], arguments[2], arguments[3]]; break;\n    default:\n      args = new Array(arguments.length - 1);\n      for (let i = 1; i < arguments.length; i++)\n        args[i - 1] = arguments[i];\n  }\n\n  if (queue.isEmpty())\n    setHasTickScheduled(true);\n  const asyncId = newAsyncId();\n  const triggerAsyncId = getDefaultTriggerAsyncId();\n  const tickObject = {\n    [async_id_symbol]: asyncId,\n    [trigger_async_id_symbol]: triggerAsyncId,\n    callback,\n    args,\n  };\n  if (initHooksExist())\n    emitInit(asyncId, 'TickObject', triggerAsyncId, tickObject);\n  queue.push(tickObject);\n}\n\nfunction runMicrotask() {\n  this.runInAsyncScope(() => {\n    const callback = this.callback;\n    try {\n      callback();\n    } finally {\n      this.emitDestroy();\n    }\n  });\n}\n\nconst defaultMicrotaskResourceOpts = { requireManualDestroy: true };\n\nfunction queueMicrotask(callback) {\n  validateFunction(callback, 'callback');\n\n  const asyncResource = new AsyncResource(\n    'Microtask',\n    defaultMicrotaskResourceOpts,\n  );\n  asyncResource.callback = callback;\n\n  enqueueMicrotask(FunctionPrototypeBind(runMicrotask, asyncResource));\n}\n\nmodule.exports = {\n  setupTaskQueue() {\n    // Sets the per-isolate promise rejection callback\n    listenForRejections();\n    // Sets the callback to be run in every tick.\n    setTickCallback(processTicksAndRejections);\n    return {\n      nextTick,\n      runNextTicks,\n    };\n  },\n  queueMicrotask,\n};\n"
    },
    "32": {
      "sourceCode": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  MathTrunc,\n  ObjectDefineProperty,\n  SymbolDispose,\n  SymbolToPrimitive,\n} = primordials;\n\nconst binding = internalBinding('timers');\nconst {\n  immediateInfo,\n} = binding;\nconst L = require('internal/linkedlist');\nconst {\n  async_id_symbol,\n  Timeout,\n  Immediate,\n  decRefCount,\n  immediateInfoFields: {\n    kCount,\n    kRefCount,\n  },\n  kRefed,\n  kHasPrimitive,\n  getTimerDuration,\n  timerListMap,\n  timerListQueue,\n  immediateQueue,\n  active,\n  unrefActive,\n  insert,\n} = require('internal/timers');\nconst {\n  promisify: { custom: customPromisify },\n  deprecate,\n} = require('internal/util');\nlet debug = require('internal/util/debuglog').debuglog('timer', (fn) => {\n  debug = fn;\n});\nconst { validateFunction } = require('internal/validators');\n\nlet timersPromises;\n\nconst {\n  destroyHooksExist,\n  // The needed emit*() functions.\n  emitDestroy,\n} = require('internal/async_hooks');\n\n// This stores all the known timer async ids to allow users to clearTimeout and\n// clearInterval using those ids, to match the spec and the rest of the web\n// platform.\nconst knownTimersById = { __proto__: null };\n\n// Remove a timer. Cancels the timeout and resets the relevant timer properties.\nfunction unenroll(item) {\n  if (item._destroyed)\n    return;\n\n  item._destroyed = true;\n\n  if (item[kHasPrimitive])\n    delete knownTimersById[item[async_id_symbol]];\n\n  // Fewer checks may be possible, but these cover everything.\n  if (destroyHooksExist() && item[async_id_symbol] !== undefined)\n    emitDestroy(item[async_id_symbol]);\n\n  L.remove(item);\n\n  // We only delete refed lists because unrefed ones are incredibly likely\n  // to come from http and be recreated shortly after.\n  // TODO: Long-term this could instead be handled by creating an internal\n  // clearTimeout that makes it clear that the list should not be deleted.\n  // That function could then be used by http and other similar modules.\n  if (item[kRefed]) {\n    // Compliment truncation during insert().\n    const msecs = MathTrunc(item._idleTimeout);\n    const list = timerListMap[msecs];\n    if (list !== undefined && L.isEmpty(list)) {\n      debug('unenroll: list empty');\n      timerListQueue.removeAt(list.priorityQueuePosition);\n      delete timerListMap[list.msecs];\n    }\n\n    decRefCount();\n  }\n\n  // If active is called later, then we want to make sure not to insert again\n  item._idleTimeout = -1;\n}\n\n// Make a regular object able to act as a timer by setting some properties.\n// This function does not start the timer, see `active()`.\n// Using existing objects as timers slightly reduces object overhead.\nfunction enroll(item, msecs) {\n  msecs = getTimerDuration(msecs, 'msecs');\n\n  // If this item was already in a list somewhere\n  // then we should unenroll it from that\n  if (item._idleNext) unenroll(item);\n\n  L.init(item);\n  item._idleTimeout = msecs;\n}\n\n\n/**\n * Schedules the execution of a one-time `callback`\n * after `after` milliseconds.\n * @param {Function} callback\n * @param {number} [after]\n * @param {any} [arg1]\n * @param {any} [arg2]\n * @param {any} [arg3]\n * @returns {Timeout}\n */\nfunction setTimeout(callback, after, arg1, arg2, arg3) {\n  validateFunction(callback, 'callback');\n\n  let i, args;\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n    case 2:\n      break;\n    case 3:\n      args = [arg1];\n      break;\n    case 4:\n      args = [arg1, arg2];\n      break;\n    default:\n      args = [arg1, arg2, arg3];\n      for (i = 5; i < arguments.length; i++) {\n        // Extend array dynamically, makes .apply run much faster in v6.0.0\n        args[i - 2] = arguments[i];\n      }\n      break;\n  }\n\n  const timeout = new Timeout(callback, after, args, false, true);\n  insert(timeout, timeout._idleTimeout);\n\n  return timeout;\n}\n\nObjectDefineProperty(setTimeout, customPromisify, {\n  __proto__: null,\n  enumerable: true,\n  get() {\n    if (!timersPromises)\n      timersPromises = require('timers/promises');\n    return timersPromises.setTimeout;\n  },\n});\n\n/**\n * Cancels a timeout.\n * @param {Timeout | string | number} timer\n * @returns {void}\n */\nfunction clearTimeout(timer) {\n  if (timer && timer._onTimeout) {\n    timer._onTimeout = null;\n    unenroll(timer);\n    return;\n  }\n  if (typeof timer === 'number' || typeof timer === 'string') {\n    const timerInstance = knownTimersById[timer];\n    if (timerInstance !== undefined) {\n      timerInstance._onTimeout = null;\n      unenroll(timerInstance);\n    }\n  }\n}\n\n/**\n * Schedules repeated execution of `callback`\n * every `repeat` milliseconds.\n * @param {Function} callback\n * @param {number} [repeat]\n * @param {any} [arg1]\n * @param {any} [arg2]\n * @param {any} [arg3]\n * @returns {Timeout}\n */\nfunction setInterval(callback, repeat, arg1, arg2, arg3) {\n  validateFunction(callback, 'callback');\n\n  let i, args;\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n    case 2:\n      break;\n    case 3:\n      args = [arg1];\n      break;\n    case 4:\n      args = [arg1, arg2];\n      break;\n    default:\n      args = [arg1, arg2, arg3];\n      for (i = 5; i < arguments.length; i++) {\n        // Extend array dynamically, makes .apply run much faster in v6.0.0\n        args[i - 2] = arguments[i];\n      }\n      break;\n  }\n\n  const timeout = new Timeout(callback, repeat, args, true, true);\n  insert(timeout, timeout._idleTimeout);\n\n  return timeout;\n}\n\n/**\n * Cancels an interval.\n * @param {Timeout | string | number} timer\n * @returns {void}\n */\nfunction clearInterval(timer) {\n  // clearTimeout and clearInterval can be used to clear timers created from\n  // both setTimeout and setInterval, as specified by HTML Living Standard:\n  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval\n  clearTimeout(timer);\n}\n\nTimeout.prototype.close = function() {\n  clearTimeout(this);\n  return this;\n};\n\nTimeout.prototype[SymbolDispose] = function() {\n  clearTimeout(this);\n};\n\n/**\n * Coerces a `Timeout` to a primitive.\n * @returns {number}\n */\nTimeout.prototype[SymbolToPrimitive] = function() {\n  const id = this[async_id_symbol];\n  if (!this[kHasPrimitive]) {\n    this[kHasPrimitive] = true;\n    knownTimersById[id] = this;\n  }\n  return id;\n};\n\n/**\n * Schedules the immediate execution of `callback`\n * after I/O events' callbacks.\n * @param {Function} callback\n * @param {any} [arg1]\n * @param {any} [arg2]\n * @param {any} [arg3]\n * @returns {Immediate}\n */\nfunction setImmediate(callback, arg1, arg2, arg3) {\n  validateFunction(callback, 'callback');\n\n  let i, args;\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n      break;\n    case 2:\n      args = [arg1];\n      break;\n    case 3:\n      args = [arg1, arg2];\n      break;\n    default:\n      args = [arg1, arg2, arg3];\n      for (i = 4; i < arguments.length; i++) {\n        // Extend array dynamically, makes .apply run much faster in v6.0.0\n        args[i - 1] = arguments[i];\n      }\n      break;\n  }\n\n  return new Immediate(callback, args);\n}\n\nObjectDefineProperty(setImmediate, customPromisify, {\n  __proto__: null,\n  enumerable: true,\n  get() {\n    if (!timersPromises)\n      timersPromises = require('timers/promises');\n    return timersPromises.setImmediate;\n  },\n});\n\n/**\n * Cancels an immediate.\n * @param {Immediate} immediate\n * @returns {void}\n */\nfunction clearImmediate(immediate) {\n  if (!immediate || immediate._destroyed)\n    return;\n\n  immediateInfo[kCount]--;\n  immediate._destroyed = true;\n\n  if (immediate[kRefed] && --immediateInfo[kRefCount] === 0) {\n    // We need to use the binding as the receiver for fast API calls.\n    binding.toggleImmediateRef(false);\n  }\n  immediate[kRefed] = null;\n\n  if (destroyHooksExist() && immediate[async_id_symbol] !== undefined) {\n    emitDestroy(immediate[async_id_symbol]);\n  }\n\n  immediate._onImmediate = null;\n\n  immediateQueue.remove(immediate);\n}\n\nImmediate.prototype[SymbolDispose] = function() {\n  clearImmediate(this);\n};\n\nmodule.exports = {\n  setTimeout,\n  clearTimeout,\n  setImmediate,\n  clearImmediate,\n  setInterval,\n  clearInterval,\n  _unrefActive: deprecate(\n    unrefActive,\n    'timers._unrefActive() is deprecated.' +\n    ' Please use timeout.refresh() instead.',\n    'DEP0127'),\n  active: deprecate(\n    active,\n    'timers.active() is deprecated. Please use timeout.refresh() instead.',\n    'DEP0126'),\n  unenroll: deprecate(\n    unenroll,\n    'timers.unenroll() is deprecated. Please use clearTimeout instead.',\n    'DEP0096'),\n  enroll: deprecate(\n    enroll,\n    'timers.enroll() is deprecated. Please use setTimeout instead.',\n    'DEP0095'),\n};\n"
    },
    "34": {
      "sourceCode": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  FunctionPrototypeBind,\n  StringPrototypeCharCodeAt,\n  StringPrototypeIndexOf,\n  StringPrototypeLastIndexOf,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeToLowerCase,\n} = primordials;\n\nconst {\n  CHAR_UPPERCASE_A,\n  CHAR_LOWERCASE_A,\n  CHAR_UPPERCASE_Z,\n  CHAR_LOWERCASE_Z,\n  CHAR_DOT,\n  CHAR_FORWARD_SLASH,\n  CHAR_BACKWARD_SLASH,\n  CHAR_COLON,\n  CHAR_QUESTION_MARK,\n} = require('internal/constants');\nconst {\n  validateObject,\n  validateString,\n} = require('internal/validators');\n\nconst platformIsWin32 = (process.platform === 'win32');\n\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = StringPrototypeCharCodeAt(path, i);\n    else if (isPathSeparator(code))\n      break;\n    else\n      code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 ||\n            StringPrototypeCharCodeAt(res, res.length - 1) !== CHAR_DOT ||\n            StringPrototypeCharCodeAt(res, res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = StringPrototypeLastIndexOf(res, separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = StringPrototypeSlice(res, 0, lastSlashIndex);\n              lastSegmentLength =\n                res.length - 1 - StringPrototypeLastIndexOf(res, separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += `${separator}${StringPrototypeSlice(path, lastSlash + 1, i)}`;\n        else\n          res = StringPrototypeSlice(path, lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction formatExt(ext) {\n  return ext ? `${ext[0] === '.' ? '' : '.'}${ext}` : '';\n}\n\n/**\n * @param {string} sep\n * @param {{\n *  dir?: string;\n *  root?: string;\n *  base?: string;\n *  name?: string;\n *  ext?: string;\n *  }} pathObject\n * @returns {string}\n */\nfunction _format(sep, pathObject) {\n  validateObject(pathObject, 'pathObject');\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base ||\n    `${pathObject.name || ''}${formatExt(pathObject.ext)}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nconst win32 = {\n  /**\n   * path.resolve([from ...], to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedDevice = '';\n    let resolvedTail = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1; i--) {\n      let path;\n      if (i >= 0) {\n        path = args[i];\n        validateString(path, `paths[${i}]`);\n\n        // Skip empty entries\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path, get cwd for that drive, or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points, because UNC paths are always absolute.\n        path = process.env[`=${resolvedDevice}`] || process.cwd();\n\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not, default to the drive's root.\n        if (path === undefined ||\n            (StringPrototypeToLowerCase(StringPrototypeSlice(path, 0, 2)) !==\n            StringPrototypeToLowerCase(resolvedDevice) &&\n            StringPrototypeCharCodeAt(path, 2) === CHAR_BACKWARD_SLASH)) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n\n      const len = path.length;\n      let rootEnd = 0;\n      let device = '';\n      let isAbsolute = false;\n      const code = StringPrototypeCharCodeAt(path, 0);\n\n      // Try to match a root\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          // `path` contains just a path separator\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        // Possible UNC root\n\n        // If we started with a separator, we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(StringPrototypeCharCodeAt(path, 1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          while (j < len &&\n                 !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            const firstPart = StringPrototypeSlice(path, last, j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            while (j < len &&\n                   isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n              j++;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              while (j < len &&\n                     !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                // We matched a UNC root\n                device =\n                  `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path, last, j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) &&\n                  StringPrototypeCharCodeAt(path, 1) === CHAR_COLON) {\n        // Possible device root\n        device = StringPrototypeSlice(path, 0, 2);\n        rootEnd = 2;\n        if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path, 2))) {\n          // Treat separator following drive name as an absolute path\n          // indicator\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (StringPrototypeToLowerCase(device) !==\n              StringPrototypeToLowerCase(resolvedDevice))\n            // This path points to another device so it is not applicable\n            continue;\n        } else {\n          resolvedDevice = device;\n        }\n      }\n\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0)\n          break;\n      } else {\n        resolvedTail =\n          `${StringPrototypeSlice(path, rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    }\n\n    // At this point the path should be resolved to a full absolute path,\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n                                   isPathSeparator);\n\n    return resolvedAbsolute ?\n      `${resolvedDevice}\\\\${resolvedTail}` :\n      `${resolvedDevice}${resolvedTail}` || '.';\n  },\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path, 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = StringPrototypeCharCodeAt(path, 0);\n\n    // Try to match a root\n    if (len === 1) {\n      // `path` contains just a single char, exit early to avoid\n      // unnecessary work\n      return isPosixPathSeparator(code) ? '\\\\' : path;\n    }\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator, we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          const firstPart = StringPrototypeSlice(path, last, j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n              return `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path, last)}\\\\`;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              device =\n                `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path, last, j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path, 1) === CHAR_COLON) {\n      // Possible device root\n      device = StringPrototypeSlice(path, 0, 2);\n      rootEnd = 2;\n      if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path, 2))) {\n        // Treat separator following drive name as an absolute path\n        // indicator\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n\n    let tail = rootEnd < len ?\n      normalizeString(StringPrototypeSlice(path, rootEnd),\n                      !isAbsolute, '\\\\', isPathSeparator) :\n      '';\n    if (tail.length === 0 && !isAbsolute)\n      tail = '.';\n    if (tail.length > 0 &&\n        isPathSeparator(StringPrototypeCharCodeAt(path, len - 1)))\n      tail += '\\\\';\n    if (device === undefined) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  },\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path, 'path');\n    const len = path.length;\n    if (len === 0)\n      return false;\n\n    const code = StringPrototypeCharCodeAt(path, 0);\n    return isPathSeparator(code) ||\n      // Possible device root\n      (len > 2 &&\n      isWindowsDeviceRoot(code) &&\n      StringPrototypeCharCodeAt(path, 1) === CHAR_COLON &&\n      isPathSeparator(StringPrototypeCharCodeAt(path, 2)));\n  },\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n\n    let joined;\n    let firstPart;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = firstPart = arg;\n        else\n          joined += `\\\\${arg}`;\n      }\n    }\n\n    if (joined === undefined)\n      return '.';\n\n    // Make sure that the joined path doesn't start with two slashes, because\n    // normalize() will mistake it for a UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at a UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as a UNC path it needs to\n    // have at least 2 components, so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n    let needsReplace = true;\n    let slashCount = 0;\n    if (isPathSeparator(StringPrototypeCharCodeAt(firstPart, 0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1 &&\n          isPathSeparator(StringPrototypeCharCodeAt(firstPart, 1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(StringPrototypeCharCodeAt(firstPart, 2)))\n            ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      while (slashCount < joined.length &&\n             isPathSeparator(StringPrototypeCharCodeAt(joined, slashCount))) {\n        slashCount++;\n      }\n\n      // Replace the slashes if needed\n      if (slashCount >= 2)\n        joined = `\\\\${StringPrototypeSlice(joined, slashCount)}`;\n    }\n\n    return win32.normalize(joined);\n  },\n\n  /**\n   * It will solve the relative path from `from` to `to`, for instance\n   * from = 'C:\\\\orandea\\\\test\\\\aaa'\n   * to = 'C:\\\\orandea\\\\impl\\\\bbb'\n   * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to)\n      return '';\n\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig)\n      return '';\n\n    from = StringPrototypeToLowerCase(fromOrig);\n    to = StringPrototypeToLowerCase(toOrig);\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    let fromStart = 0;\n    while (fromStart < from.length &&\n           StringPrototypeCharCodeAt(from, fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let fromEnd = from.length;\n    while (\n      fromEnd - 1 > fromStart &&\n      StringPrototypeCharCodeAt(from, fromEnd - 1) === CHAR_BACKWARD_SLASH\n    ) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    let toStart = 0;\n    while (toStart < to.length &&\n           StringPrototypeCharCodeAt(to, toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let toEnd = to.length;\n    while (toEnd - 1 > toStart &&\n           StringPrototypeCharCodeAt(to, toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from, fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to, toStart + i))\n        break;\n      else if (fromCode === CHAR_BACKWARD_SLASH)\n        lastCommonSep = i;\n    }\n\n    // We found a mismatch before the first common path separator was seen, so\n    // return the original `to`.\n    if (i !== length) {\n      if (lastCommonSep === -1)\n        return toOrig;\n    } else {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to, toStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return StringPrototypeSlice(toOrig, toStart + i + 1);\n        }\n        if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return StringPrototypeSlice(toOrig, toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from, fromStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1)\n        lastCommonSep = 0;\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from, i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? '..' : '\\\\..';\n      }\n    }\n\n    toStart += lastCommonSep;\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return `${out}${StringPrototypeSlice(toOrig, toStart, toEnd)}`;\n\n    if (StringPrototypeCharCodeAt(toOrig, toStart) === CHAR_BACKWARD_SLASH)\n      ++toStart;\n    return StringPrototypeSlice(toOrig, toStart, toEnd);\n  },\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string' || path.length === 0)\n      return path;\n\n    const resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length <= 2)\n      return path;\n\n    if (StringPrototypeCharCodeAt(resolvedPath, 0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n      if (StringPrototypeCharCodeAt(resolvedPath, 1) === CHAR_BACKWARD_SLASH) {\n        const code = StringPrototypeCharCodeAt(resolvedPath, 2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root, convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${StringPrototypeSlice(resolvedPath, 2)}`;\n        }\n      }\n    } else if (\n      isWindowsDeviceRoot(StringPrototypeCharCodeAt(resolvedPath, 0)) &&\n      StringPrototypeCharCodeAt(resolvedPath, 1) === CHAR_COLON &&\n      StringPrototypeCharCodeAt(resolvedPath, 2) === CHAR_BACKWARD_SLASH\n    ) {\n      // Matched device root, convert the path to a long UNC path\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n\n    return path;\n  },\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path, 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = -1;\n    let offset = 0;\n    const code = StringPrototypeCharCodeAt(path, 0);\n\n    if (len === 1) {\n      // `path` contains just a path separator, exit early to avoid\n      // unnecessary work or a dot.\n      return isPathSeparator(code) ? path : '.';\n    }\n\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a \"normal root\" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    // Possible device root\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path, 1) === CHAR_COLON) {\n      rootEnd =\n        len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path, 2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1)\n        return '.';\n\n      end = rootEnd;\n    }\n    return StringPrototypeSlice(path, 0, end);\n  },\n\n  /**\n   * @param {string} path\n   * @param {string} [suffix]\n   * @returns {string}\n   */\n  basename(path, suffix) {\n    if (suffix !== undefined)\n      validateString(suffix, 'ext');\n    validateString(path, 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2 &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path, 0)) &&\n        StringPrototypeCharCodeAt(path, 1) === CHAR_COLON) {\n      start = 2;\n    }\n\n    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n      if (suffix === path)\n        return '';\n      let extIdx = suffix.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= start; --i) {\n        const code = StringPrototypeCharCodeAt(path, i);\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(suffix, extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path, start, end);\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, i))) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path, start, end);\n  },\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path, 'path');\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 &&\n        StringPrototypeCharCodeAt(path, 1) === CHAR_COLON &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path, 0))) {\n      start = startPart = 2;\n    }\n\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path, i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path, startDot, end);\n  },\n\n  format: FunctionPrototypeBind(_format, null, '\\\\'),\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *  dir: string;\n   *  root: string;\n   *  base: string;\n   *  name: string;\n   *  ext: string;\n   *  }}\n   */\n  parse(path) {\n    validateString(path, 'path');\n\n    const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0)\n      return ret;\n\n    const len = path.length;\n    let rootEnd = 0;\n    let code = StringPrototypeCharCodeAt(path, 0);\n\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        // `path` contains just a path separator, exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = 1;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path, 1) === CHAR_COLON) {\n      // Possible device root\n      if (len <= 2) {\n        // `path` contains just a drive root, exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, 2))) {\n        if (len === 3) {\n          // `path` contains just a drive root, exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd > 0)\n      ret.root = StringPrototypeSlice(path, 0, rootEnd);\n\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = StringPrototypeCharCodeAt(path, i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n           startDot === end - 1 &&\n           startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path, startPart, end);\n      } else {\n        ret.name = StringPrototypeSlice(path, startPart, startDot);\n        ret.base = StringPrototypeSlice(path, startPart, end);\n        ret.ext = StringPrototypeSlice(path, startDot, end);\n      }\n    }\n\n    // If the directory is the root, use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n    if (startPart > 0 && startPart !== rootEnd)\n      ret.dir = StringPrototypeSlice(path, 0, startPart - 1);\n    else\n      ret.dir = ret.root;\n\n    return ret;\n  },\n\n  sep: '\\\\',\n  delimiter: ';',\n  win32: null,\n  posix: null,\n};\n\nconst posixCwd = (() => {\n  if (platformIsWin32) {\n    // Converts Windows' backslash path separators to POSIX forward slashes\n    // and truncates any drive indicator\n    const regexp = /\\\\/g;\n    return () => {\n      const cwd = StringPrototypeReplace(process.cwd(), regexp, '/');\n      return StringPrototypeSlice(cwd, StringPrototypeIndexOf(cwd, '/'));\n    };\n  }\n\n  // We're already on POSIX, no need for any transformations\n  return () => process.cwd();\n})();\n\nconst posix = {\n  /**\n   * path.resolve([from ...], to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? args[i] : posixCwd();\n      validateString(path, `paths[${i}]`);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute =\n        StringPrototypeCharCodeAt(path, 0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n                                   isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  },\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path, 'path');\n\n    if (path.length === 0)\n      return '.';\n\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path, 0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator =\n      StringPrototypeCharCodeAt(path, path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute)\n        return '/';\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator)\n      path += '/';\n\n    return isAbsolute ? `/${path}` : path;\n  },\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path, 'path');\n    return path.length > 0 &&\n           StringPrototypeCharCodeAt(path, 0) === CHAR_FORWARD_SLASH;\n  },\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n    let joined;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += `/${arg}`;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to)\n      return '';\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = (fromLen < toLen ? fromLen : toLen);\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from, fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to, toStart + i))\n        break;\n      else if (fromCode === CHAR_FORWARD_SLASH)\n        lastCommonSep = i;\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to, toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return StringPrototypeSlice(to, toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return StringPrototypeSlice(to, toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from, fromStart + i) ===\n            CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from, i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${StringPrototypeSlice(to, toStart + lastCommonSep)}`;\n  },\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path;\n  },\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path, 'path');\n    if (path.length === 0)\n      return '.';\n    const hasRoot = StringPrototypeCharCodeAt(path, 0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return StringPrototypeSlice(path, 0, end);\n  },\n\n  /**\n   * @param {string} path\n   * @param {string} [suffix]\n   * @returns {string}\n   */\n  basename(path, suffix) {\n    if (suffix !== undefined)\n      validateString(suffix, 'ext');\n    validateString(path, 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n      if (suffix === path)\n        return '';\n      let extIdx = suffix.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= 0; --i) {\n        const code = StringPrototypeCharCodeAt(path, i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(suffix, extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path, start, end);\n    }\n    for (let i = path.length - 1; i >= 0; --i) {\n      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path, start, end);\n  },\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path, 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(path, i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path, startDot, end);\n  },\n\n  format: FunctionPrototypeBind(_format, null, '/'),\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *   dir: string;\n   *   root: string;\n   *   base: string;\n   *   name: string;\n   *   ext: string;\n   *   }}\n   */\n  parse(path) {\n    validateString(path, 'path');\n\n    const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0)\n      return ret;\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path, 0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path, i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n          startDot === end - 1 &&\n          startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path, start, end);\n      } else {\n        ret.name = StringPrototypeSlice(path, start, startDot);\n        ret.base = StringPrototypeSlice(path, start, end);\n        ret.ext = StringPrototypeSlice(path, startDot, end);\n      }\n    }\n\n    if (startPart > 0)\n      ret.dir = StringPrototypeSlice(path, 0, startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null,\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\n// Legacy internal API, docs-only deprecated: DEP0080\nwin32._makeLong = win32.toNamespacedPath;\nposix._makeLong = posix.toNamespacedPath;\n\nmodule.exports = platformIsWin32 ? win32 : posix;\n"
    },
    "44": {
      "sourceCode": "'use strict';\n\n// The Console constructor is not actually used to construct the global\n// console. It's exported for backwards compatibility.\n\nconst {\n  ArrayFrom,\n  ArrayIsArray,\n  ArrayPrototypeForEach,\n  ArrayPrototypePush,\n  ArrayPrototypeUnshift,\n  Boolean,\n  ErrorCaptureStackTrace,\n  FunctionPrototypeBind,\n  MathFloor,\n  Number,\n  NumberPrototypeToFixed,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  ObjectKeys,\n  ObjectPrototypeHasOwnProperty,\n  ObjectValues,\n  ReflectApply,\n  ReflectConstruct,\n  ReflectOwnKeys,\n  RegExpPrototypeSymbolReplace,\n  SafeArrayIterator,\n  SafeMap,\n  SafeWeakMap,\n  SafeSet,\n  StringPrototypeIncludes,\n  StringPrototypePadStart,\n  StringPrototypeRepeat,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  Symbol,\n  SymbolHasInstance,\n  SymbolToStringTag,\n} = primordials;\n\nconst { trace } = internalBinding('trace_events');\nconst {\n  isStackOverflowError,\n  codes: {\n    ERR_CONSOLE_WRITABLE_STREAM,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INCOMPATIBLE_OPTION_PAIR,\n  },\n} = require('internal/errors');\nconst {\n  validateArray,\n  validateInteger,\n  validateObject,\n} = require('internal/validators');\nconst { previewEntries } = internalBinding('util');\nconst { Buffer: { isBuffer } } = require('buffer');\nconst {\n  inspect,\n  formatWithOptions,\n} = require('internal/util/inspect');\nconst {\n  isTypedArray, isSet, isMap, isSetIterator, isMapIterator,\n} = require('internal/util/types');\nconst {\n  CHAR_LOWERCASE_B: kTraceBegin,\n  CHAR_LOWERCASE_E: kTraceEnd,\n  CHAR_LOWERCASE_N: kTraceInstant,\n  CHAR_UPPERCASE_C: kTraceCount,\n} = require('internal/constants');\nconst kCounts = Symbol('counts');\n\nconst kTraceConsoleCategory = 'node,node.console';\n\nconst kSecond = 1000;\nconst kMinute = 60 * kSecond;\nconst kHour = 60 * kMinute;\nconst kMaxGroupIndentation = 1000;\n\n// Lazy loaded for startup performance.\nlet cliTable;\n\nlet utilColors;\nfunction lazyUtilColors() {\n  utilColors ??= require('internal/util/colors');\n  return utilColors;\n}\n\n// Track amount of indentation required via `console.group()`.\nconst kGroupIndent = Symbol('kGroupIndent');\nconst kGroupIndentationWidth = Symbol('kGroupIndentWidth');\nconst kFormatForStderr = Symbol('kFormatForStderr');\nconst kFormatForStdout = Symbol('kFormatForStdout');\nconst kGetInspectOptions = Symbol('kGetInspectOptions');\nconst kColorMode = Symbol('kColorMode');\nconst kIsConsole = Symbol('kIsConsole');\nconst kWriteToConsole = Symbol('kWriteToConsole');\nconst kBindProperties = Symbol('kBindProperties');\nconst kBindStreamsEager = Symbol('kBindStreamsEager');\nconst kBindStreamsLazy = Symbol('kBindStreamsLazy');\nconst kUseStdout = Symbol('kUseStdout');\nconst kUseStderr = Symbol('kUseStderr');\n\nconst optionsMap = new SafeWeakMap();\nfunction Console(options /* or: stdout, stderr, ignoreErrors = true */) {\n  // We have to test new.target here to see if this function is called\n  // with new, because we need to define a custom instanceof to accommodate\n  // the global console.\n  if (new.target === undefined) {\n    return ReflectConstruct(Console, arguments);\n  }\n\n  if (!options || typeof options.write === 'function') {\n    options = {\n      stdout: options,\n      stderr: arguments[1],\n      ignoreErrors: arguments[2],\n    };\n  }\n\n  const {\n    stdout,\n    stderr = stdout,\n    ignoreErrors = true,\n    colorMode = 'auto',\n    inspectOptions,\n    groupIndentation,\n  } = options;\n\n  if (!stdout || typeof stdout.write !== 'function') {\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stdout');\n  }\n  if (!stderr || typeof stderr.write !== 'function') {\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stderr');\n  }\n\n  if (typeof colorMode !== 'boolean' && colorMode !== 'auto')\n    throw new ERR_INVALID_ARG_VALUE('colorMode', colorMode);\n\n  if (groupIndentation !== undefined) {\n    validateInteger(groupIndentation, 'groupIndentation',\n                    0, kMaxGroupIndentation);\n  }\n\n  if (inspectOptions !== undefined) {\n    validateObject(inspectOptions, 'options.inspectOptions');\n\n    if (inspectOptions.colors !== undefined &&\n        options.colorMode !== undefined) {\n      throw new ERR_INCOMPATIBLE_OPTION_PAIR(\n        'options.inspectOptions.color', 'colorMode');\n    }\n    optionsMap.set(this, inspectOptions);\n  }\n\n  // Bind the prototype functions to this Console instance\n  ArrayPrototypeForEach(ObjectKeys(Console.prototype), (key) => {\n    // We have to bind the methods grabbed from the instance instead of from\n    // the prototype so that users extending the Console can override them\n    // from the prototype chain of the subclass.\n    this[key] = FunctionPrototypeBind(this[key], this);\n    ObjectDefineProperty(this[key], 'name', {\n      __proto__: null,\n      value: key,\n    });\n  });\n\n  this[kBindStreamsEager](stdout, stderr);\n  this[kBindProperties](ignoreErrors, colorMode, groupIndentation);\n}\n\nconst consolePropAttributes = {\n  writable: true,\n  enumerable: false,\n  configurable: true,\n};\n\n// Fixup global.console instanceof global.console.Console\nObjectDefineProperty(Console, SymbolHasInstance, {\n  __proto__: null,\n  value(instance) {\n    return instance[kIsConsole];\n  },\n});\n\nconst kColorInspectOptions = { colors: true };\nconst kNoColorInspectOptions = {};\n\nObjectDefineProperties(Console.prototype, {\n  [kBindStreamsEager]: {\n    __proto__: null,\n    ...consolePropAttributes,\n    // Eager version for the Console constructor\n    value: function(stdout, stderr) {\n      ObjectDefineProperties(this, {\n        '_stdout': { __proto__: null, ...consolePropAttributes, value: stdout },\n        '_stderr': { __proto__: null, ...consolePropAttributes, value: stderr },\n      });\n    },\n  },\n  [kBindStreamsLazy]: {\n    __proto__: null,\n    ...consolePropAttributes,\n    // Lazily load the stdout and stderr from an object so we don't\n    // create the stdio streams when they are not even accessed\n    value: function(object) {\n      let stdout;\n      let stderr;\n      ObjectDefineProperties(this, {\n        '_stdout': {\n          __proto__: null,\n          enumerable: false,\n          configurable: true,\n          get() {\n            if (!stdout) stdout = object.stdout;\n            return stdout;\n          },\n          set(value) { stdout = value; },\n        },\n        '_stderr': {\n          __proto__: null,\n          enumerable: false,\n          configurable: true,\n          get() {\n            if (!stderr) { stderr = object.stderr; }\n            return stderr;\n          },\n          set(value) { stderr = value; },\n        },\n      });\n    },\n  },\n  [kBindProperties]: {\n    __proto__: null,\n    ...consolePropAttributes,\n    value: function(ignoreErrors, colorMode, groupIndentation = 2) {\n      ObjectDefineProperties(this, {\n        '_stdoutErrorHandler': {\n          __proto__: null,\n          ...consolePropAttributes,\n          value: createWriteErrorHandler(this, kUseStdout),\n        },\n        '_stderrErrorHandler': {\n          ...consolePropAttributes,\n          __proto__: null,\n          value: createWriteErrorHandler(this, kUseStderr),\n        },\n        '_ignoreErrors': {\n          __proto__: null,\n          ...consolePropAttributes,\n          value: Boolean(ignoreErrors),\n        },\n        '_times': { __proto__: null, ...consolePropAttributes, value: new SafeMap() },\n        // Corresponds to https://console.spec.whatwg.org/#count-map\n        [kCounts]: { __proto__: null, ...consolePropAttributes, value: new SafeMap() },\n        [kColorMode]: { __proto__: null, ...consolePropAttributes, value: colorMode },\n        [kIsConsole]: { __proto__: null, ...consolePropAttributes, value: true },\n        [kGroupIndent]: { __proto__: null, ...consolePropAttributes, value: '' },\n        [kGroupIndentationWidth]: {\n          __proto__: null,\n          ...consolePropAttributes,\n          value: groupIndentation,\n        },\n        [SymbolToStringTag]: {\n          __proto__: null,\n          writable: false,\n          enumerable: false,\n          configurable: true,\n          value: 'console',\n        },\n      });\n    },\n  },\n  [kWriteToConsole]: {\n    __proto__: null,\n    ...consolePropAttributes,\n    value: function(streamSymbol, string) {\n      const ignoreErrors = this._ignoreErrors;\n      const groupIndent = this[kGroupIndent];\n\n      const useStdout = streamSymbol === kUseStdout;\n      const stream = useStdout ? this._stdout : this._stderr;\n      const errorHandler = useStdout ?\n        this._stdoutErrorHandler : this._stderrErrorHandler;\n\n      if (groupIndent.length !== 0) {\n        if (StringPrototypeIncludes(string, '\\n')) {\n          string = RegExpPrototypeSymbolReplace(/\\n/g, string, `\\n${groupIndent}`);\n        }\n        string = groupIndent + string;\n      }\n      string += '\\n';\n\n      if (ignoreErrors === false) return stream.write(string);\n\n      // There may be an error occurring synchronously (e.g. for files or TTYs\n      // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems), so\n      // handle both situations.\n      try {\n        // Add and later remove a noop error handler to catch synchronous\n        // errors.\n        if (stream.listenerCount('error') === 0)\n          stream.once('error', noop);\n\n        stream.write(string, errorHandler);\n      } catch (e) {\n        // Console is a debugging utility, so it swallowing errors is not\n        // desirable even in edge cases such as low stack space.\n        if (isStackOverflowError(e))\n          throw e;\n        // Sorry, there's no proper way to pass along the error here.\n      } finally {\n        stream.removeListener('error', noop);\n      }\n    },\n  },\n  [kGetInspectOptions]: {\n    __proto__: null,\n    ...consolePropAttributes,\n    value: function(stream) {\n      let color = this[kColorMode];\n      if (color === 'auto') {\n        color = lazyUtilColors().shouldColorize(stream);\n      }\n\n      const options = optionsMap.get(this);\n      if (options) {\n        if (options.colors === undefined) {\n          options.colors = color;\n        }\n        return options;\n      }\n\n      return color ? kColorInspectOptions : kNoColorInspectOptions;\n    },\n  },\n  [kFormatForStdout]: {\n    __proto__: null,\n    ...consolePropAttributes,\n    value: function(args) {\n      const opts = this[kGetInspectOptions](this._stdout);\n      ArrayPrototypeUnshift(args, opts);\n      return ReflectApply(formatWithOptions, null, args);\n    },\n  },\n  [kFormatForStderr]: {\n    __proto__: null,\n    ...consolePropAttributes,\n    value: function(args) {\n      const opts = this[kGetInspectOptions](this._stderr);\n      ArrayPrototypeUnshift(args, opts);\n      return ReflectApply(formatWithOptions, null, args);\n    },\n  },\n});\n\n// Make a function that can serve as the callback passed to `stream.write()`.\nfunction createWriteErrorHandler(instance, streamSymbol) {\n  return (err) => {\n    // This conditional evaluates to true if and only if there was an error\n    // that was not already emitted (which happens when the _write callback\n    // is invoked asynchronously).\n    const stream = streamSymbol === kUseStdout ?\n      instance._stdout : instance._stderr;\n    if (err !== null && !stream._writableState.errorEmitted) {\n      // If there was an error, it will be emitted on `stream` as\n      // an `error` event. Adding a `once` listener will keep that error\n      // from becoming an uncaught exception, but since the handler is\n      // removed after the event, non-console.* writes won't be affected.\n      // we are only adding noop if there is no one else listening for 'error'\n      if (stream.listenerCount('error') === 0) {\n        stream.once('error', noop);\n      }\n    }\n  };\n}\n\nconst consoleMethods = {\n  log(...args) {\n    this[kWriteToConsole](kUseStdout, this[kFormatForStdout](args));\n  },\n\n\n  warn(...args) {\n    this[kWriteToConsole](kUseStderr, this[kFormatForStderr](args));\n  },\n\n\n  dir(object, options) {\n    this[kWriteToConsole](kUseStdout, inspect(object, {\n      customInspect: false,\n      ...this[kGetInspectOptions](this._stdout),\n      ...options,\n    }));\n  },\n\n  time(label = 'default') {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    if (this._times.has(label)) {\n      process.emitWarning(`Label '${label}' already exists for console.time()`);\n      return;\n    }\n    trace(kTraceBegin, kTraceConsoleCategory, `time::${label}`, 0);\n    this._times.set(label, process.hrtime());\n  },\n\n  timeEnd(label = 'default') {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    const found = timeLogImpl(this, 'timeEnd', label);\n    trace(kTraceEnd, kTraceConsoleCategory, `time::${label}`, 0);\n    if (found) {\n      this._times.delete(label);\n    }\n  },\n\n  timeLog(label = 'default', ...data) {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    timeLogImpl(this, 'timeLog', label, data);\n    trace(kTraceInstant, kTraceConsoleCategory, `time::${label}`, 0);\n  },\n\n  trace: function trace(...args) {\n    const err = {\n      name: 'Trace',\n      message: this[kFormatForStderr](args),\n    };\n    ErrorCaptureStackTrace(err, trace);\n    this.error(err.stack);\n  },\n\n  assert(expression, ...args) {\n    if (!expression) {\n      args[0] = `Assertion failed${args.length === 0 ? '' : `: ${args[0]}`}`;\n      // The arguments will be formatted in warn() again\n      ReflectApply(this.warn, this, args);\n    }\n  },\n\n  // Defined by: https://console.spec.whatwg.org/#clear\n  clear() {\n    // It only makes sense to clear if _stdout is a TTY.\n    // Otherwise, do nothing.\n    if (this._stdout.isTTY && process.env.TERM !== 'dumb') {\n      // The require is here intentionally to avoid readline being\n      // required too early when console is first loaded.\n      const {\n        cursorTo,\n        clearScreenDown,\n      } = require('internal/readline/callbacks');\n      cursorTo(this._stdout, 0, 0);\n      clearScreenDown(this._stdout);\n    }\n  },\n\n  // Defined by: https://console.spec.whatwg.org/#count\n  count(label = 'default') {\n    // Ensures that label is a string, and only things that can be\n    // coerced to strings. e.g. Symbol is not allowed\n    label = `${label}`;\n    const counts = this[kCounts];\n    let count = counts.get(label);\n    if (count === undefined)\n      count = 1;\n    else\n      count++;\n    counts.set(label, count);\n    trace(kTraceCount, kTraceConsoleCategory, `count::${label}`, 0, count);\n    this.log(`${label}: ${count}`);\n  },\n\n  // Defined by: https://console.spec.whatwg.org/#countreset\n  countReset(label = 'default') {\n    const counts = this[kCounts];\n    if (!counts.has(label)) {\n      process.emitWarning(`Count for '${label}' does not exist`);\n      return;\n    }\n    trace(kTraceCount, kTraceConsoleCategory, `count::${label}`, 0, 0);\n    counts.delete(`${label}`);\n  },\n\n  group(...data) {\n    if (data.length > 0) {\n      ReflectApply(this.log, this, data);\n    }\n    this[kGroupIndent] +=\n      StringPrototypeRepeat(' ', this[kGroupIndentationWidth]);\n  },\n\n  groupEnd() {\n    this[kGroupIndent] = StringPrototypeSlice(\n      this[kGroupIndent],\n      0,\n      this[kGroupIndent].length - this[kGroupIndentationWidth],\n    );\n  },\n\n  // https://console.spec.whatwg.org/#table\n  table(tabularData, properties) {\n    if (properties !== undefined)\n      validateArray(properties, 'properties');\n\n    if (tabularData === null || typeof tabularData !== 'object')\n      return this.log(tabularData);\n\n    cliTable ??= require('internal/cli_table');\n    const final = (k, v) => this.log(cliTable(k, v));\n\n    const _inspect = (v) => {\n      const depth = v !== null &&\n                    typeof v === 'object' &&\n                    !isArray(v) &&\n                    ObjectKeys(v).length > 2 ? -1 : 0;\n      const opt = {\n        depth,\n        maxArrayLength: 3,\n        breakLength: Infinity,\n        ...this[kGetInspectOptions](this._stdout),\n      };\n      return inspect(v, opt);\n    };\n    const getIndexArray = (length) => ArrayFrom(\n      { length }, (_, i) => _inspect(i));\n\n    const mapIter = isMapIterator(tabularData);\n    let isKeyValue = false;\n    let i = 0;\n    if (mapIter) {\n      const res = previewEntries(tabularData, true);\n      tabularData = res[0];\n      isKeyValue = res[1];\n    }\n\n    if (isKeyValue || isMap(tabularData)) {\n      const keys = [];\n      const values = [];\n      let length = 0;\n      if (mapIter) {\n        for (; i < tabularData.length / 2; ++i) {\n          ArrayPrototypePush(keys, _inspect(tabularData[i * 2]));\n          ArrayPrototypePush(values, _inspect(tabularData[i * 2 + 1]));\n          length++;\n        }\n      } else {\n        for (const { 0: k, 1: v } of tabularData) {\n          ArrayPrototypePush(keys, _inspect(k));\n          ArrayPrototypePush(values, _inspect(v));\n          length++;\n        }\n      }\n      return final([\n        iterKey, keyKey, valuesKey,\n      ], [\n        getIndexArray(length),\n        keys,\n        values,\n      ]);\n    }\n\n    const setIter = isSetIterator(tabularData);\n    if (setIter)\n      tabularData = previewEntries(tabularData);\n\n    const setlike = setIter || mapIter || isSet(tabularData);\n    if (setlike) {\n      const values = [];\n      let length = 0;\n      for (const v of tabularData) {\n        ArrayPrototypePush(values, _inspect(v));\n        length++;\n      }\n      return final([iterKey, valuesKey], [getIndexArray(length), values]);\n    }\n\n    const map = { __proto__: null };\n    let hasPrimitives = false;\n    const valuesKeyArray = [];\n    const indexKeyArray = ObjectKeys(tabularData);\n\n    for (; i < indexKeyArray.length; i++) {\n      const item = tabularData[indexKeyArray[i]];\n      const primitive = item === null ||\n          (typeof item !== 'function' && typeof item !== 'object');\n      if (properties === undefined && primitive) {\n        hasPrimitives = true;\n        valuesKeyArray[i] = _inspect(item);\n      } else {\n        const keys = properties || ObjectKeys(item);\n        for (const key of keys) {\n          map[key] ??= [];\n          if ((primitive && properties) ||\n               !ObjectPrototypeHasOwnProperty(item, key))\n            map[key][i] = '';\n          else\n            map[key][i] = _inspect(item[key]);\n        }\n      }\n    }\n\n    const keys = ObjectKeys(map);\n    const values = ObjectValues(map);\n    if (hasPrimitives) {\n      ArrayPrototypePush(keys, valuesKey);\n      ArrayPrototypePush(values, valuesKeyArray);\n    }\n    ArrayPrototypeUnshift(keys, indexKey);\n    ArrayPrototypeUnshift(values, indexKeyArray);\n\n    return final(keys, values);\n  },\n};\n\n// Returns true if label was found\nfunction timeLogImpl(self, name, label, data) {\n  const time = self._times.get(label);\n  if (time === undefined) {\n    process.emitWarning(`No such label '${label}' for console.${name}()`);\n    return false;\n  }\n  const duration = process.hrtime(time);\n  const ms = duration[0] * 1000 + duration[1] / 1e6;\n\n  const formatted = formatTime(ms);\n\n  if (data === undefined) {\n    self.log('%s: %s', label, formatted);\n  } else {\n    self.log('%s: %s', label, formatted, ...new SafeArrayIterator(data));\n  }\n  return true;\n}\n\nfunction pad(value) {\n  return StringPrototypePadStart(`${value}`, 2, '0');\n}\n\nfunction formatTime(ms) {\n  let hours = 0;\n  let minutes = 0;\n  let seconds = 0;\n\n  if (ms >= kSecond) {\n    if (ms >= kMinute) {\n      if (ms >= kHour) {\n        hours = MathFloor(ms / kHour);\n        ms = ms % kHour;\n      }\n      minutes = MathFloor(ms / kMinute);\n      ms = ms % kMinute;\n    }\n    seconds = ms / kSecond;\n  }\n\n  if (hours !== 0 || minutes !== 0) {\n    ({ 0: seconds, 1: ms } = StringPrototypeSplit(\n      NumberPrototypeToFixed(seconds, 3),\n      '.',\n    ));\n    const res = hours !== 0 ? `${hours}:${pad(minutes)}` : minutes;\n    return `${res}:${pad(seconds)}.${ms} (${hours !== 0 ? 'h:m' : ''}m:ss.mmm)`;\n  }\n\n  if (seconds !== 0) {\n    return `${NumberPrototypeToFixed(seconds, 3)}s`;\n  }\n\n  return `${Number(NumberPrototypeToFixed(ms, 3))}ms`;\n}\n\nconst keyKey = 'Key';\nconst valuesKey = 'Values';\nconst indexKey = '(index)';\nconst iterKey = '(iteration index)';\n\nconst isArray = (v) => ArrayIsArray(v) || isTypedArray(v) || isBuffer(v);\n\nfunction noop() {}\n\nfor (const method of ReflectOwnKeys(consoleMethods))\n  Console.prototype[method] = consoleMethods[method];\n\nConsole.prototype.debug = Console.prototype.log;\nConsole.prototype.info = Console.prototype.log;\nConsole.prototype.dirxml = Console.prototype.log;\nConsole.prototype.error = Console.prototype.warn;\nConsole.prototype.groupCollapsed = Console.prototype.group;\n\nfunction initializeGlobalConsole(globalConsole) {\n  globalConsole[kBindStreamsLazy](process);\n  globalConsole[kBindProperties](true, 'auto');\n\n  const {\n    namespace: {\n      addSerializeCallback,\n      isBuildingSnapshot,\n    },\n  } = require('internal/v8/startup_snapshot');\n\n  if (!internalBinding('config').hasInspector || !isBuildingSnapshot()) {\n    return;\n  }\n  const { console: consoleFromVM } = internalBinding('inspector');\n  const nodeConsoleKeys = ObjectKeys(Console.prototype);\n  const vmConsoleKeys = ObjectKeys(consoleFromVM);\n  const originalKeys = new SafeSet(vmConsoleKeys.concat(nodeConsoleKeys));\n  const inspectorConsoleKeys = new SafeSet();\n  for (const key of ObjectKeys(globalConsole)) {\n    if (!originalKeys.has(key)) {\n      inspectorConsoleKeys.add(key);\n    }\n  }\n  // During deserialization these should be reinstalled to console by\n  // V8 when the inspector client is created.\n  addSerializeCallback(() => {\n    for (const key of inspectorConsoleKeys) {\n      globalConsole[key] = undefined;\n    }\n  });\n}\n\nmodule.exports = {\n  Console,\n  kBindStreamsLazy,\n  kBindProperties,\n  initializeGlobalConsole,\n  formatTime, // exported for tests\n};\n"
    },
    "112": {
      "sourceCode": "'use strict';\n\nlet internalTTy;\nfunction lazyInternalTTY() {\n  internalTTy ??= require('internal/tty');\n  return internalTTy;\n}\n\nmodule.exports = {\n  blue: '',\n  green: '',\n  white: '',\n  red: '',\n  gray: '',\n  clear: '',\n  hasColors: false,\n  shouldColorize(stream) {\n    if (process.env.FORCE_COLOR !== undefined) {\n      return lazyInternalTTY().getColorDepth() > 2;\n    }\n    return stream?.isTTY && (\n      typeof stream.getColorDepth === 'function' ?\n        stream.getColorDepth() > 2 : true);\n  },\n  refresh() {\n    if (process.stderr.isTTY) {\n      const hasColors = module.exports.shouldColorize(process.stderr);\n      module.exports.blue = hasColors ? '\\u001b[34m' : '';\n      module.exports.green = hasColors ? '\\u001b[32m' : '';\n      module.exports.white = hasColors ? '\\u001b[39m' : '';\n      module.exports.yellow = hasColors ? '\\u001b[33m' : '';\n      module.exports.red = hasColors ? '\\u001b[31m' : '';\n      module.exports.gray = hasColors ? '\\u001b[90m' : '';\n      module.exports.clear = hasColors ? '\\u001bc' : '';\n      module.exports.hasColors = hasColors;\n    }\n  },\n};\n\nmodule.exports.refresh();\n"
    },
    "114": {
      "sourceCode": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeIndexOf,\n  ArrayPrototypePush,\n  Boolean,\n  FunctionPrototypeBind,\n  FunctionPrototypeCall,\n  MathMax,\n  Number,\n  NumberIsNaN,\n  NumberParseInt,\n  ObjectDefineProperty,\n  ObjectSetPrototypeOf,\n  Symbol,\n  SymbolAsyncDispose,\n  SymbolDispose,\n} = primordials;\n\nconst EventEmitter = require('events');\nconst stream = require('stream');\nlet debug = require('internal/util/debuglog').debuglog('net', (fn) => {\n  debug = fn;\n});\nconst {\n  kReinitializeHandle,\n  isIP,\n  isIPv4,\n  isIPv6,\n  normalizedArgsSymbol,\n  makeSyncWrite,\n} = require('internal/net');\nconst assert = require('internal/assert');\nconst {\n  UV_EADDRINUSE,\n  UV_EINVAL,\n  UV_ENOTCONN,\n  UV_ECANCELED,\n  UV_ETIMEDOUT,\n} = internalBinding('uv');\n\nconst { Buffer } = require('buffer');\nconst { ShutdownWrap } = internalBinding('stream_wrap');\nconst {\n  TCP,\n  TCPConnectWrap,\n  constants: TCPConstants,\n} = internalBinding('tcp_wrap');\nconst {\n  Pipe,\n  PipeConnectWrap,\n  constants: PipeConstants,\n} = internalBinding('pipe_wrap');\nconst {\n  newAsyncId,\n  defaultTriggerAsyncIdScope,\n  symbols: { async_id_symbol, owner_symbol },\n} = require('internal/async_hooks');\nconst {\n  writevGeneric,\n  writeGeneric,\n  onStreamRead,\n  kAfterAsyncWrite,\n  kHandle,\n  kUpdateTimer,\n  setStreamTimeout,\n  kBuffer,\n  kBufferCb,\n  kBufferGen,\n} = require('internal/stream_base_commons');\nconst {\n  codes: {\n    ERR_INVALID_ADDRESS_FAMILY,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_FD_TYPE,\n    ERR_INVALID_IP_ADDRESS,\n    ERR_INVALID_HANDLE_TYPE,\n    ERR_SERVER_ALREADY_LISTEN,\n    ERR_SERVER_NOT_RUNNING,\n    ERR_SOCKET_CONNECTION_TIMEOUT,\n    ERR_SOCKET_CLOSED,\n    ERR_SOCKET_CLOSED_BEFORE_CONNECTION,\n    ERR_MISSING_ARGS,\n  },\n  aggregateErrors,\n  errnoException,\n  exceptionWithHostPort,\n  genericNodeError,\n  uvExceptionWithHostPort,\n} = require('internal/errors');\nconst { isUint8Array } = require('internal/util/types');\nconst { queueMicrotask } = require('internal/process/task_queues');\nconst { kEmptyObject, guessHandleType, promisify } = require('internal/util');\nconst {\n  validateAbortSignal,\n  validateBoolean,\n  validateFunction,\n  validateInt32,\n  validateNumber,\n  validatePort,\n  validateString,\n} = require('internal/validators');\nconst kLastWriteQueueSize = Symbol('lastWriteQueueSize');\nconst { getOptionValue } = require('internal/options');\n\n// Lazy loaded to improve startup performance.\nlet cluster;\nlet dns;\nlet BlockList;\nlet SocketAddress;\nlet autoSelectFamilyDefault = getOptionValue('--network-family-autoselection');\nlet autoSelectFamilyAttemptTimeoutDefault = 250;\n\nconst { clearTimeout, setTimeout } = require('timers');\nconst { kTimeout } = require('internal/timers');\n\nconst DEFAULT_IPV4_ADDR = '0.0.0.0';\nconst DEFAULT_IPV6_ADDR = '::';\n\nconst isWindows = process.platform === 'win32';\n\nconst noop = () => {};\n\nconst kPerfHooksNetConnectContext = Symbol('kPerfHooksNetConnectContext');\n\nconst dc = require('diagnostics_channel');\nconst netClientSocketChannel = dc.channel('net.client.socket');\nconst netServerSocketChannel = dc.channel('net.server.socket');\n\nconst {\n  hasObserver,\n  startPerf,\n  stopPerf,\n} = require('internal/perf/observe');\nconst { getDefaultHighWaterMark } = require('internal/streams/state');\n\nfunction getFlags(ipv6Only) {\n  return ipv6Only === true ? TCPConstants.UV_TCP_IPV6ONLY : 0;\n}\n\nfunction createHandle(fd, is_server) {\n  validateInt32(fd, 'fd', 0);\n  const type = guessHandleType(fd);\n  if (type === 'PIPE') {\n    return new Pipe(\n      is_server ? PipeConstants.SERVER : PipeConstants.SOCKET,\n    );\n  }\n\n  if (type === 'TCP') {\n    return new TCP(\n      is_server ? TCPConstants.SERVER : TCPConstants.SOCKET,\n    );\n  }\n\n  throw new ERR_INVALID_FD_TYPE(type);\n}\n\n\nfunction getNewAsyncId(handle) {\n  return (!handle || typeof handle.getAsyncId !== 'function') ?\n    newAsyncId() : handle.getAsyncId();\n}\n\n\nfunction isPipeName(s) {\n  return typeof s === 'string' && toNumber(s) === false;\n}\n\n/**\n * Creates a new TCP or IPC server\n * @param {{\n *   allowHalfOpen?: boolean;\n *   pauseOnConnect?: boolean;\n *   }} [options]\n * @param {Function} [connectionListener]\n * @returns {Server}\n */\n\nfunction createServer(options, connectionListener) {\n  return new Server(options, connectionListener);\n}\n\n\n// Target API:\n//\n// let s = net.connect({port: 80, host: 'google.com'}, function() {\n//   ...\n// });\n//\n// There are various forms:\n//\n// connect(options, [cb])\n// connect(port, [host], [cb])\n// connect(path, [cb]);\n//\nfunction connect(...args) {\n  const normalized = normalizeArgs(args);\n  const options = normalized[0];\n  debug('createConnection', normalized);\n  const socket = new Socket(options);\n\n  if (netClientSocketChannel.hasSubscribers) {\n    netClientSocketChannel.publish({\n      socket,\n    });\n  }\n  if (options.timeout) {\n    socket.setTimeout(options.timeout);\n  }\n\n  return socket.connect(normalized);\n}\n\nfunction getDefaultAutoSelectFamily() {\n  return autoSelectFamilyDefault;\n}\n\nfunction setDefaultAutoSelectFamily(value) {\n  validateBoolean(value, 'value');\n  autoSelectFamilyDefault = value;\n}\n\nfunction getDefaultAutoSelectFamilyAttemptTimeout() {\n  return autoSelectFamilyAttemptTimeoutDefault;\n}\n\nfunction setDefaultAutoSelectFamilyAttemptTimeout(value) {\n  validateInt32(value, 'value', 1);\n\n  if (value < 10) {\n    value = 10;\n  }\n\n  autoSelectFamilyAttemptTimeoutDefault = value;\n}\n\n// Returns an array [options, cb], where options is an object,\n// cb is either a function or null.\n// Used to normalize arguments of Socket.prototype.connect() and\n// Server.prototype.listen(). Possible combinations of parameters:\n//   (options[...][, cb])\n//   (path[...][, cb])\n//   ([port][, host][...][, cb])\n// For Socket.prototype.connect(), the [...] part is ignored\n// For Server.prototype.listen(), the [...] part is [, backlog]\n// but will not be handled here (handled in listen())\nfunction normalizeArgs(args) {\n  let arr;\n\n  if (args.length === 0) {\n    arr = [{}, null];\n    arr[normalizedArgsSymbol] = true;\n    return arr;\n  }\n\n  const arg0 = args[0];\n  let options = {};\n  if (typeof arg0 === 'object' && arg0 !== null) {\n    // (options[...][, cb])\n    options = arg0;\n  } else if (isPipeName(arg0)) {\n    // (path[...][, cb])\n    options.path = arg0;\n  } else {\n    // ([port][, host][...][, cb])\n    options.port = arg0;\n    if (args.length > 1 && typeof args[1] === 'string') {\n      options.host = args[1];\n    }\n  }\n\n  const cb = args[args.length - 1];\n  if (typeof cb !== 'function')\n    arr = [options, null];\n  else\n    arr = [options, cb];\n\n  arr[normalizedArgsSymbol] = true;\n  return arr;\n}\n\n\n// Called when creating new Socket, or when re-using a closed Socket\nfunction initSocketHandle(self) {\n  self._undestroy();\n  self._sockname = null;\n\n  // Handle creation may be deferred to bind() or connect() time.\n  if (self._handle) {\n    self._handle[owner_symbol] = self;\n    self._handle.onread = onStreamRead;\n    self[async_id_symbol] = getNewAsyncId(self._handle);\n\n    let userBuf = self[kBuffer];\n    if (userBuf) {\n      const bufGen = self[kBufferGen];\n      if (bufGen !== null) {\n        userBuf = bufGen();\n        if (!isUint8Array(userBuf))\n          return;\n        self[kBuffer] = userBuf;\n      }\n      self._handle.useUserBuffer(userBuf);\n    }\n  }\n}\n\nfunction closeSocketHandle(self, isException, isCleanupPending = false) {\n  if (self._handle) {\n    self._handle.close(() => {\n      debug('emit close');\n      self.emit('close', isException);\n      if (isCleanupPending) {\n        self._handle.onread = noop;\n        self._handle = null;\n        self._sockname = null;\n      }\n    });\n  }\n}\n\nconst kBytesRead = Symbol('kBytesRead');\nconst kBytesWritten = Symbol('kBytesWritten');\nconst kSetNoDelay = Symbol('kSetNoDelay');\nconst kSetKeepAlive = Symbol('kSetKeepAlive');\nconst kSetKeepAliveInitialDelay = Symbol('kSetKeepAliveInitialDelay');\n\nfunction Socket(options) {\n  if (!(this instanceof Socket)) return new Socket(options);\n  if (options?.objectMode) {\n    throw new ERR_INVALID_ARG_VALUE(\n      'options.objectMode',\n      options.objectMode,\n      'is not supported',\n    );\n  } else if (options?.readableObjectMode || options?.writableObjectMode) {\n    throw new ERR_INVALID_ARG_VALUE(\n      `options.${\n        options.readableObjectMode ? 'readableObjectMode' : 'writableObjectMode'\n      }`,\n      options.readableObjectMode || options.writableObjectMode,\n      'is not supported',\n    );\n  }\n  if (typeof options?.keepAliveInitialDelay !== 'undefined') {\n    validateNumber(\n      options?.keepAliveInitialDelay, 'options.keepAliveInitialDelay',\n    );\n\n    if (options.keepAliveInitialDelay < 0) {\n      options.keepAliveInitialDelay = 0;\n    }\n  }\n\n  this.connecting = false;\n  // Problem with this is that users can supply their own handle, that may not\n  // have _handle.getAsyncId(). In this case an[async_id_symbol] should\n  // probably be supplied by async_hooks.\n  this[async_id_symbol] = -1;\n  this._hadError = false;\n  this[kHandle] = null;\n  this._parent = null;\n  this._host = null;\n  this[kLastWriteQueueSize] = 0;\n  this[kTimeout] = null;\n  this[kBuffer] = null;\n  this[kBufferCb] = null;\n  this[kBufferGen] = null;\n  this._closeAfterHandlingError = false;\n\n  if (typeof options === 'number')\n    options = { fd: options }; // Legacy interface.\n  else\n    options = { ...options };\n\n  // Default to *not* allowing half open sockets.\n  options.allowHalfOpen = Boolean(options.allowHalfOpen);\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  options.autoDestroy = true;\n  // Handle strings directly.\n  options.decodeStrings = false;\n  stream.Duplex.call(this, options);\n\n  if (options.handle) {\n    this._handle = options.handle; // private\n    this[async_id_symbol] = getNewAsyncId(this._handle);\n  } else if (options.fd !== undefined) {\n    const { fd } = options;\n    let err;\n\n    // createHandle will throw ERR_INVALID_FD_TYPE if `fd` is not\n    // a valid `PIPE` or `TCP` descriptor\n    this._handle = createHandle(fd, false);\n\n    err = this._handle.open(fd);\n\n    // While difficult to fabricate, in some architectures\n    // `open` may return an error code for valid file descriptors\n    // which cannot be opened. This is difficult to test as most\n    // un-openable fds will throw on `createHandle`\n    if (err)\n      throw errnoException(err, 'open');\n\n    this[async_id_symbol] = this._handle.getAsyncId();\n\n    if ((fd === 1 || fd === 2) &&\n        (this._handle instanceof Pipe) && isWindows) {\n      // Make stdout and stderr blocking on Windows\n      err = this._handle.setBlocking(true);\n      if (err)\n        throw errnoException(err, 'setBlocking');\n\n      this._writev = null;\n      this._write = makeSyncWrite(fd);\n      // makeSyncWrite adjusts this value like the original handle would, so\n      // we need to let it do that by turning it into a writable, own\n      // property.\n      ObjectDefineProperty(this._handle, 'bytesWritten', {\n        __proto__: null,\n        value: 0, writable: true,\n      });\n    }\n  }\n\n  const onread = options.onread;\n  if (onread !== null && typeof onread === 'object' &&\n      (isUint8Array(onread.buffer) || typeof onread.buffer === 'function') &&\n      typeof onread.callback === 'function') {\n    if (typeof onread.buffer === 'function') {\n      this[kBuffer] = true;\n      this[kBufferGen] = onread.buffer;\n    } else {\n      this[kBuffer] = onread.buffer;\n    }\n    this[kBufferCb] = onread.callback;\n  }\n\n  this[kSetNoDelay] = Boolean(options.noDelay);\n  this[kSetKeepAlive] = Boolean(options.keepAlive);\n  this[kSetKeepAliveInitialDelay] = ~~(options.keepAliveInitialDelay / 1000);\n\n  // Shut down the socket when we're finished with it.\n  this.on('end', onReadableStreamEnd);\n\n  initSocketHandle(this);\n\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  // If we have a handle, then start the flow of data into the\n  // buffer.  if not, then this will happen when we connect\n  if (this._handle && options.readable !== false) {\n    if (options.pauseOnCreate) {\n      // Stop the handle from reading and pause the stream\n      this._handle.reading = false;\n      this._handle.readStop();\n      this.readableFlowing = false;\n    } else if (!options.manualStart) {\n      this.read(0);\n    }\n  }\n\n  if (options.signal) {\n    addClientAbortSignalOption(this, options);\n  }\n\n  // Reserve properties\n  this.server = null;\n  this._server = null;\n\n  // Used after `.destroy()`\n  this[kBytesRead] = 0;\n  this[kBytesWritten] = 0;\n}\nObjectSetPrototypeOf(Socket.prototype, stream.Duplex.prototype);\nObjectSetPrototypeOf(Socket, stream.Duplex);\n\n// Refresh existing timeouts.\nSocket.prototype._unrefTimer = function _unrefTimer() {\n  for (let s = this; s !== null; s = s._parent) {\n    if (s[kTimeout])\n      s[kTimeout].refresh();\n  }\n};\n\n\n// The user has called .end(), and all the bytes have been\n// sent out to the other side.\nSocket.prototype._final = function(cb) {\n  // If still connecting - defer handling `_final` until 'connect' will happen\n  if (this.pending) {\n    debug('_final: not yet connected');\n    return this.once('connect', () => this._final(cb));\n  }\n\n  if (!this._handle)\n    return cb();\n\n  debug('_final: not ended, call shutdown()');\n\n  const req = new ShutdownWrap();\n  req.oncomplete = afterShutdown;\n  req.handle = this._handle;\n  req.callback = cb;\n  const err = this._handle.shutdown(req);\n\n  if (err === 1 || err === UV_ENOTCONN)  // synchronous finish\n    return cb();\n  else if (err !== 0)\n    return cb(errnoException(err, 'shutdown'));\n};\n\nfunction afterShutdown() {\n  const self = this.handle[owner_symbol];\n\n  debug('afterShutdown destroyed=%j', self.destroyed);\n\n  this.callback();\n}\n\n// Provide a better error message when we call end() as a result\n// of the other side sending a FIN.  The standard 'write after end'\n// is overly vague, and makes it seem like the user's code is to blame.\nfunction writeAfterFIN(chunk, encoding, cb) {\n  if (!this.writableEnded) {\n    return stream.Duplex.prototype.write.call(this, chunk, encoding, cb);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  const er = genericNodeError(\n    'This socket has been ended by the other party',\n    { code: 'EPIPE' },\n  );\n  if (typeof cb === 'function') {\n    defaultTriggerAsyncIdScope(this[async_id_symbol], process.nextTick, cb, er);\n  }\n  this.destroy(er);\n\n  return false;\n}\n\nSocket.prototype.setTimeout = setStreamTimeout;\n\n\nSocket.prototype._onTimeout = function() {\n  const handle = this._handle;\n  const lastWriteQueueSize = this[kLastWriteQueueSize];\n  if (lastWriteQueueSize > 0 && handle) {\n    // `lastWriteQueueSize !== writeQueueSize` means there is\n    // an active write in progress, so we suppress the timeout.\n    const { writeQueueSize } = handle;\n    if (lastWriteQueueSize !== writeQueueSize) {\n      this[kLastWriteQueueSize] = writeQueueSize;\n      this._unrefTimer();\n      return;\n    }\n  }\n  debug('_onTimeout');\n  this.emit('timeout');\n};\n\n\nSocket.prototype.setNoDelay = function(enable) {\n  // Backwards compatibility: assume true when `enable` is omitted\n  enable = Boolean(enable === undefined ? true : enable);\n\n  if (!this._handle) {\n    this[kSetNoDelay] = enable;\n    return this;\n  }\n\n  if (this._handle.setNoDelay && enable !== this[kSetNoDelay]) {\n    this[kSetNoDelay] = enable;\n    this._handle.setNoDelay(enable);\n  }\n\n  return this;\n};\n\n\nSocket.prototype.setKeepAlive = function(enable, initialDelayMsecs) {\n  enable = Boolean(enable);\n  const initialDelay = ~~(initialDelayMsecs / 1000);\n\n  if (!this._handle) {\n    this[kSetKeepAlive] = enable;\n    this[kSetKeepAliveInitialDelay] = initialDelay;\n    return this;\n  }\n\n  if (!this._handle.setKeepAlive) {\n    return this;\n  }\n\n  if (enable !== this[kSetKeepAlive] ||\n      (\n        enable &&\n        this[kSetKeepAliveInitialDelay] !== initialDelay\n      )\n  ) {\n    this[kSetKeepAlive] = enable;\n    this[kSetKeepAliveInitialDelay] = initialDelay;\n    this._handle.setKeepAlive(enable, initialDelay);\n  }\n\n  return this;\n};\n\n\nSocket.prototype.address = function() {\n  return this._getsockname();\n};\n\n\nObjectDefineProperty(Socket.prototype, '_connecting', {\n  __proto__: null,\n  get: function() {\n    return this.connecting;\n  },\n});\n\nObjectDefineProperty(Socket.prototype, 'pending', {\n  __proto__: null,\n  get() {\n    return !this._handle || this.connecting;\n  },\n  configurable: true,\n});\n\n\nObjectDefineProperty(Socket.prototype, 'readyState', {\n  __proto__: null,\n  get: function() {\n    if (this.connecting) {\n      return 'opening';\n    } else if (this.readable && this.writable) {\n      return 'open';\n    } else if (this.readable && !this.writable) {\n      return 'readOnly';\n    } else if (!this.readable && this.writable) {\n      return 'writeOnly';\n    }\n    return 'closed';\n  },\n});\n\n\nObjectDefineProperty(Socket.prototype, 'bufferSize', {\n  __proto__: null,\n  get: function() {\n    if (this._handle) {\n      return this.writableLength;\n    }\n  },\n});\n\nObjectDefineProperty(Socket.prototype, kUpdateTimer, {\n  __proto__: null,\n  get: function() {\n    return this._unrefTimer;\n  },\n});\n\n\nfunction tryReadStart(socket) {\n  // Not already reading, start the flow\n  debug('Socket._handle.readStart');\n  socket._handle.reading = true;\n  const err = socket._handle.readStart();\n  if (err)\n    socket.destroy(errnoException(err, 'read'));\n}\n\n// Just call handle.readStart until we have enough in the buffer\nSocket.prototype._read = function(n) {\n  debug(\n    '_read - n', n,\n    'isConnecting?', !!this.connecting,\n    'hasHandle?', !!this._handle,\n  );\n\n  if (this.connecting || !this._handle) {\n    debug('_read wait for connection');\n    this.once('connect', () => this._read(n));\n  } else if (!this._handle.reading) {\n    tryReadStart(this);\n  }\n};\n\n\nSocket.prototype.end = function(data, encoding, callback) {\n  stream.Duplex.prototype.end.call(this,\n                                   data, encoding, callback);\n  return this;\n};\n\nSocket.prototype.resetAndDestroy = function() {\n  if (this._handle) {\n    if (!(this._handle instanceof TCP))\n      throw new ERR_INVALID_HANDLE_TYPE();\n    if (this.connecting) {\n      debug('reset wait for connection');\n      this.once('connect', () => this._reset());\n    } else {\n      this._reset();\n    }\n  } else {\n    this.destroy(new ERR_SOCKET_CLOSED());\n  }\n  return this;\n};\n\nSocket.prototype.pause = function() {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      this._handle.reading) {\n    this._handle.reading = false;\n    if (!this.destroyed) {\n      const err = this._handle.readStop();\n      if (err)\n        this.destroy(errnoException(err, 'read'));\n    }\n  }\n  return stream.Duplex.prototype.pause.call(this);\n};\n\n\nSocket.prototype.resume = function() {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.resume.call(this);\n};\n\n\nSocket.prototype.read = function(n) {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.read.call(this, n);\n};\n\n\n// Called when the 'end' event is emitted.\nfunction onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n  }\n}\n\n\nSocket.prototype.destroySoon = function() {\n  if (this.writable)\n    this.end();\n\n  if (this.writableFinished)\n    this.destroy();\n  else\n    this.once('finish', this.destroy);\n};\n\n\nSocket.prototype._destroy = function(exception, cb) {\n  debug('destroy');\n\n  this.connecting = false;\n\n  for (let s = this; s !== null; s = s._parent) {\n    clearTimeout(s[kTimeout]);\n  }\n\n  debug('close');\n  if (this._handle) {\n    if (this !== process.stderr)\n      debug('close handle');\n    const isException = exception ? true : false;\n    // `bytesRead` and `kBytesWritten` should be accessible after `.destroy()`\n    this[kBytesRead] = this._handle.bytesRead;\n    this[kBytesWritten] = this._handle.bytesWritten;\n\n    if (this.resetAndClosing) {\n      this.resetAndClosing = false;\n      const err = this._handle.reset(() => {\n        debug('emit close');\n        this.emit('close', isException);\n      });\n      if (err)\n        this.emit('error', errnoException(err, 'reset'));\n    } else if (this._closeAfterHandlingError) {\n      // Enqueue closing the socket as a microtask, so that the socket can be\n      // accessible when an `error` event is handled in the `next tick queue`.\n      queueMicrotask(() => closeSocketHandle(this, isException, true));\n    } else {\n      closeSocketHandle(this, isException);\n    }\n\n    if (!this._closeAfterHandlingError) {\n      this._handle.onread = noop;\n      this._handle = null;\n      this._sockname = null;\n    }\n    cb(exception);\n  } else {\n    cb(exception);\n    process.nextTick(emitCloseNT, this);\n  }\n\n  if (this._server) {\n    debug('has server');\n    this._server._connections--;\n    if (this._server._emitCloseIfDrained) {\n      this._server._emitCloseIfDrained();\n    }\n  }\n};\n\nSocket.prototype._reset = function() {\n  debug('reset connection');\n  this.resetAndClosing = true;\n  return this.destroy();\n};\n\nSocket.prototype._getpeername = function() {\n  if (!this._handle || !this._handle.getpeername || this.connecting) {\n    return this._peername || {};\n  } else if (!this._peername) {\n    const out = {};\n    const err = this._handle.getpeername(out);\n    if (err) return out;\n    this._peername = out;\n  }\n  return this._peername;\n};\n\nfunction protoGetter(name, callback) {\n  ObjectDefineProperty(Socket.prototype, name, {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    get: callback,\n  });\n}\n\nprotoGetter('bytesRead', function bytesRead() {\n  return this._handle ? this._handle.bytesRead : this[kBytesRead];\n});\n\nprotoGetter('remoteAddress', function remoteAddress() {\n  return this._getpeername().address;\n});\n\nprotoGetter('remoteFamily', function remoteFamily() {\n  return this._getpeername().family;\n});\n\nprotoGetter('remotePort', function remotePort() {\n  return this._getpeername().port;\n});\n\n\nSocket.prototype._getsockname = function() {\n  if (!this._handle || !this._handle.getsockname) {\n    return {};\n  } else if (!this._sockname) {\n    this._sockname = {};\n    // FIXME(bnoordhuis) Throw when the return value is not 0?\n    this._handle.getsockname(this._sockname);\n  }\n  return this._sockname;\n};\n\n\nprotoGetter('localAddress', function localAddress() {\n  return this._getsockname().address;\n});\n\n\nprotoGetter('localPort', function localPort() {\n  return this._getsockname().port;\n});\n\nprotoGetter('localFamily', function localFamily() {\n  return this._getsockname().family;\n});\n\nSocket.prototype[kAfterAsyncWrite] = function() {\n  this[kLastWriteQueueSize] = 0;\n};\n\nSocket.prototype._writeGeneric = function(writev, data, encoding, cb) {\n  // If we are still connecting, then buffer this for later.\n  // The Writable logic will buffer up any more writes while\n  // waiting for this one to be done.\n  if (this.connecting) {\n    this._pendingData = data;\n    this._pendingEncoding = encoding;\n    this.once('connect', function connect() {\n      this.off('close', onClose);\n      this._writeGeneric(writev, data, encoding, cb);\n    });\n    function onClose() {\n      cb(new ERR_SOCKET_CLOSED_BEFORE_CONNECTION());\n    }\n    this.once('close', onClose);\n    return;\n  }\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  if (!this._handle) {\n    cb(new ERR_SOCKET_CLOSED());\n    return false;\n  }\n\n  this._unrefTimer();\n\n  let req;\n  if (writev)\n    req = writevGeneric(this, data, cb);\n  else\n    req = writeGeneric(this, data, encoding, cb);\n  if (req.async)\n    this[kLastWriteQueueSize] = req.bytes;\n};\n\n\nSocket.prototype._writev = function(chunks, cb) {\n  this._writeGeneric(true, chunks, '', cb);\n};\n\n\nSocket.prototype._write = function(data, encoding, cb) {\n  this._writeGeneric(false, data, encoding, cb);\n};\n\n\n// Legacy alias. Having this is probably being overly cautious, but it doesn't\n// really hurt anyone either. This can probably be removed safely if desired.\nprotoGetter('_bytesDispatched', function _bytesDispatched() {\n  return this._handle ? this._handle.bytesWritten : this[kBytesWritten];\n});\n\nprotoGetter('bytesWritten', function bytesWritten() {\n  let bytes = this._bytesDispatched;\n  const data = this._pendingData;\n  const encoding = this._pendingEncoding;\n  const writableBuffer = this.writableBuffer;\n\n  if (!writableBuffer)\n    return undefined;\n\n  for (const el of writableBuffer) {\n    bytes += el.chunk instanceof Buffer ?\n      el.chunk.length :\n      Buffer.byteLength(el.chunk, el.encoding);\n  }\n\n  if (ArrayIsArray(data)) {\n    // Was a writev, iterate over chunks to get total length\n    for (let i = 0; i < data.length; i++) {\n      const chunk = data[i];\n\n      if (data.allBuffers || chunk instanceof Buffer)\n        bytes += chunk.length;\n      else\n        bytes += Buffer.byteLength(chunk.chunk, chunk.encoding);\n    }\n  } else if (data) {\n    // Writes are either a string or a Buffer.\n    if (typeof data !== 'string')\n      bytes += data.length;\n    else\n      bytes += Buffer.byteLength(data, encoding);\n  }\n\n  return bytes;\n});\n\n\nfunction checkBindError(err, port, handle) {\n  // EADDRINUSE may not be reported until we call listen() or connect().\n  // To complicate matters, a failed bind() followed by listen() or connect()\n  // will implicitly bind to a random port. Ergo, check that the socket is\n  // bound to the expected port before calling listen() or connect().\n  //\n  // FIXME(bnoordhuis) Doesn't work for pipe handles, they don't have a\n  // getsockname() method. Non-issue for now, the cluster module doesn't\n  // really support pipes anyway.\n  if (err === 0 && port > 0 && handle.getsockname) {\n    const out = {};\n    err = handle.getsockname(out);\n    if (err === 0 && port !== out.port) {\n      debug(`checkBindError, bound to ${out.port} instead of ${port}`);\n      err = UV_EADDRINUSE;\n    }\n  }\n  return err;\n}\n\n\nfunction internalConnect(\n  self, address, port, addressType, localAddress, localPort, flags) {\n  // TODO return promise from Socket.prototype.connect which\n  // wraps _connectReq.\n\n  assert(self.connecting);\n\n  let err;\n\n  if (localAddress || localPort) {\n    if (addressType === 4) {\n      localAddress = localAddress || DEFAULT_IPV4_ADDR;\n      err = self._handle.bind(localAddress, localPort);\n    } else { // addressType === 6\n      localAddress = localAddress || DEFAULT_IPV6_ADDR;\n      err = self._handle.bind6(localAddress, localPort, flags);\n    }\n    debug('connect: binding to localAddress: %s and localPort: %d (addressType: %d)',\n          localAddress, localPort, addressType);\n\n    err = checkBindError(err, localPort, self._handle);\n    if (err) {\n      const ex = exceptionWithHostPort(err, 'bind', localAddress, localPort);\n      self.destroy(ex);\n      return;\n    }\n  }\n\n  debug('connect: attempting to connect to %s:%d (addressType: %d)', address, port, addressType);\n\n  if (addressType === 6 || addressType === 4) {\n    const req = new TCPConnectWrap();\n    req.oncomplete = afterConnect;\n    req.address = address;\n    req.port = port;\n    req.localAddress = localAddress;\n    req.localPort = localPort;\n\n    if (addressType === 4)\n      err = self._handle.connect(req, address, port);\n    else\n      err = self._handle.connect6(req, address, port);\n  } else {\n    const req = new PipeConnectWrap();\n    req.address = address;\n    req.oncomplete = afterConnect;\n\n    err = self._handle.connect(req, address);\n  }\n\n  if (err) {\n    const sockname = self._getsockname();\n    let details;\n\n    if (sockname) {\n      details = sockname.address + ':' + sockname.port;\n    }\n\n    const ex = exceptionWithHostPort(err, 'connect', address, port, details);\n    self.destroy(ex);\n  } else if ((addressType === 6 || addressType === 4) && hasObserver('net')) {\n    startPerf(self, kPerfHooksNetConnectContext, { type: 'net', name: 'connect', detail: { host: address, port } });\n  }\n}\n\n\nfunction internalConnectMultiple(context, canceled) {\n  clearTimeout(context[kTimeout]);\n  const self = context.socket;\n\n  // We were requested to abort. Stop all operations\n  if (self._aborted) {\n    return;\n  }\n\n  // All connections have been tried without success, destroy with error\n  if (canceled || context.current === context.addresses.length) {\n    if (context.errors.length === 0) {\n      self.destroy(new ERR_SOCKET_CONNECTION_TIMEOUT());\n      return;\n    }\n\n    self.destroy(aggregateErrors(context.errors));\n    return;\n  }\n\n  assert(self.connecting);\n\n  const current = context.current++;\n\n  if (current > 0) {\n    self[kReinitializeHandle](new TCP(TCPConstants.SOCKET));\n  }\n\n  const { localPort, port, flags } = context;\n  const { address, family: addressType } = context.addresses[current];\n  let localAddress;\n  let err;\n\n  if (localPort) {\n    if (addressType === 4) {\n      localAddress = DEFAULT_IPV4_ADDR;\n      err = self._handle.bind(localAddress, localPort);\n    } else { // addressType === 6\n      localAddress = DEFAULT_IPV6_ADDR;\n      err = self._handle.bind6(localAddress, localPort, flags);\n    }\n\n    debug('connect/multiple: binding to localAddress: %s and localPort: %d (addressType: %d)',\n          localAddress, localPort, addressType);\n\n    err = checkBindError(err, localPort, self._handle);\n    if (err) {\n      ArrayPrototypePush(context.errors, exceptionWithHostPort(err, 'bind', localAddress, localPort));\n      internalConnectMultiple(context);\n      return;\n    }\n  }\n\n  debug('connect/multiple: attempting to connect to %s:%d (addressType: %d)', address, port, addressType);\n\n  const req = new TCPConnectWrap();\n  req.oncomplete = FunctionPrototypeBind(afterConnectMultiple, undefined, context, current);\n  req.address = address;\n  req.port = port;\n  req.localAddress = localAddress;\n  req.localPort = localPort;\n\n  ArrayPrototypePush(self.autoSelectFamilyAttemptedAddresses, `${address}:${port}`);\n\n  if (addressType === 4) {\n    err = self._handle.connect(req, address, port);\n  } else {\n    err = self._handle.connect6(req, address, port);\n  }\n\n  if (err) {\n    const sockname = self._getsockname();\n    let details;\n\n    if (sockname) {\n      details = sockname.address + ':' + sockname.port;\n    }\n\n    ArrayPrototypePush(context.errors, exceptionWithHostPort(err, 'connect', address, port, details));\n    internalConnectMultiple(context);\n    return;\n  }\n\n  if (current < context.addresses.length - 1) {\n    debug('connect/multiple: setting the attempt timeout to %d ms', context.timeout);\n\n    // If the attempt has not returned an error, start the connection timer\n    context[kTimeout] = setTimeout(internalConnectMultipleTimeout, context.timeout, context, req, self._handle);\n  }\n}\n\nSocket.prototype.connect = function(...args) {\n  let normalized;\n  // If passed an array, it's treated as an array of arguments that have\n  // already been normalized (so we don't normalize more than once). This has\n  // been solved before in https://github.com/nodejs/node/pull/12342, but was\n  // reverted as it had unintended side effects.\n  if (ArrayIsArray(args[0]) && args[0][normalizedArgsSymbol]) {\n    normalized = args[0];\n  } else {\n    normalized = normalizeArgs(args);\n  }\n  const options = normalized[0];\n  const cb = normalized[1];\n\n  if (cb !== null) {\n    this.once('connect', cb);\n  }\n\n  // If the parent is already connecting, do not attempt to connect again\n  if (this._parent && this._parent.connecting) {\n    return this;\n  }\n\n  // options.port === null will be checked later.\n  if (options.port === undefined && options.path == null)\n    throw new ERR_MISSING_ARGS(['options', 'port', 'path']);\n\n  if (this.write !== Socket.prototype.write)\n    this.write = Socket.prototype.write;\n\n  if (this.destroyed) {\n    this._handle = null;\n    this._peername = null;\n    this._sockname = null;\n  }\n\n  const { path } = options;\n  const pipe = !!path;\n  debug('pipe', pipe, path);\n\n  if (!this._handle) {\n    this._handle = pipe ?\n      new Pipe(PipeConstants.SOCKET) :\n      new TCP(TCPConstants.SOCKET);\n    initSocketHandle(this);\n  }\n\n  this._unrefTimer();\n\n  this.connecting = true;\n\n  if (pipe) {\n    validateString(path, 'options.path');\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol], internalConnect, this, path,\n    );\n  } else {\n    lookupAndConnect(this, options);\n  }\n  return this;\n};\n\nSocket.prototype[kReinitializeHandle] = function reinitializeHandle(handle) {\n  this._handle?.close();\n\n  this._handle = handle;\n  this._handle[owner_symbol] = this;\n\n  initSocketHandle(this);\n};\n\nfunction socketToDnsFamily(family) {\n  switch (family) {\n    case 'IPv4':\n      return 4;\n    case 'IPv6':\n      return 6;\n  }\n\n  return family;\n}\n\nfunction lookupAndConnect(self, options) {\n  const { localAddress, localPort } = options;\n  const host = options.host || 'localhost';\n  let { port, autoSelectFamilyAttemptTimeout, autoSelectFamily } = options;\n\n  if (localAddress && !isIP(localAddress)) {\n    throw new ERR_INVALID_IP_ADDRESS(localAddress);\n  }\n\n  if (localPort) {\n    validateNumber(localPort, 'options.localPort');\n  }\n\n  if (typeof port !== 'undefined') {\n    if (typeof port !== 'number' && typeof port !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('options.port',\n                                     ['number', 'string'], port);\n    }\n    validatePort(port);\n  }\n  port |= 0;\n\n\n  if (autoSelectFamily != null) {\n    validateBoolean(autoSelectFamily, 'options.autoSelectFamily');\n  } else {\n    autoSelectFamily = autoSelectFamilyDefault;\n  }\n\n  if (autoSelectFamilyAttemptTimeout != null) {\n    validateInt32(autoSelectFamilyAttemptTimeout, 'options.autoSelectFamilyAttemptTimeout', 1);\n\n    if (autoSelectFamilyAttemptTimeout < 10) {\n      autoSelectFamilyAttemptTimeout = 10;\n    }\n  } else {\n    autoSelectFamilyAttemptTimeout = autoSelectFamilyAttemptTimeoutDefault;\n  }\n\n  // If host is an IP, skip performing a lookup\n  const addressType = isIP(host);\n  if (addressType) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol], process.nextTick, () => {\n      if (self.connecting)\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol],\n          internalConnect,\n          self, host, port, addressType, localAddress, localPort,\n        );\n    });\n    return;\n  }\n\n  if (options.lookup != null)\n    validateFunction(options.lookup, 'options.lookup');\n\n  if (dns === undefined) dns = require('dns');\n  const dnsopts = {\n    family: socketToDnsFamily(options.family),\n    hints: options.hints || 0,\n  };\n\n  if (!isWindows &&\n      dnsopts.family !== 4 &&\n      dnsopts.family !== 6 &&\n      dnsopts.hints === 0) {\n    dnsopts.hints = dns.ADDRCONFIG;\n  }\n\n  debug('connect: find host', host);\n  debug('connect: dns options', dnsopts);\n  self._host = host;\n  const lookup = options.lookup || dns.lookup;\n\n  if (dnsopts.family !== 4 && dnsopts.family !== 6 && !localAddress && autoSelectFamily) {\n    debug('connect: autodetecting');\n\n    dnsopts.all = true;\n    defaultTriggerAsyncIdScope(self[async_id_symbol], function() {\n      lookupAndConnectMultiple(\n        self,\n        async_id_symbol,\n        lookup,\n        host,\n        options,\n        dnsopts,\n        port,\n        localAddress,\n        localPort,\n        autoSelectFamilyAttemptTimeout,\n      );\n    });\n\n    return;\n  }\n\n  defaultTriggerAsyncIdScope(self[async_id_symbol], function() {\n    lookup(host, dnsopts, function emitLookup(err, ip, addressType) {\n      self.emit('lookup', err, ip, addressType, host);\n\n      // It's possible we were destroyed while looking this up.\n      // XXX it would be great if we could cancel the promise returned by\n      // the look up.\n      if (!self.connecting) return;\n\n      if (err) {\n        // net.createConnection() creates a net.Socket object and immediately\n        // calls net.Socket.connect() on it (that's us). There are no event\n        // listeners registered yet so defer the error event to the next tick.\n        process.nextTick(connectErrorNT, self, err);\n      } else if (!isIP(ip)) {\n        err = new ERR_INVALID_IP_ADDRESS(ip);\n        process.nextTick(connectErrorNT, self, err);\n      } else if (addressType !== 4 && addressType !== 6) {\n        err = new ERR_INVALID_ADDRESS_FAMILY(addressType,\n                                             options.host,\n                                             options.port);\n        process.nextTick(connectErrorNT, self, err);\n      } else {\n        self._unrefTimer();\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol],\n          internalConnect,\n          self, ip, port, addressType, localAddress, localPort,\n        );\n      }\n    });\n  });\n}\n\nfunction lookupAndConnectMultiple(\n  self, async_id_symbol, lookup, host, options, dnsopts, port, localAddress, localPort, timeout,\n) {\n  defaultTriggerAsyncIdScope(self[async_id_symbol], function emitLookup() {\n    lookup(host, dnsopts, function emitLookup(err, addresses) {\n      // It's possible we were destroyed while looking this up.\n      // XXX it would be great if we could cancel the promise returned by\n      // the look up.\n      if (!self.connecting) {\n        return;\n      } else if (err) {\n        self.emit('lookup', err, undefined, undefined, host);\n\n        // net.createConnection() creates a net.Socket object and immediately\n        // calls net.Socket.connect() on it (that's us). There are no event\n        // listeners registered yet so defer the error event to the next tick.\n        process.nextTick(connectErrorNT, self, err);\n        return;\n      }\n\n      // Filter addresses by only keeping the one which are either IPv4 or IPV6.\n      // The first valid address determines which group has preference on the\n      // alternate family sorting which happens later.\n      const validAddresses = [[], []];\n      const validIps = [[], []];\n      let destinations;\n      for (let i = 0, l = addresses.length; i < l; i++) {\n        const address = addresses[i];\n        const { address: ip, family: addressType } = address;\n        self.emit('lookup', err, ip, addressType, host);\n\n        if (isIP(ip) && (addressType === 4 || addressType === 6)) {\n          if (!destinations) {\n            destinations = addressType === 6 ? { 6: 0, 4: 1 } : { 4: 0, 6: 1 };\n          }\n\n          const destination = destinations[addressType];\n\n          // Only try an address once\n          if (!ArrayPrototypeIncludes(validIps[destination], ip)) {\n            ArrayPrototypePush(validAddresses[destination], address);\n            ArrayPrototypePush(validIps[destination], ip);\n          }\n        }\n      }\n\n\n      // When no AAAA or A records are available, fail on the first one\n      if (!validAddresses[0].length && !validAddresses[1].length) {\n        const { address: firstIp, family: firstAddressType } = addresses[0];\n\n        if (!isIP(firstIp)) {\n          err = new ERR_INVALID_IP_ADDRESS(firstIp);\n          process.nextTick(connectErrorNT, self, err);\n        } else if (firstAddressType !== 4 && firstAddressType !== 6) {\n          err = new ERR_INVALID_ADDRESS_FAMILY(firstAddressType,\n                                               options.host,\n                                               options.port);\n          process.nextTick(connectErrorNT, self, err);\n        }\n\n        return;\n      }\n\n      // Sort addresses alternating families\n      const toAttempt = [];\n      for (let i = 0, l = MathMax(validAddresses[0].length, validAddresses[1].length); i < l; i++) {\n        if (i in validAddresses[0]) {\n          ArrayPrototypePush(toAttempt, validAddresses[0][i]);\n        }\n        if (i in validAddresses[1]) {\n          ArrayPrototypePush(toAttempt, validAddresses[1][i]);\n        }\n      }\n\n      if (toAttempt.length === 1) {\n        debug('connect/multiple: only one address found, switching back to single connection');\n        const { address: ip, family: addressType } = toAttempt[0];\n\n        self._unrefTimer();\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol],\n          internalConnect,\n          self,\n          ip,\n          port,\n          addressType,\n          localAddress,\n          localPort,\n        );\n\n        return;\n      }\n\n      self.autoSelectFamilyAttemptedAddresses = [];\n      debug('connect/multiple: will try the following addresses', toAttempt);\n\n      const context = {\n        socket: self,\n        addresses: toAttempt,\n        current: 0,\n        port,\n        localPort,\n        timeout,\n        [kTimeout]: null,\n        errors: [],\n      };\n\n      self._unrefTimer();\n      defaultTriggerAsyncIdScope(self[async_id_symbol], internalConnectMultiple, context);\n    });\n  });\n}\n\nfunction connectErrorNT(self, err) {\n  self.destroy(err);\n}\n\n\nSocket.prototype.ref = function() {\n  if (!this._handle) {\n    this.once('connect', this.ref);\n    return this;\n  }\n\n  if (typeof this._handle.ref === 'function') {\n    this._handle.ref();\n  }\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  if (!this._handle) {\n    this.once('connect', this.unref);\n    return this;\n  }\n\n  if (typeof this._handle.unref === 'function') {\n    this._handle.unref();\n  }\n\n  return this;\n};\n\n\nfunction afterConnect(status, handle, req, readable, writable) {\n  const self = handle[owner_symbol];\n\n  // Callback may come after call to destroy\n  if (self.destroyed) {\n    return;\n  }\n\n  debug('afterConnect');\n\n  assert(self.connecting);\n  self.connecting = false;\n  self._sockname = null;\n\n  if (status === 0) {\n    if (self.readable && !readable) {\n      self.push(null);\n      self.read();\n    }\n    if (self.writable && !writable) {\n      self.end();\n    }\n    self._unrefTimer();\n\n    if (self[kSetNoDelay] && self._handle.setNoDelay) {\n      self._handle.setNoDelay(true);\n    }\n\n    if (self[kSetKeepAlive] && self._handle.setKeepAlive) {\n      self._handle.setKeepAlive(true, self[kSetKeepAliveInitialDelay]);\n    }\n\n    self.emit('connect');\n    self.emit('ready');\n\n    // Start the first read, or get an immediate EOF.\n    // this doesn't actually consume any bytes, because len=0.\n    if (readable && !self.isPaused())\n      self.read(0);\n    if (self[kPerfHooksNetConnectContext] && hasObserver('net')) {\n      stopPerf(self, kPerfHooksNetConnectContext);\n    }\n  } else {\n    let details;\n    if (req.localAddress && req.localPort) {\n      details = req.localAddress + ':' + req.localPort;\n    }\n    const ex = exceptionWithHostPort(status,\n                                     'connect',\n                                     req.address,\n                                     req.port,\n                                     details);\n    if (details) {\n      ex.localAddress = req.localAddress;\n      ex.localPort = req.localPort;\n    }\n    self.destroy(ex);\n  }\n}\n\nfunction addClientAbortSignalOption(self, options) {\n  validateAbortSignal(options.signal, 'options.signal');\n  const { signal } = options;\n  let disposable;\n\n  function onAbort() {\n    disposable?.[SymbolDispose]();\n    self._aborted = true;\n  }\n\n  if (signal.aborted) {\n    process.nextTick(onAbort);\n  } else {\n    process.nextTick(() => {\n      disposable = EventEmitter.addAbortListener(signal, onAbort);\n    });\n  }\n}\n\nfunction createConnectionError(req, status) {\n  let details;\n\n  if (req.localAddress && req.localPort) {\n    details = req.localAddress + ':' + req.localPort;\n  }\n\n  const ex = exceptionWithHostPort(status,\n                                   'connect',\n                                   req.address,\n                                   req.port,\n                                   details);\n  if (details) {\n    ex.localAddress = req.localAddress;\n    ex.localPort = req.localPort;\n  }\n\n  return ex;\n}\n\nfunction afterConnectMultiple(context, current, status, handle, req, readable, writable) {\n  debug('connect/multiple: connection attempt to %s:%s completed with status %s', req.address, req.port, status);\n\n  // Make sure another connection is not spawned\n  clearTimeout(context[kTimeout]);\n\n  // One of the connection has completed and correctly dispatched but after timeout, ignore this one\n  if (status === 0 && current !== context.current - 1) {\n    debug('connect/multiple: ignoring successful but timedout connection to %s:%s', req.address, req.port);\n    handle.close();\n    return;\n  }\n\n  const self = context.socket;\n\n  // Some error occurred, add to the list of exceptions\n  if (status !== 0) {\n    ArrayPrototypePush(context.errors, createConnectionError(req, status));\n\n    // Try the next address\n    internalConnectMultiple(context, status === UV_ECANCELED);\n    return;\n  }\n\n  if (hasObserver('net')) {\n    startPerf(\n      self,\n      kPerfHooksNetConnectContext,\n      { type: 'net', name: 'connect', detail: { host: req.address, port: req.port } },\n    );\n  }\n\n  afterConnect(status, self._handle, req, readable, writable);\n}\n\nfunction internalConnectMultipleTimeout(context, req, handle) {\n  debug('connect/multiple: connection to %s:%s timed out', req.address, req.port);\n  req.oncomplete = undefined;\n  ArrayPrototypePush(context.errors, createConnectionError(req, UV_ETIMEDOUT));\n  handle.close();\n  internalConnectMultiple(context);\n}\n\nfunction addServerAbortSignalOption(self, options) {\n  if (options?.signal === undefined) {\n    return;\n  }\n  validateAbortSignal(options.signal, 'options.signal');\n  const { signal } = options;\n  const onAborted = () => {\n    self.close();\n  };\n  if (signal.aborted) {\n    process.nextTick(onAborted);\n  } else {\n    const disposable = EventEmitter.addAbortListener(signal, onAborted);\n    self.once('close', disposable[SymbolDispose]);\n  }\n}\n\nfunction Server(options, connectionListener) {\n  if (!(this instanceof Server))\n    return new Server(options, connectionListener);\n\n  EventEmitter.call(this);\n\n  if (typeof options === 'function') {\n    connectionListener = options;\n    options = kEmptyObject;\n    this.on('connection', connectionListener);\n  } else if (options == null || typeof options === 'object') {\n    options = { ...options };\n\n    if (typeof connectionListener === 'function') {\n      this.on('connection', connectionListener);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n  }\n  if (typeof options.keepAliveInitialDelay !== 'undefined') {\n    validateNumber(\n      options.keepAliveInitialDelay, 'options.keepAliveInitialDelay',\n    );\n\n    if (options.keepAliveInitialDelay < 0) {\n      options.keepAliveInitialDelay = 0;\n    }\n  }\n  if (typeof options.highWaterMark !== 'undefined') {\n    validateNumber(\n      options.highWaterMark, 'options.highWaterMark',\n    );\n\n    if (options.highWaterMark < 0) {\n      options.highWaterMark = getDefaultHighWaterMark();\n    }\n  }\n\n  this._connections = 0;\n\n  this[async_id_symbol] = -1;\n  this._handle = null;\n  this._usingWorkers = false;\n  this._workers = [];\n  this._unref = false;\n\n  this.allowHalfOpen = options.allowHalfOpen || false;\n  this.pauseOnConnect = !!options.pauseOnConnect;\n  this.noDelay = Boolean(options.noDelay);\n  this.keepAlive = Boolean(options.keepAlive);\n  this.keepAliveInitialDelay = ~~(options.keepAliveInitialDelay / 1000);\n  this.highWaterMark = options.highWaterMark ?? getDefaultHighWaterMark();\n}\nObjectSetPrototypeOf(Server.prototype, EventEmitter.prototype);\nObjectSetPrototypeOf(Server, EventEmitter);\n\n\nfunction toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\n\n// Returns handle if it can be created, or error code if it can't\nfunction createServerHandle(address, port, addressType, fd, flags) {\n  let err = 0;\n  // Assign handle in listen, and clean up if bind or listen fails\n  let handle;\n\n  let isTCP = false;\n  if (typeof fd === 'number' && fd >= 0) {\n    try {\n      handle = createHandle(fd, true);\n    } catch (e) {\n      // Not a fd we can listen on.  This will trigger an error.\n      debug('listen invalid fd=%d:', fd, e.message);\n      return UV_EINVAL;\n    }\n\n    err = handle.open(fd);\n    if (err)\n      return err;\n\n    assert(!address && !port);\n  } else if (port === -1 && addressType === -1) {\n    handle = new Pipe(PipeConstants.SERVER);\n    if (isWindows) {\n      const instances = NumberParseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\n      if (!NumberIsNaN(instances)) {\n        handle.setPendingInstances(instances);\n      }\n    }\n  } else {\n    handle = new TCP(TCPConstants.SERVER);\n    isTCP = true;\n  }\n\n  if (address || port || isTCP) {\n    debug('bind to', address || 'any');\n    if (!address) {\n      // Try binding to ipv6 first\n      err = handle.bind6(DEFAULT_IPV6_ADDR, port, flags);\n      if (err) {\n        handle.close();\n        // Fallback to ipv4\n        return createServerHandle(DEFAULT_IPV4_ADDR, port);\n      }\n    } else if (addressType === 6) {\n      err = handle.bind6(address, port, flags);\n    } else {\n      err = handle.bind(address, port);\n    }\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\nfunction setupListenHandle(address, port, addressType, backlog, fd, flags) {\n  debug('setupListenHandle', address, port, addressType, backlog, fd);\n\n  // If there is not yet a handle, we need to create one and bind.\n  // In the case of a server sent via IPC, we don't need to do this.\n  if (this._handle) {\n    debug('setupListenHandle: have a handle already');\n  } else {\n    debug('setupListenHandle: create a handle');\n\n    let rval = null;\n\n    // Try to bind to the unspecified IPv6 address, see if IPv6 is available\n    if (!address && typeof fd !== 'number') {\n      rval = createServerHandle(DEFAULT_IPV6_ADDR, port, 6, fd, flags);\n\n      if (typeof rval === 'number') {\n        rval = null;\n        address = DEFAULT_IPV4_ADDR;\n        addressType = 4;\n      } else {\n        address = DEFAULT_IPV6_ADDR;\n        addressType = 6;\n      }\n    }\n\n    if (rval === null)\n      rval = createServerHandle(address, port, addressType, fd, flags);\n\n    if (typeof rval === 'number') {\n      const error = uvExceptionWithHostPort(rval, 'listen', address, port);\n      process.nextTick(emitErrorNT, this, error);\n      return;\n    }\n    this._handle = rval;\n  }\n\n  this[async_id_symbol] = getNewAsyncId(this._handle);\n  this._handle.onconnection = onconnection;\n  this._handle[owner_symbol] = this;\n\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\n  // which will thus give us a backlog of 512 entries.\n  const err = this._handle.listen(backlog || 511);\n\n  if (err) {\n    const ex = uvExceptionWithHostPort(err, 'listen', address, port);\n    this._handle.close();\n    this._handle = null;\n    defaultTriggerAsyncIdScope(this[async_id_symbol],\n                               process.nextTick,\n                               emitErrorNT,\n                               this,\n                               ex);\n    return;\n  }\n\n  // Generate connection key, this should be unique to the connection\n  this._connectionKey = addressType + ':' + address + ':' + port;\n\n  // Unref the handle if the server was unref'ed prior to listening\n  if (this._unref)\n    this.unref();\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol],\n                             process.nextTick,\n                             emitListeningNT,\n                             this);\n}\n\nServer.prototype._listen2 = setupListenHandle;  // legacy alias\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\n\nfunction emitListeningNT(self) {\n  // Ensure handle hasn't closed\n  if (self._handle)\n    self.emit('listening');\n}\n\n\nfunction listenInCluster(server, address, port, addressType,\n                         backlog, fd, exclusive, flags, options) {\n  exclusive = !!exclusive;\n\n  if (cluster === undefined) cluster = require('cluster');\n\n  if (cluster.isPrimary || exclusive) {\n    // Will create a new handle\n    // _listen2 sets up the listened handle, it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address, port, addressType, backlog, fd, flags);\n    return;\n  }\n\n  const serverQuery = {\n    address: address,\n    port: port,\n    addressType: addressType,\n    fd: fd,\n    flags,\n    backlog,\n    ...options,\n  };\n  // Get the primary's server handle, and listen on it\n  cluster._getServer(server, serverQuery, listenOnPrimaryHandle);\n\n  function listenOnPrimaryHandle(err, handle) {\n    err = checkBindError(err, port, handle);\n\n    if (err) {\n      const ex = exceptionWithHostPort(err, 'bind', address, port);\n      return server.emit('error', ex);\n    }\n\n    // Reuse primary's server handle\n    server._handle = handle;\n    // _listen2 sets up the listened handle, it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address, port, addressType, backlog, fd, flags);\n  }\n}\n\n\nServer.prototype.listen = function(...args) {\n  const normalized = normalizeArgs(args);\n  let options = normalized[0];\n  const cb = normalized[1];\n\n  if (this._handle) {\n    throw new ERR_SERVER_ALREADY_LISTEN();\n  }\n\n  if (cb !== null) {\n    this.once('listening', cb);\n  }\n  const backlogFromArgs =\n    // (handle, backlog) or (path, backlog) or (port, backlog)\n    toNumber(args.length > 1 && args[1]) ||\n    toNumber(args.length > 2 && args[2]);  // (port, host, backlog)\n\n  options = options._handle || options.handle || options;\n  const flags = getFlags(options.ipv6Only);\n  // (handle[, backlog][, cb]) where handle is an object with a handle\n  if (options instanceof TCP) {\n    this._handle = options;\n    this[async_id_symbol] = this._handle.getAsyncId();\n    listenInCluster(this, null, -1, -1, backlogFromArgs);\n    return this;\n  }\n  addServerAbortSignalOption(this, options);\n  // (handle[, backlog][, cb]) where handle is an object with a fd\n  if (typeof options.fd === 'number' && options.fd >= 0) {\n    listenInCluster(this, null, null, null, backlogFromArgs, options.fd);\n    return this;\n  }\n\n  // ([port][, host][, backlog][, cb]) where port is omitted,\n  // that is, listen(), listen(null), listen(cb), or listen(null, cb)\n  // or (options[, cb]) where options.port is explicitly set as undefined or\n  // null, bind to an arbitrary unused port\n  if (args.length === 0 || typeof args[0] === 'function' ||\n      (typeof options.port === 'undefined' && 'port' in options) ||\n      options.port === null) {\n    options.port = 0;\n  }\n  // ([port][, host][, backlog][, cb]) where port is specified\n  // or (options[, cb]) where options.port is specified\n  // or if options.port is normalized as 0 before\n  let backlog;\n  if (typeof options.port === 'number' || typeof options.port === 'string') {\n    validatePort(options.port, 'options.port');\n    backlog = options.backlog || backlogFromArgs;\n    // start TCP server listening on host:port\n    if (options.host) {\n      lookupAndListen(this, options.port | 0, options.host, backlog,\n                      options.exclusive, flags);\n    } else { // Undefined host, listens on unspecified address\n      // Default addressType 4 will be used to search for primary server\n      listenInCluster(this, null, options.port | 0, 4,\n                      backlog, undefined, options.exclusive);\n    }\n    return this;\n  }\n\n  // (path[, backlog][, cb]) or (options[, cb])\n  // where path or options.path is a UNIX domain socket or Windows pipe\n  if (options.path && isPipeName(options.path)) {\n    // We can not call fchmod on abstract unix socket\n    if (options.path[0] === '\\0' &&\n        (options.readableAll || options.writableAll)) {\n      const msg = 'can not set readableAll or writableAllt to true when path is abstract unix socket';\n      throw new ERR_INVALID_ARG_VALUE('options', options, msg);\n    }\n    const pipeName = this._pipeName = options.path;\n    backlog = options.backlog || backlogFromArgs;\n    listenInCluster(this,\n                    pipeName,\n                    -1,\n                    -1,\n                    backlog,\n                    undefined,\n                    options.exclusive,\n                    undefined,\n                    {\n                      readableAll: options.readableAll,\n                      writableAll: options.writableAll,\n                    });\n\n    if (!this._handle) {\n      // Failed and an error shall be emitted in the next tick.\n      // Therefore, we directly return.\n      return this;\n    }\n\n    let mode = 0;\n    if (options.readableAll === true)\n      mode |= PipeConstants.UV_READABLE;\n    if (options.writableAll === true)\n      mode |= PipeConstants.UV_WRITABLE;\n    if (mode !== 0) {\n      const err = this._handle.fchmod(mode);\n      if (err) {\n        this._handle.close();\n        this._handle = null;\n        throw errnoException(err, 'uv_pipe_chmod');\n      }\n    }\n    return this;\n  }\n\n  if (!(('port' in options) || ('path' in options))) {\n    throw new ERR_INVALID_ARG_VALUE('options', options,\n                                    'must have the property \"port\" or \"path\"');\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('options', options);\n};\n\nfunction lookupAndListen(self, port, address, backlog, exclusive, flags) {\n  if (dns === undefined) dns = require('dns');\n  dns.lookup(address, function doListen(err, ip, addressType) {\n    if (err) {\n      self.emit('error', err);\n    } else {\n      addressType = ip ? addressType : 4;\n      listenInCluster(self, ip, port, addressType,\n                      backlog, undefined, exclusive, flags);\n    }\n  });\n}\n\nObjectDefineProperty(Server.prototype, 'listening', {\n  __proto__: null,\n  get: function() {\n    return !!this._handle;\n  },\n  configurable: true,\n  enumerable: true,\n});\n\nServer.prototype.address = function() {\n  if (this._handle && this._handle.getsockname) {\n    const out = {};\n    const err = this._handle.getsockname(out);\n    if (err) {\n      throw errnoException(err, 'address');\n    }\n    return out;\n  } else if (this._pipeName) {\n    return this._pipeName;\n  }\n  return null;\n};\n\nfunction onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    if (clientHandle.getsockname || clientHandle.getpeername) {\n      const data = { __proto__: null };\n      if (clientHandle.getsockname) {\n        const localInfo = { __proto__: null };\n        clientHandle.getsockname(localInfo);\n        data.localAddress = localInfo.address;\n        data.localPort = localInfo.port;\n        data.localFamily = localInfo.family;\n      }\n      if (clientHandle.getpeername) {\n        const remoteInfo = { __proto__: null };\n        clientHandle.getpeername(remoteInfo);\n        data.remoteAddress = remoteInfo.address;\n        data.remotePort = remoteInfo.port;\n        data.remoteFamily = remoteInfo.family;\n      }\n      self.emit('drop', data);\n    } else {\n      self.emit('drop');\n    }\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true,\n    readableHighWaterMark: self.highWaterMark,\n    writableHighWaterMark: self.highWaterMark,\n  });\n\n  if (self.noDelay && clientHandle.setNoDelay) {\n    socket[kSetNoDelay] = true;\n    clientHandle.setNoDelay(true);\n  }\n  if (self.keepAlive && clientHandle.setKeepAlive) {\n    socket[kSetKeepAlive] = true;\n    socket[kSetKeepAliveInitialDelay] = self.keepAliveInitialDelay;\n    clientHandle.setKeepAlive(true, self.keepAliveInitialDelay);\n  }\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n  self.emit('connection', socket);\n  if (netServerSocketChannel.hasSubscribers) {\n    netServerSocketChannel.publish({\n      socket,\n    });\n  }\n}\n\n/**\n * Gets the number of concurrent connections on the server\n * @param {Function} cb\n * @returns {Server}\n */\n\nServer.prototype.getConnections = function(cb) {\n  const self = this;\n\n  function end(err, connections) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol],\n                               process.nextTick,\n                               cb,\n                               err,\n                               connections);\n  }\n\n  if (!this._usingWorkers) {\n    end(null, this._connections);\n    return this;\n  }\n\n  // Poll workers\n  let left = this._workers.length;\n  let total = this._connections;\n\n  function oncount(err, count) {\n    if (err) {\n      left = -1;\n      return end(err);\n    }\n\n    total += count;\n    if (--left === 0) return end(null, total);\n  }\n\n  for (let n = 0; n < this._workers.length; n++) {\n    this._workers[n].getConnections(oncount);\n  }\n\n  return this;\n};\n\n\nServer.prototype.close = function(cb) {\n  if (typeof cb === 'function') {\n    if (!this._handle) {\n      this.once('close', function close() {\n        cb(new ERR_SERVER_NOT_RUNNING());\n      });\n    } else {\n      this.once('close', cb);\n    }\n  }\n\n  if (this._handle) {\n    this._handle.close();\n    this._handle = null;\n  }\n\n  if (this._usingWorkers) {\n    let left = this._workers.length;\n    const onWorkerClose = () => {\n      if (--left !== 0) return;\n\n      this._connections = 0;\n      this._emitCloseIfDrained();\n    };\n\n    // Increment connections to be sure that, even if all sockets will be closed\n    // during polling of workers, `close` event will be emitted only once.\n    this._connections++;\n\n    // Poll workers\n    for (let n = 0; n < this._workers.length; n++)\n      this._workers[n].close(onWorkerClose);\n  } else {\n    this._emitCloseIfDrained();\n  }\n\n  return this;\n};\n\nServer.prototype[SymbolAsyncDispose] = async function() {\n  if (!this._handle) {\n    return;\n  }\n  return FunctionPrototypeCall(promisify(this.close), this);\n};\n\nServer.prototype._emitCloseIfDrained = function() {\n  debug('SERVER _emitCloseIfDrained');\n\n  if (this._handle || this._connections) {\n    debug('SERVER handle? %j   connections? %d',\n          !!this._handle, this._connections);\n    return;\n  }\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol],\n                             process.nextTick,\n                             emitCloseNT,\n                             this);\n};\n\n\nfunction emitCloseNT(self) {\n  debug('SERVER: emit close');\n  self.emit('close');\n}\n\n\nServer.prototype[EventEmitter.captureRejectionSymbol] = function(\n  err, event, sock) {\n\n  switch (event) {\n    case 'connection':\n      sock.destroy(err);\n      break;\n    default:\n      this.emit('error', err);\n  }\n};\n\n\n// Legacy alias on the C++ wrapper object. This is not public API, so we may\n// want to runtime-deprecate it at some point. There's no hurry, though.\nObjectDefineProperty(TCP.prototype, 'owner', {\n  __proto__: null,\n  get() { return this[owner_symbol]; },\n  set(v) { return this[owner_symbol] = v; },\n});\n\nObjectDefineProperty(Socket.prototype, '_handle', {\n  __proto__: null,\n  get() { return this[kHandle]; },\n  set(v) { return this[kHandle] = v; },\n});\n\nServer.prototype._setupWorker = function(socketList) {\n  this._usingWorkers = true;\n  this._workers.push(socketList);\n  socketList.once('exit', (socketList) => {\n    const index = ArrayPrototypeIndexOf(this._workers, socketList);\n    this._workers.splice(index, 1);\n  });\n};\n\nServer.prototype.ref = function() {\n  this._unref = false;\n\n  if (this._handle)\n    this._handle.ref();\n\n  return this;\n};\n\nServer.prototype.unref = function() {\n  this._unref = true;\n\n  if (this._handle)\n    this._handle.unref();\n\n  return this;\n};\n\nlet _setSimultaneousAccepts;\nlet warnSimultaneousAccepts = true;\n\nif (isWindows) {\n  let simultaneousAccepts;\n\n  _setSimultaneousAccepts = function(handle) {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\n        'net._setSimultaneousAccepts() is deprecated and will be removed.',\n        'DeprecationWarning', 'DEP0121');\n      warnSimultaneousAccepts = false;\n    }\n    if (handle === undefined) {\n      return;\n    }\n\n    if (simultaneousAccepts === undefined) {\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\n                             process.env.NODE_MANY_ACCEPTS !== '0');\n    }\n\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\n      handle.setSimultaneousAccepts(!!simultaneousAccepts);\n      handle._simultaneousAccepts = simultaneousAccepts;\n    }\n  };\n} else {\n  _setSimultaneousAccepts = function() {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\n        'net._setSimultaneousAccepts() is deprecated and will be removed.',\n        'DeprecationWarning', 'DEP0121');\n      warnSimultaneousAccepts = false;\n    }\n  };\n}\n\nmodule.exports = {\n  _createServerHandle: createServerHandle,\n  _normalizeArgs: normalizeArgs,\n  _setSimultaneousAccepts,\n  get BlockList() {\n    BlockList ??= require('internal/blocklist').BlockList;\n    return BlockList;\n  },\n  get SocketAddress() {\n    SocketAddress ??= require('internal/socketaddress').SocketAddress;\n    return SocketAddress;\n  },\n  connect,\n  createConnection: connect,\n  createServer,\n  isIP: isIP,\n  isIPv4: isIPv4,\n  isIPv6: isIPv6,\n  Server,\n  Socket,\n  Stream: Socket, // Legacy naming\n  getDefaultAutoSelectFamily,\n  setDefaultAutoSelectFamily,\n  getDefaultAutoSelectFamilyAttemptTimeout,\n  setDefaultAutoSelectFamilyAttemptTimeout,\n};\n"
    },
    "123": {
      "sourceCode": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeIndexOf,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberParseInt,\n  ObjectDefineProperties,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  Promise,\n  SafeSet,\n  Symbol,\n  SymbolAsyncDispose,\n  SymbolAsyncIterator,\n  SymbolSpecies,\n  TypedArrayPrototypeSet,\n} = primordials;\n\nmodule.exports = Readable;\nReadable.ReadableState = ReadableState;\n\nconst EE = require('events');\nconst { Stream, prependListener } = require('internal/streams/legacy');\nconst { Buffer } = require('buffer');\n\nconst {\n  addAbortSignal,\n} = require('internal/streams/add-abort-signal');\nconst eos = require('internal/streams/end-of-stream');\n\nlet debug = require('internal/util/debuglog').debuglog('stream', (fn) => {\n  debug = fn;\n});\nconst destroyImpl = require('internal/streams/destroy');\nconst {\n  getHighWaterMark,\n  getDefaultHighWaterMark,\n} = require('internal/streams/state');\nconst {\n  kState,\n  // bitfields\n  kObjectMode,\n  kErrorEmitted,\n  kAutoDestroy,\n  kEmitClose,\n  kDestroyed,\n  kClosed,\n  kCloseEmitted,\n  kErrored,\n  kConstructed,\n  kOnConstructed,\n} = require('internal/streams/utils');\n\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_OUT_OF_RANGE,\n    ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT,\n    ERR_UNKNOWN_ENCODING,\n  },\n  AbortError,\n} = require('internal/errors');\nconst { validateObject } = require('internal/validators');\n\nconst FastBuffer = Buffer[SymbolSpecies];\n\nconst { StringDecoder } = require('string_decoder');\nconst from = require('internal/streams/from');\n\nObjectSetPrototypeOf(Readable.prototype, Stream.prototype);\nObjectSetPrototypeOf(Readable, Stream);\nconst nop = () => {};\n\nconst { errorOrDestroy } = destroyImpl;\n\nconst kErroredValue = Symbol('kErroredValue');\nconst kDefaultEncodingValue = Symbol('kDefaultEncodingValue');\nconst kDecoderValue = Symbol('kDecoderValue');\nconst kEncodingValue = Symbol('kEncodingValue');\n\nconst kEnded = 1 << 9;\nconst kEndEmitted = 1 << 10;\nconst kReading = 1 << 11;\nconst kSync = 1 << 12;\nconst kNeedReadable = 1 << 13;\nconst kEmittedReadable = 1 << 14;\nconst kReadableListening = 1 << 15;\nconst kResumeScheduled = 1 << 16;\nconst kMultiAwaitDrain = 1 << 17;\nconst kReadingMore = 1 << 18;\nconst kDataEmitted = 1 << 19;\nconst kDefaultUTF8Encoding = 1 << 20;\nconst kDecoder = 1 << 21;\nconst kEncoding = 1 << 22;\nconst kHasFlowing = 1 << 23;\nconst kFlowing = 1 << 24;\nconst kHasPaused = 1 << 25;\nconst kPaused = 1 << 26;\nconst kDataListening = 1 << 27;\n\n// TODO(benjamingr) it is likely slower to do it this way than with free functions\nfunction makeBitMapDescriptor(bit) {\n  return {\n    enumerable: false,\n    get() { return (this[kState] & bit) !== 0; },\n    set(value) {\n      if (value) this[kState] |= bit;\n      else this[kState] &= ~bit;\n    },\n  };\n}\nObjectDefineProperties(ReadableState.prototype, {\n  objectMode: makeBitMapDescriptor(kObjectMode),\n  ended: makeBitMapDescriptor(kEnded),\n  endEmitted: makeBitMapDescriptor(kEndEmitted),\n  reading: makeBitMapDescriptor(kReading),\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in, therefore we start as\n  // constructed.\n  constructed: makeBitMapDescriptor(kConstructed),\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  sync: makeBitMapDescriptor(kSync),\n  // Whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  needReadable: makeBitMapDescriptor(kNeedReadable),\n  emittedReadable: makeBitMapDescriptor(kEmittedReadable),\n  readableListening: makeBitMapDescriptor(kReadableListening),\n  resumeScheduled: makeBitMapDescriptor(kResumeScheduled),\n  // True if the error was already emitted and should not be thrown again.\n  errorEmitted: makeBitMapDescriptor(kErrorEmitted),\n  emitClose: makeBitMapDescriptor(kEmitClose),\n  autoDestroy: makeBitMapDescriptor(kAutoDestroy),\n  // Has it been destroyed.\n  destroyed: makeBitMapDescriptor(kDestroyed),\n  // Indicates whether the stream has finished destroying.\n  closed: makeBitMapDescriptor(kClosed),\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  closeEmitted: makeBitMapDescriptor(kCloseEmitted),\n  multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),\n  // If true, a maybeReadMore has been scheduled.\n  readingMore: makeBitMapDescriptor(kReadingMore),\n  dataEmitted: makeBitMapDescriptor(kDataEmitted),\n\n  // Indicates whether the stream has errored. When true no further\n  // _read calls, 'data' or 'readable' events should occur. This is needed\n  // since when autoDestroy is disabled we need a way to tell whether the\n  // stream has failed.\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return (this[kState] & kErrored) !== 0 ? this[kErroredValue] : null;\n    },\n    set(value) {\n      if (value) {\n        this[kErroredValue] = value;\n        this[kState] |= kErrored;\n      } else {\n        this[kState] &= ~kErrored;\n      }\n    },\n  },\n\n  defaultEncoding: {\n    __proto__: null,\n    enumerable: false,\n    get() { return (this[kState] & kDefaultUTF8Encoding) !== 0 ? 'utf8' : this[kDefaultEncodingValue]; },\n    set(value) {\n      if (value === 'utf8' || value === 'utf-8') {\n        this[kState] |= kDefaultUTF8Encoding;\n      } else {\n        this[kState] &= ~kDefaultUTF8Encoding;\n        this[kDefaultEncodingValue] = value;\n      }\n    },\n  },\n\n  decoder: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return (this[kState] & kDecoder) !== 0 ? this[kDecoderValue] : null;\n    },\n    set(value) {\n      if (value) {\n        this[kDecoderValue] = value;\n        this[kState] |= kDecoder;\n      } else {\n        this[kState] &= ~kDecoder;\n      }\n    },\n  },\n\n  encoding: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return (this[kState] & kEncoding) !== 0 ? this[kEncodingValue] : null;\n    },\n    set(value) {\n      if (value) {\n        this[kEncodingValue] = value;\n        this[kState] |= kEncoding;\n      } else {\n        this[kState] &= ~kEncoding;\n      }\n    },\n  },\n\n  flowing: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return (this[kState] & kHasFlowing) !== 0 ? (this[kState] & kFlowing) !== 0 : null;\n    },\n    set(value) {\n      if (value == null) {\n        this[kState] &= ~(kHasFlowing | kFlowing);\n      } else if (value) {\n        this[kState] |= (kHasFlowing | kFlowing);\n      } else {\n        this[kState] |= kHasFlowing;\n        this[kState] &= ~kFlowing;\n      }\n    },\n  },\n});\n\n\nfunction ReadableState(options, stream, isDuplex) {\n  // Bit map field to store ReadableState more effciently with 1 bit per field\n  // instead of a V8 slot per field.\n  this[kState] = kEmitClose | kAutoDestroy | kConstructed | kSync;\n\n  // Object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away.\n  if (options && options.objectMode)\n    this[kState] |= kObjectMode;\n\n  if (isDuplex && options && options.readableObjectMode)\n    this[kState] |= kObjectMode;\n\n  // The point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = options ?\n    getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex) :\n    getDefaultHighWaterMark(false);\n\n  this.buffer = [];\n  this.bufferIndex = 0;\n  this.length = 0;\n  this.pipes = [];\n\n  // Should close be emitted on destroy. Defaults to true.\n  if (options && options.emitClose === false) this[kState] &= ~kEmitClose;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  if (options && options.autoDestroy === false) this[kState] &= ~kAutoDestroy;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  const defaultEncoding = options?.defaultEncoding;\n  if (defaultEncoding == null || defaultEncoding === 'utf8' || defaultEncoding === 'utf-8') {\n    this[kState] |= kDefaultUTF8Encoding;\n  } else if (Buffer.isEncoding(defaultEncoding)) {\n    this.defaultEncoding = defaultEncoding;\n  } else {\n    throw new ERR_UNKNOWN_ENCODING(defaultEncoding);\n  }\n\n  // Ref the piped dest which we need a drain event on it\n  // type: null | Writable | Set<Writable>.\n  this.awaitDrainWriters = null;\n\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nReadableState.prototype[kOnConstructed] = function onConstructed(stream) {\n  if ((this[kState] & kNeedReadable) !== 0) {\n    maybeReadMore(stream, this);\n  }\n};\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._events ??= {\n    close: undefined,\n    error: undefined,\n    data: undefined,\n    end: undefined,\n    readable: undefined,\n    // Skip uncommon events...\n    // pause: undefined,\n    // resume: undefined,\n    // pipe: undefined,\n    // unpipe: undefined,\n    // [destroyImpl.kConstruct]: undefined,\n    // [destroyImpl.kDestroy]: undefined,\n  };\n\n  this._readableState = new ReadableState(options, this, false);\n\n  if (options) {\n    if (typeof options.read === 'function')\n      this._read = options.read;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.construct === 'function')\n      this._construct = options.construct;\n\n    if (options.signal)\n      addAbortSignal(options.signal, this);\n  }\n\n  Stream.call(this, options);\n\n  if (this._construct != null) {\n    destroyImpl.construct(this, () => {\n      this._readableState[kOnConstructed](this);\n    });\n  }\n}\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function(err, cb) {\n  cb(err);\n};\n\nReadable.prototype[EE.captureRejectionSymbol] = function(err) {\n  this.destroy(err);\n};\n\nReadable.prototype[SymbolAsyncDispose] = function() {\n  let error;\n  if (!this.destroyed) {\n    error = this.readableEnded ? null : new AbortError();\n    this.destroy(error);\n  }\n  return new Promise((resolve, reject) => eos(this, (err) => (err && err !== error ? reject(err) : resolve(null))));\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  debug('push', chunk);\n\n  const state = this._readableState;\n  return (state[kState] & kObjectMode) === 0 ?\n    readableAddChunkPushByteMode(this, state, chunk, encoding) :\n    readableAddChunkPushObjectMode(this, state, chunk, encoding);\n};\n\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function(chunk, encoding) {\n  debug('unshift', chunk);\n  const state = this._readableState;\n  return (state[kState] & kObjectMode) === 0 ?\n    readableAddChunkUnshiftByteMode(this, state, chunk, encoding) :\n    readableAddChunkUnshiftObjectMode(this, state, chunk);\n};\n\n\nfunction readableAddChunkUnshiftByteMode(stream, state, chunk, encoding) {\n  if (chunk === null) {\n    state[kState] &= ~kReading;\n    onEofChunk(stream, state);\n\n    return false;\n  }\n\n  if (typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (state.encoding !== encoding) {\n      if (state.encoding) {\n        // When unshifting, if state.encoding is set, we have to save\n        // the string in the BufferList with the state encoding.\n        chunk = Buffer.from(chunk, encoding).toString(state.encoding);\n      } else {\n        chunk = Buffer.from(chunk, encoding);\n      }\n    }\n  } else if (Stream._isUint8Array(chunk)) {\n    chunk = Stream._uint8ArrayToBuffer(chunk);\n  } else if (chunk !== undefined && !(chunk instanceof Buffer)) {\n    errorOrDestroy(stream, new ERR_INVALID_ARG_TYPE(\n      'chunk', ['string', 'Buffer', 'Uint8Array'], chunk));\n    return false;\n  }\n\n\n  if (!(chunk && chunk.length > 0)) {\n    return canPushMore(state);\n  }\n\n  return readableAddChunkUnshiftValue(stream, state, chunk);\n}\n\nfunction readableAddChunkUnshiftObjectMode(stream, state, chunk) {\n  if (chunk === null) {\n    state[kState] &= ~kReading;\n    onEofChunk(stream, state);\n\n    return false;\n  }\n\n  return readableAddChunkUnshiftValue(stream, state, chunk);\n}\n\nfunction readableAddChunkUnshiftValue(stream, state, chunk) {\n  if ((state[kState] & kEndEmitted) !== 0)\n    errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\n  else if ((state[kState] & (kDestroyed | kErrored)) !== 0)\n    return false;\n  else\n    addChunk(stream, state, chunk, true);\n\n  return canPushMore(state);\n}\n\nfunction readableAddChunkPushByteMode(stream, state, chunk, encoding) {\n  if (chunk === null) {\n    state[kState] &= ~kReading;\n    onEofChunk(stream, state);\n    return false;\n  }\n\n  if (typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (state.encoding !== encoding) {\n      chunk = Buffer.from(chunk, encoding);\n      encoding = '';\n    }\n  } else if (chunk instanceof Buffer) {\n    encoding = '';\n  } else if (Stream._isUint8Array(chunk)) {\n    chunk = Stream._uint8ArrayToBuffer(chunk);\n    encoding = '';\n  } else if (chunk !== undefined) {\n    errorOrDestroy(stream, new ERR_INVALID_ARG_TYPE(\n      'chunk', ['string', 'Buffer', 'Uint8Array'], chunk));\n    return false;\n  }\n\n  if (!chunk || chunk.length <= 0) {\n    state[kState] &= ~kReading;\n    maybeReadMore(stream, state);\n\n    return canPushMore(state);\n  }\n\n  if ((state[kState] & kEnded) !== 0) {\n    errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n    return false;\n  }\n\n  if ((state[kState] & (kDestroyed | kErrored)) !== 0) {\n    return false;\n  }\n\n  state[kState] &= ~kReading;\n  if ((state[kState] & kDecoder) !== 0 && !encoding) {\n    chunk = state[kDecoderValue].write(chunk);\n    if (chunk.length === 0) {\n      maybeReadMore(stream, state);\n      return canPushMore(state);\n    }\n  }\n\n  addChunk(stream, state, chunk, false);\n  return canPushMore(state);\n}\n\nfunction readableAddChunkPushObjectMode(stream, state, chunk, encoding) {\n  if (chunk === null) {\n    state[kState] &= ~kReading;\n    onEofChunk(stream, state);\n    return false;\n  }\n\n  if ((state[kState] & kEnded) !== 0) {\n    errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n    return false;\n  }\n\n  if ((state[kState] & (kDestroyed | kErrored)) !== 0) {\n    return false;\n  }\n\n  state[kState] &= ~kReading;\n\n  if ((state[kState] & kDecoder) !== 0 && !encoding) {\n    chunk = state[kDecoderValue].write(chunk);\n  }\n\n  addChunk(stream, state, chunk, false);\n  return canPushMore(state);\n}\n\nfunction canPushMore(state) {\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return (state[kState] & kEnded) === 0 &&\n    (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if ((state[kState] & (kFlowing | kSync | kDataListening)) === (kFlowing | kDataListening) && state.length === 0) {\n    // Use the guard to avoid creating `Set()` repeatedly\n    // when we have multiple pipes.\n    if ((state[kState] & kMultiAwaitDrain) !== 0) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n\n    state[kState] |= kDataEmitted;\n    stream.emit('data', chunk);\n  } else {\n    // Update the buffer info.\n    state.length += (state[kState] & kObjectMode) !== 0 ? 1 : chunk.length;\n    if (addToFront) {\n      if (state.bufferIndex > 0) {\n        state.buffer[--state.bufferIndex] = chunk;\n      } else {\n        state.buffer.unshift(chunk); // Slow path\n      }\n    } else {\n      state.buffer.push(chunk);\n    }\n\n    if ((state[kState] & kNeedReadable) !== 0)\n      emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nReadable.prototype.isPaused = function() {\n  const state = this._readableState;\n  return (state[kState] & kPaused) !== 0 || (state[kState] & (kHasFlowing | kFlowing)) === kHasFlowing;\n};\n\n// Backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  const state = this._readableState;\n\n  const decoder = new StringDecoder(enc);\n  state.decoder = decoder;\n  // If setEncoding(null), decoder.encoding equals utf8.\n  state.encoding = state.decoder.encoding;\n\n  // Iterate over current buffer to convert already stored Buffers:\n  let content = '';\n  for (const data of state.buffer.slice(state.bufferIndex)) {\n    content += decoder.write(data);\n  }\n  state.buffer.length = 0;\n  state.bufferIndex = 0;\n\n  if (content !== '')\n    state.buffer.push(content);\n  state.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n > MAX_HWM) {\n    throw new ERR_OUT_OF_RANGE('size', '<= 1GiB', n);\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts.\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || (state.length === 0 && (state[kState] & kEnded) !== 0))\n    return 0;\n  if ((state[kState] & kObjectMode) !== 0)\n    return 1;\n  if (NumberIsNaN(n)) {\n    // Only flow one buffer at a time.\n    if ((state[kState] & kFlowing) !== 0 && state.length)\n      return state.buffer[state.bufferIndex].length;\n    return state.length;\n  }\n  if (n <= state.length)\n    return n;\n  return (state[kState] & kEnded) !== 0 ? state.length : 0;\n}\n\n// You can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  // Same as parseInt(undefined, 10), however V8 7.3 performance regressed\n  // in this scenario, so we are doing it manually.\n  if (n === undefined) {\n    n = NaN;\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n, 10);\n  }\n  const state = this._readableState;\n  const nOrig = n;\n\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark)\n    state.highWaterMark = computeNewHighWaterMark(n);\n\n  if (n !== 0)\n    state[kState] &= ~kEmittedReadable;\n\n  // If we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      (state[kState] & kNeedReadable) !== 0 &&\n      ((state.highWaterMark !== 0 ?\n        state.length >= state.highWaterMark :\n        state.length > 0) ||\n       (state[kState] & kEnded) !== 0)) {\n    debug('read: emitReadable');\n    if (state.length === 0 && (state[kState] & kEnded) !== 0)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // If we've ended, and we're now clear, then finish it up.\n  if (n === 0 && (state[kState] & kEnded) !== 0) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  let doRead = (state[kState] & kNeedReadable) !== 0;\n  debug('need readable', doRead);\n\n  // If we currently have less than the highWaterMark, then also read some.\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // However, if we've ended, then there's no point, if we're already\n  // reading, then it's unnecessary, if we're constructing we have to wait,\n  // and if we're destroyed or errored, then it's not allowed,\n  if ((state[kState] & (kReading | kEnded | kDestroyed | kErrored | kConstructed)) !== kConstructed) {\n    doRead = false;\n    debug('reading, ended or constructing', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state[kState] |= kReading | kSync;\n    // If the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state[kState] |= kNeedReadable;\n\n    // Call internal read method\n    try {\n      this._read(state.highWaterMark);\n    } catch (err) {\n      errorOrDestroy(this, err);\n    }\n    state[kState] &= ~kSync;\n\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if ((state[kState] & kReading) === 0)\n      n = howMuchToRead(nOrig, state);\n  }\n\n  let ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state[kState] |= state.length <= state.highWaterMark ? kNeedReadable : 0;\n    n = 0;\n  } else {\n    state.length -= n;\n    if ((state[kState] & kMultiAwaitDrain) !== 0) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if ((state[kState] & kEnded) === 0)\n      state[kState] |= kNeedReadable;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && (state[kState] & kEnded) !== 0)\n      endReadable(this);\n  }\n\n  if (ret !== null && (state[kState] & (kErrorEmitted | kCloseEmitted)) === 0) {\n    state[kState] |= kDataEmitted;\n    this.emit('data', ret);\n  }\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if ((state[kState] & kEnded) !== 0) return;\n  const decoder = (state[kState] & kDecoder) !== 0 ? state[kDecoderValue] : null;\n  if (decoder) {\n    const chunk = decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += (state[kState] & kObjectMode) !== 0 ? 1 : chunk.length;\n    }\n  }\n  state[kState] |= kEnded;\n\n  if ((state[kState] & kSync) !== 0) {\n    // If we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    emitReadable(stream);\n  } else {\n    // Emit 'readable' now to make sure it gets picked up.\n    state[kState] &= ~kNeedReadable;\n    state[kState] |= kEmittedReadable;\n    // We have to emit readable now that we are EOF. Modules\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\n    emitReadable_(stream);\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  const state = stream._readableState;\n  debug('emitReadable');\n  state[kState] &= ~kNeedReadable;\n  if ((state[kState] & kEmittedReadable) === 0) {\n    debug('emitReadable', (state[kState] & kFlowing) !== 0);\n    state[kState] |= kEmittedReadable;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  const state = stream._readableState;\n  debug('emitReadable_');\n  if ((state[kState] & (kDestroyed | kErrored)) === 0 && (state.length || (state[kState] & kEnded) !== 0)) {\n    stream.emit('readable');\n    state[kState] &= ~kEmittedReadable;\n  }\n\n  // The stream needs another readable event if:\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state[kState] |=\n    (state[kState] & (kFlowing | kEnded)) === 0 &&\n    state.length <= state.highWaterMark ? kNeedReadable : 0;\n  flow(stream);\n}\n\n\n// At this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if ((state[kState] & (kReadingMore | kConstructed)) === kConstructed) {\n    state[kState] |= kReadingMore;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while ((state[kState] & (kReading | kEnded)) === 0 &&\n         (state.length < state.highWaterMark ||\n          ((state[kState] & kFlowing) !== 0 && state.length === 0))) {\n    const len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // Didn't get any data, stop spinning.\n      break;\n  }\n  state[kState] &= ~kReadingMore;\n}\n\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()');\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  const src = this;\n  const state = this._readableState;\n\n  if (state.pipes.length === 1) {\n    if ((state[kState] & kMultiAwaitDrain) === 0) {\n      state[kState] |= kMultiAwaitDrain;\n      state.awaitDrainWriters = new SafeSet(\n        state.awaitDrainWriters ? [state.awaitDrainWriters] : [],\n      );\n    }\n  }\n\n  state.pipes.push(dest);\n  debug('pipe count=%d opts=%j', state.pipes.length, pipeOpts);\n\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  const endFn = doEnd ? onend : unpipe;\n  if ((state[kState] & kEndEmitted) !== 0)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  let ondrain;\n\n  let cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // Cleanup event handlers once the pipe is broken.\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    if (ondrain) {\n      dest.removeListener('drain', ondrain);\n    }\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // If the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (ondrain && state.awaitDrainWriters &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  function pause() {\n    // If the user unpiped during `dest.write()`, it is possible\n    // to get stuck in a permanently paused state if that write\n    // also returned false.\n    // => Check whether `dest` is still a piping destination.\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug('false write response, pause', 0);\n        state.awaitDrainWriters = dest;\n        state[kState] &= ~kMultiAwaitDrain;\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug('false write response, pause', state.awaitDrainWriters.size);\n        state.awaitDrainWriters.add(dest);\n      }\n      src.pause();\n    }\n    if (!ondrain) {\n      // When the dest drains, it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow(), but adding and removing repeatedly is\n      // too slow.\n      ondrain = pipeOnDrain(src, dest);\n      dest.on('drain', ondrain);\n    }\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    const ret = dest.write(chunk);\n    debug('dest.write', ret);\n    if (ret === false) {\n      pause();\n    }\n  }\n\n  // If the dest has an error, then stop piping into it.\n  // However, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (dest.listenerCount('error') === 0) {\n      const s = dest._writableState || dest._readableState;\n      if (s && !s.errorEmitted) {\n        // User incorrectly emitted 'error' directly on the stream.\n        errorOrDestroy(dest, er);\n      } else {\n        dest.emit('error', er);\n      }\n    }\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // Tell the dest that it's being piped to.\n  dest.emit('pipe', src);\n\n  // Start the flow if it hasn't been started already.\n\n  if (dest.writableNeedDrain === true) {\n    pause();\n  } else if ((state[kState] & kFlowing) === 0) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src, dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState;\n\n    // `ondrain` will call directly,\n    // `this` maybe not a reference to dest,\n    // so we use the real dest here.\n    if (state.awaitDrainWriters === dest) {\n      debug('pipeOnDrain', 1);\n      state.awaitDrainWriters = null;\n    } else if ((state[kState] & kMultiAwaitDrain) !== 0) {\n      debug('pipeOnDrain', state.awaitDrainWriters.size);\n      state.awaitDrainWriters.delete(dest);\n    }\n\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) &&\n      (state[kState] & kDataListening) !== 0) {\n      src.resume();\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  const state = this._readableState;\n  const unpipeInfo = { hasUnpiped: false };\n\n  // If we're not piping anywhere, then do nothing.\n  if (state.pipes.length === 0)\n    return this;\n\n  if (!dest) {\n    // remove all.\n    const dests = state.pipes;\n    state.pipes = [];\n    this.pause();\n\n    for (let i = 0; i < dests.length; i++)\n      dests[i].emit('unpipe', this, { hasUnpiped: false });\n    return this;\n  }\n\n  // Try to find the right one.\n  const index = ArrayPrototypeIndexOf(state.pipes, dest);\n  if (index === -1)\n    return this;\n\n  state.pipes.splice(index, 1);\n  if (state.pipes.length === 0)\n    this.pause();\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function(ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn);\n  const state = this._readableState;\n\n  if (ev === 'data') {\n    state[kState] |= kDataListening;\n\n    // Update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state[kState] |= this.listenerCount('readable') > 0 ? kReadableListening : 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused.\n    if ((state[kState] & (kHasFlowing | kFlowing)) !== kHasFlowing) {\n      this.resume();\n    }\n  } else if (ev === 'readable') {\n    if ((state[kState] & (kEndEmitted | kReadableListening)) === 0) {\n      state[kState] |= kReadableListening | kNeedReadable | kHasFlowing;\n      state[kState] &= ~(kFlowing | kEmittedReadable);\n      debug('on readable');\n      if (state.length) {\n        emitReadable(this);\n      } else if ((state[kState] & kReading) === 0) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function(ev, fn) {\n  const state = this._readableState;\n\n  const res = Stream.prototype.removeListener.call(this,\n                                                   ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  } else if (ev === 'data' && this.listenerCount('data') === 0) {\n    state[kState] &= ~kDataListening;\n  }\n\n  return res;\n};\nReadable.prototype.off = Readable.prototype.removeListener;\n\nReadable.prototype.removeAllListeners = function(ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this,\n                                                        arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  const state = self._readableState;\n\n  if (self.listenerCount('readable') > 0) {\n    state[kState] |= kReadableListening;\n  } else {\n    state[kState] &= ~kReadableListening;\n  }\n\n  if ((state[kState] & (kHasPaused | kPaused | kResumeScheduled)) === (kHasPaused | kResumeScheduled)) {\n    // Flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state[kState] |= kHasFlowing | kFlowing;\n\n    // Crude way to check if we should resume.\n  } else if ((state[kState] & kDataListening) !== 0) {\n    self.resume();\n  } else if ((state[kState] & kReadableListening) === 0) {\n    state[kState] &= ~(kHasFlowing | kFlowing);\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  const state = this._readableState;\n  if ((state[kState] & kFlowing) === 0) {\n    debug('resume');\n    // We flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume().\n    state[kState] |= kHasFlowing;\n    if ((state[kState] & kReadableListening) === 0) {\n      state[kState] |= kFlowing;\n    } else {\n      state[kState] &= ~kFlowing;\n    }\n    resume(this, state);\n  }\n  state[kState] |= kHasPaused;\n  state[kState] &= ~kPaused;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if ((state[kState] & kResumeScheduled) === 0) {\n    state[kState] |= kResumeScheduled;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', (state[kState] & kReading) !== 0);\n  if ((state[kState] & kReading) === 0) {\n    stream.read(0);\n  }\n\n  state[kState] &= ~kResumeScheduled;\n  stream.emit('resume');\n  flow(stream);\n  if ((state[kState] & (kFlowing | kReading)) === kFlowing)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  const state = this._readableState;\n  debug('call pause');\n  if ((state[kState] & (kHasFlowing | kFlowing)) !== kHasFlowing) {\n    debug('pause');\n    state[kState] |= kHasFlowing;\n    state[kState] &= ~kFlowing;\n    this.emit('pause');\n  }\n  state[kState] |= kHasPaused | kPaused;\n  return this;\n};\n\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug('flow');\n  while ((state[kState] & kFlowing) !== 0 && stream.read() !== null);\n}\n\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  let paused = false;\n\n  // TODO (ronag): Should this.destroy(err) emit\n  // 'error' on the wrapped stream? Would require\n  // a static factory method, e.g. Readable.wrap(stream).\n\n  stream.on('data', (chunk) => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  stream.on('end', () => {\n    this.push(null);\n  });\n\n  stream.on('error', (err) => {\n    errorOrDestroy(this, err);\n  });\n\n  stream.on('close', () => {\n    this.destroy();\n  });\n\n  stream.on('destroy', () => {\n    this.destroy();\n  });\n\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\n  const streamKeys = ObjectKeys(stream);\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j];\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = stream[i].bind(stream);\n    }\n  }\n\n  return this;\n};\n\nReadable.prototype[SymbolAsyncIterator] = function() {\n  return streamToAsyncIterator(this);\n};\n\nReadable.prototype.iterator = function(options) {\n  if (options !== undefined) {\n    validateObject(options, 'options');\n  }\n  return streamToAsyncIterator(this, options);\n};\n\nfunction streamToAsyncIterator(stream, options) {\n  if (typeof stream.read !== 'function') {\n    stream = Readable.wrap(stream, { objectMode: true });\n  }\n\n  const iter = createAsyncIterator(stream, options);\n  iter.stream = stream;\n  return iter;\n}\n\nasync function* createAsyncIterator(stream, options) {\n  let callback = nop;\n\n  function next(resolve) {\n    if (this === stream) {\n      callback();\n      callback = nop;\n    } else {\n      callback = resolve;\n    }\n  }\n\n  stream.on('readable', next);\n\n  let error;\n  const cleanup = eos(stream, { writable: false }, (err) => {\n    error = err ? aggregateTwoErrors(error, err) : null;\n    callback();\n    callback = nop;\n  });\n\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read();\n      if (chunk !== null) {\n        yield chunk;\n      } else if (error) {\n        throw error;\n      } else if (error === null) {\n        return;\n      } else {\n        await new Promise(next);\n      }\n    }\n  } catch (err) {\n    error = aggregateTwoErrors(error, err);\n    throw error;\n  } finally {\n    if (\n      (error || options?.destroyOnReturn !== false) &&\n      (error === undefined || stream._readableState.autoDestroy)\n    ) {\n      destroyImpl.destroyer(stream, null);\n    } else {\n      stream.off('readable', next);\n      cleanup();\n    }\n  }\n}\n\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype, {\n  readable: {\n    __proto__: null,\n    get() {\n      const r = this._readableState;\n      // r.readable === false means that this is part of a Duplex stream\n      // where the readable side was disabled upon construction.\n      // Compat. The user might manually disable readable side through\n      // deprecated setter.\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted &&\n        !r.endEmitted;\n    },\n    set(val) {\n      // Backwards compat.\n      if (this._readableState) {\n        this._readableState.readable = !!val;\n      }\n    },\n  },\n\n  readableDidRead: {\n    __proto__: null,\n    enumerable: false,\n    get: function() {\n      return this._readableState.dataEmitted;\n    },\n  },\n\n  readableAborted: {\n    __proto__: null,\n    enumerable: false,\n    get: function() {\n      return !!(\n        this._readableState.readable !== false &&\n        (this._readableState.destroyed || this._readableState.errored) &&\n        !this._readableState.endEmitted\n      );\n    },\n  },\n\n  readableHighWaterMark: {\n    __proto__: null,\n    enumerable: false,\n    get: function() {\n      return this._readableState.highWaterMark;\n    },\n  },\n\n  readableBuffer: {\n    __proto__: null,\n    enumerable: false,\n    get: function() {\n      return this._readableState && this._readableState.buffer;\n    },\n  },\n\n  readableFlowing: {\n    __proto__: null,\n    enumerable: false,\n    get: function() {\n      return this._readableState.flowing;\n    },\n    set: function(state) {\n      if (this._readableState) {\n        this._readableState.flowing = state;\n      }\n    },\n  },\n\n  readableLength: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState.length;\n    },\n  },\n\n  readableObjectMode: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.objectMode : false;\n    },\n  },\n\n  readableEncoding: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.encoding : null;\n    },\n  },\n\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.errored : null;\n    },\n  },\n\n  closed: {\n    __proto__: null,\n    get() {\n      return this._readableState ? this._readableState.closed : false;\n    },\n  },\n\n  destroyed: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.destroyed : false;\n    },\n    set(value) {\n      // We ignore the value if the stream\n      // has not been initialized yet.\n      if (!this._readableState) {\n        return;\n      }\n\n      // Backward compatibility, the user is explicitly\n      // managing destroyed.\n      this._readableState.destroyed = value;\n    },\n  },\n\n  readableEnded: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false;\n    },\n  },\n\n});\n\nObjectDefineProperties(ReadableState.prototype, {\n  // Legacy getter for `pipesCount`.\n  pipesCount: {\n    __proto__: null,\n    get() {\n      return this.pipes.length;\n    },\n  },\n\n  // Legacy property for `paused`.\n  paused: {\n    __proto__: null,\n    get() {\n      return (this[kState] & kPaused) !== 0;\n    },\n    set(value) {\n      this[kState] |= kHasPaused;\n      if (value) {\n        this[kState] |= kPaused;\n      } else {\n        this[kState] &= ~kPaused;\n      }\n    },\n  },\n});\n\n// Exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered.\n  if (state.length === 0)\n    return null;\n\n  let idx = state.bufferIndex;\n  let ret;\n\n  const buf = state.buffer;\n  const len = buf.length;\n\n  if ((state[kState] & kObjectMode) !== 0) {\n    ret = buf[idx];\n    buf[idx++] = null;\n  } else if (!n || n >= state.length) {\n    // Read it all, truncate the list.\n    if ((state[kState] & kDecoder) !== 0) {\n      ret = '';\n      while (idx < len) {\n        ret += buf[idx];\n        buf[idx++] = null;\n      }\n    } else if (len - idx === 0) {\n      ret = Buffer.alloc(0);\n    } else if (len - idx === 1) {\n      ret = buf[idx];\n      buf[idx++] = null;\n    } else {\n      ret = Buffer.allocUnsafe(state.length);\n\n      let i = 0;\n      while (idx < len) {\n        TypedArrayPrototypeSet(ret, buf[idx], i);\n        i += buf[idx].length;\n        buf[idx++] = null;\n      }\n    }\n  } else if (n < buf[idx].length) {\n    // `slice` is the same for buffers and strings.\n    ret = buf[idx].slice(0, n);\n    buf[idx] = buf[idx].slice(n);\n  } else if (n === buf[idx].length) {\n    // First chunk is a perfect match.\n    ret = buf[idx];\n    buf[idx++] = null;\n  } else if ((state[kState] & kDecoder) !== 0) {\n    ret = '';\n    while (idx < len) {\n      const str = buf[idx];\n      if (n > str.length) {\n        ret += str;\n        n -= str.length;\n        buf[idx++] = null;\n      } else {\n        if (n === buf.length) {\n          ret += str;\n          buf[idx++] = null;\n        } else {\n          ret += str.slice(0, n);\n          buf[idx] = str.slice(n);\n        }\n        break;\n      }\n    }\n  } else {\n    ret = Buffer.allocUnsafe(n);\n\n    const retLen = n;\n    while (idx < len) {\n      const data = buf[idx];\n      if (n > data.length) {\n        TypedArrayPrototypeSet(ret, data, retLen - n);\n        n -= data.length;\n        buf[idx++] = null;\n      } else {\n        if (n === data.length) {\n          TypedArrayPrototypeSet(ret, data, retLen - n);\n          buf[idx++] = null;\n        } else {\n          TypedArrayPrototypeSet(ret, new FastBuffer(data.buffer, data.byteOffset, n), retLen - n);\n          buf[idx] = new FastBuffer(data.buffer, data.byteOffset + n, data.length - n);\n        }\n        break;\n      }\n    }\n  }\n\n  if (idx === len) {\n    state.buffer.length = 0;\n    state.bufferIndex = 0;\n  } else if (idx > 1024) {\n    state.buffer.splice(0, idx);\n    state.bufferIndex = 0;\n  } else {\n    state.bufferIndex = idx;\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  const state = stream._readableState;\n\n  debug('endReadable');\n  if ((state[kState] & kEndEmitted) === 0) {\n    state[kState] |= kEnded;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT');\n\n  // Check that we didn't get one last unshift.\n  if ((state[kState] & (kErrored | kCloseEmitted | kEndEmitted)) === 0 && state.length === 0) {\n    state[kState] |= kEndEmitted;\n    stream.emit('end');\n\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT, stream);\n    } else if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well.\n      const wState = stream._writableState;\n      const autoDestroy = !wState || (\n        wState.autoDestroy &&\n        // We don't expect the writable to ever 'finish'\n        // if writable is explicitly set to false.\n        (wState.finished || wState.writable === false)\n      );\n\n      if (autoDestroy) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded &&\n    !stream.destroyed;\n  if (writable) {\n    stream.end();\n  }\n}\n\nReadable.from = function(iterable, opts) {\n  return from(Readable, iterable, opts);\n};\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nReadable.fromWeb = function(readableStream, options) {\n  return lazyWebStreams().newStreamReadableFromReadableStream(\n    readableStream,\n    options);\n};\n\nReadable.toWeb = function(streamReadable, options) {\n  return lazyWebStreams().newReadableStreamFromStreamReadable(\n    streamReadable,\n    options);\n};\n\nReadable.wrap = function(src, options) {\n  return new Readable({\n    objectMode: src.readableObjectMode ?? src.objectMode ?? true,\n    ...options,\n    destroy(err, callback) {\n      destroyImpl.destroyer(src, err);\n      callback(err);\n    },\n  }).wrap(src);\n};\n"
    },
    "127": {
      "sourceCode": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nconst {\n  ArrayPrototypeSlice,\n  Error,\n  FunctionPrototypeSymbolHasInstance,\n  ObjectDefineProperty,\n  ObjectDefineProperties,\n  ObjectSetPrototypeOf,\n  StringPrototypeToLowerCase,\n  Symbol,\n  SymbolHasInstance,\n} = primordials;\n\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\n\nconst EE = require('events');\nconst Stream = require('internal/streams/legacy').Stream;\nconst { Buffer } = require('buffer');\nconst destroyImpl = require('internal/streams/destroy');\n\nconst {\n  addAbortSignal,\n} = require('internal/streams/add-abort-signal');\n\nconst {\n  getHighWaterMark,\n  getDefaultHighWaterMark,\n} = require('internal/streams/state');\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED,\n  ERR_STREAM_ALREADY_FINISHED,\n  ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING,\n} = require('internal/errors').codes;\nconst {\n  kState,\n  // bitfields\n  kObjectMode,\n  kErrorEmitted,\n  kAutoDestroy,\n  kEmitClose,\n  kDestroyed,\n  kClosed,\n  kCloseEmitted,\n  kErrored,\n  kConstructed,\n  kOnConstructed,\n} = require('internal/streams/utils');\n\nconst { errorOrDestroy } = destroyImpl;\n\nObjectSetPrototypeOf(Writable.prototype, Stream.prototype);\nObjectSetPrototypeOf(Writable, Stream);\n\nfunction nop() {}\n\nconst kOnFinishedValue = Symbol('kOnFinishedValue');\nconst kErroredValue = Symbol('kErroredValue');\nconst kDefaultEncodingValue = Symbol('kDefaultEncodingValue');\nconst kWriteCbValue = Symbol('kWriteCbValue');\nconst kAfterWriteTickInfoValue = Symbol('kAfterWriteTickInfoValue');\nconst kBufferedValue = Symbol('kBufferedValue');\n\nconst kSync = 1 << 9;\nconst kFinalCalled = 1 << 10;\nconst kNeedDrain = 1 << 11;\nconst kEnding = 1 << 12;\nconst kFinished = 1 << 13;\nconst kDecodeStrings = 1 << 14;\nconst kWriting = 1 << 15;\nconst kBufferProcessing = 1 << 16;\nconst kPrefinished = 1 << 17;\nconst kAllBuffers = 1 << 18;\nconst kAllNoop = 1 << 19;\nconst kOnFinished = 1 << 20;\nconst kHasWritable = 1 << 21;\nconst kWritable = 1 << 22;\nconst kCorked = 1 << 23;\nconst kDefaultUTF8Encoding = 1 << 24;\nconst kWriteCb = 1 << 25;\nconst kExpectWriteCb = 1 << 26;\nconst kAfterWriteTickInfo = 1 << 27;\nconst kAfterWritePending = 1 << 28;\nconst kBuffered = 1 << 29;\nconst kEnded = 1 << 30;\n\n// TODO(benjamingr) it is likely slower to do it this way than with free functions\nfunction makeBitMapDescriptor(bit) {\n  return {\n    enumerable: false,\n    get() { return (this[kState] & bit) !== 0; },\n    set(value) {\n      if (value) this[kState] |= bit;\n      else this[kState] &= ~bit;\n    },\n  };\n}\nObjectDefineProperties(WritableState.prototype, {\n  // Object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  objectMode: makeBitMapDescriptor(kObjectMode),\n\n  // if _final has been called.\n  finalCalled: makeBitMapDescriptor(kFinalCalled),\n\n  // drain event flag.\n  needDrain: makeBitMapDescriptor(kNeedDrain),\n\n  // At the start of calling end()\n  ending: makeBitMapDescriptor(kEnding),\n\n  // When end() has been called, and returned.\n  ended: makeBitMapDescriptor(kEnded),\n\n  // When 'finish' is emitted.\n  finished: makeBitMapDescriptor(kFinished),\n\n  // Has it been destroyed.\n  destroyed: makeBitMapDescriptor(kDestroyed),\n\n  // Should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  decodeStrings: makeBitMapDescriptor(kDecodeStrings),\n\n  // A flag to see when we're in the middle of a write.\n  writing: makeBitMapDescriptor(kWriting),\n\n  // A flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  sync: makeBitMapDescriptor(kSync),\n\n  // A flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  bufferProcessing: makeBitMapDescriptor(kBufferProcessing),\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in, therefore we start as\n  // constructed.\n  constructed: makeBitMapDescriptor(kConstructed),\n\n  // Emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams.\n  prefinished: makeBitMapDescriptor(kPrefinished),\n\n  // True if the error was already emitted and should not be thrown again.\n  errorEmitted: makeBitMapDescriptor(kErrorEmitted),\n\n  // Should close be emitted on destroy. Defaults to true.\n  emitClose: makeBitMapDescriptor(kEmitClose),\n\n  // Should .destroy() be called after 'finish' (and potentially 'end').\n  autoDestroy: makeBitMapDescriptor(kAutoDestroy),\n\n  // Indicates whether the stream has finished destroying.\n  closed: makeBitMapDescriptor(kClosed),\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  closeEmitted: makeBitMapDescriptor(kCloseEmitted),\n\n  allBuffers: makeBitMapDescriptor(kAllBuffers),\n  allNoop: makeBitMapDescriptor(kAllNoop),\n\n  // Indicates whether the stream has errored. When true all write() calls\n  // should return false. This is needed since when autoDestroy\n  // is disabled we need a way to tell whether the stream has failed.\n  // This is/should be a cold path.\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() { return (this[kState] & kErrored) !== 0 ? this[kErroredValue] : null; },\n    set(value) {\n      if (value) {\n        this[kErroredValue] = value;\n        this[kState] |= kErrored;\n      } else {\n        this[kState] &= ~kErrored;\n      }\n    },\n  },\n\n  writable: {\n    __proto__: null,\n    enumerable: false,\n    get() { return (this[kState] & kHasWritable) !== 0 ? (this[kState] & kWritable) !== 0 : undefined; },\n    set(value) {\n      if (value == null) {\n        this[kState] &= ~(kHasWritable | kWritable);\n      } else if (value) {\n        this[kState] |= (kHasWritable | kWritable);\n      } else {\n        this[kState] |= kHasWritable;\n        this[kState] &= ~kWritable;\n      }\n    },\n  },\n\n  defaultEncoding: {\n    __proto__: null,\n    enumerable: false,\n    get() { return (this[kState] & kDefaultUTF8Encoding) !== 0 ? 'utf8' : this[kDefaultEncodingValue]; },\n    set(value) {\n      if (value === 'utf8' || value === 'utf-8') {\n        this[kState] |= kDefaultUTF8Encoding;\n      } else {\n        this[kState] &= ~kDefaultUTF8Encoding;\n        this[kDefaultEncodingValue] = value;\n      }\n    },\n  },\n\n  // The callback that the user supplies to write(chunk, encoding, cb).\n  writecb: {\n    __proto__: null,\n    enumerable: false,\n    get() { return (this[kState] & kWriteCb) !== 0 ? this[kWriteCbValue] : nop; },\n    set(value) {\n      if (value) {\n        this[kWriteCbValue] = value;\n        this[kState] |= kWriteCb;\n      } else {\n        this[kState] &= ~kWriteCb;\n      }\n    },\n  },\n\n  // Storage for data passed to the afterWrite() callback in case of\n  // synchronous _write() completion.\n  afterWriteTickInfo: {\n    __proto__: null,\n    enumerable: false,\n    get() { return (this[kState] & kAfterWriteTickInfo) !== 0 ? this[kAfterWriteTickInfoValue] : null; },\n    set(value) {\n      if (value) {\n        this[kAfterWriteTickInfoValue] = value;\n        this[kState] |= kAfterWriteTickInfo;\n      } else {\n        this[kState] &= ~kAfterWriteTickInfo;\n      }\n    },\n  },\n\n  buffered: {\n    __proto__: null,\n    enumerable: false,\n    get() { return (this[kState] & kBuffered) !== 0 ? this[kBufferedValue] : []; },\n    set(value) {\n      this[kBufferedValue] = value;\n      if (value) {\n        this[kState] |= kBuffered;\n      } else {\n        this[kState] &= ~kBuffered;\n      }\n    },\n  },\n\n});\n\nfunction WritableState(options, stream, isDuplex) {\n  // Bit map field to store WritableState more effciently with 1 bit per field\n  // instead of a V8 slot per field.\n  this[kState] = kSync | kConstructed | kEmitClose | kAutoDestroy;\n\n  if (options && options.objectMode)\n    this[kState] |= kObjectMode;\n\n  if (isDuplex && options && options.writableObjectMode)\n    this[kState] |= kObjectMode;\n\n  // The point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write().\n  this.highWaterMark = options ?\n    getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex) :\n    getDefaultHighWaterMark(false);\n\n  if (!options || options.decodeStrings !== false) this[kState] |= kDecodeStrings;\n\n  // Should close be emitted on destroy. Defaults to true.\n  if (options && options.emitClose === false) this[kState] &= ~kEmitClose;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  if (options && options.autoDestroy === false) this[kState] &= ~kAutoDestroy;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  const defaultEncoding = options ? options.defaultEncoding : null;\n  if (defaultEncoding == null || defaultEncoding === 'utf8' || defaultEncoding === 'utf-8') {\n    this[kState] |= kDefaultUTF8Encoding;\n  } else if (Buffer.isEncoding(defaultEncoding)) {\n    this[kState] &= ~kDefaultUTF8Encoding;\n    this[kDefaultEncodingValue] = defaultEncoding;\n  } else {\n    throw new ERR_UNKNOWN_ENCODING(defaultEncoding);\n  }\n\n  // Not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // When true all writes will be buffered until .uncork() call.\n  this.corked = 0;\n\n  // The callback that's passed to _write(chunk, cb).\n  this.onwrite = onwrite.bind(undefined, stream);\n\n  // The amount that is being written when _write is called.\n  this.writelen = 0;\n\n  resetBuffer(this);\n\n  // Number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted.\n  this.pendingcb = 0;\n}\n\nfunction resetBuffer(state) {\n  state[kBufferedValue] = null;\n  state.bufferedIndex = 0;\n  state[kState] |= kAllBuffers | kAllNoop;\n  state[kState] &= ~kBuffered;\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  return (this[kState] & kBuffered) === 0 ? [] : ArrayPrototypeSlice(this.buffered, this.bufferedIndex);\n};\n\nObjectDefineProperty(WritableState.prototype, 'bufferedRequestCount', {\n  __proto__: null,\n  get() {\n    return (this[kState] & kBuffered) === 0 ? 0 : this[kBufferedValue].length - this.bufferedIndex;\n  },\n});\n\nWritableState.prototype[kOnConstructed] = function onConstructed(stream) {\n  if ((this[kState] & kWriting) === 0) {\n    clearBuffer(stream, this);\n  }\n\n  if ((this[kState] & kEnding) !== 0) {\n    finishMaybe(stream, this);\n  }\n};\n\nfunction Writable(options) {\n  if (!(this instanceof Writable))\n    return new Writable(options);\n\n  this._events ??= {\n    close: undefined,\n    error: undefined,\n    prefinish: undefined,\n    finish: undefined,\n    drain: undefined,\n    // Skip uncommon events...\n    // [destroyImpl.kConstruct]: undefined,\n    // [destroyImpl.kDestroy]: undefined,\n  };\n\n  this._writableState = new WritableState(options, this, false);\n\n  if (options) {\n    if (typeof options.write === 'function')\n      this._write = options.write;\n\n    if (typeof options.writev === 'function')\n      this._writev = options.writev;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.final === 'function')\n      this._final = options.final;\n\n    if (typeof options.construct === 'function')\n      this._construct = options.construct;\n\n    if (options.signal)\n      addAbortSignal(options.signal, this);\n  }\n\n  Stream.call(this, options);\n\n  if (this._construct != null) {\n    destroyImpl.construct(this, () => {\n      this._writableState[kOnConstructed](this);\n    });\n  }\n}\n\nObjectDefineProperty(Writable, SymbolHasInstance, {\n  __proto__: null,\n  value: function(object) {\n    if (FunctionPrototypeSymbolHasInstance(this, object)) return true;\n    if (this !== Writable) return false;\n\n    return object && object._writableState instanceof WritableState;\n  },\n});\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction _write(stream, chunk, encoding, cb) {\n  const state = stream._writableState;\n\n  if (cb == null || typeof cb !== 'function') {\n    cb = nop;\n  }\n\n  if (chunk === null) {\n    throw new ERR_STREAM_NULL_VALUES();\n  }\n\n  if ((state[kState] & kObjectMode) === 0) {\n    if (!encoding) {\n      encoding = (state[kState] & kDefaultUTF8Encoding) !== 0 ? 'utf8' : state.defaultEncoding;\n    } else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding)) {\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    }\n\n    if (typeof chunk === 'string') {\n      if ((state[kState] & kDecodeStrings) !== 0) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = 'buffer';\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = 'buffer';\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk);\n      encoding = 'buffer';\n    } else {\n      throw new ERR_INVALID_ARG_TYPE(\n        'chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n    }\n  }\n\n  let err;\n  if ((state[kState] & kEnding) !== 0) {\n    err = new ERR_STREAM_WRITE_AFTER_END();\n  } else if ((state[kState] & kDestroyed) !== 0) {\n    err = new ERR_STREAM_DESTROYED('write');\n  }\n\n  if (err) {\n    process.nextTick(cb, err);\n    errorOrDestroy(stream, err, true);\n    return err;\n  }\n\n  state.pendingcb++;\n  return writeOrBuffer(stream, state, chunk, encoding, cb);\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  if (encoding != null && typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  return _write(this, chunk, encoding, cb) === true;\n};\n\nWritable.prototype.cork = function() {\n  const state = this._writableState;\n\n  state[kState] |= kCorked;\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  const state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.corked) {\n      state[kState] &= ~kCorked;\n    }\n\n    if ((state[kState] & kWriting) === 0)\n      clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string')\n    encoding = StringPrototypeToLowerCase(encoding);\n  if (!Buffer.isEncoding(encoding))\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\n// If we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, callback) {\n  const len = (state[kState] & kObjectMode) !== 0 ? 1 : chunk.length;\n\n  state.length += len;\n\n  if ((state[kState] & (kWriting | kErrored | kCorked | kConstructed)) !== kConstructed) {\n    if ((state[kState] & kBuffered) === 0) {\n      state[kState] |= kBuffered;\n      state[kBufferedValue] = [];\n    }\n\n    state[kBufferedValue].push({ chunk, encoding, callback });\n    if ((state[kState] & kAllBuffers) !== 0 && encoding !== 'buffer') {\n      state[kState] &= ~kAllBuffers;\n    }\n    if ((state[kState] & kAllNoop) !== 0 && callback !== nop) {\n      state[kState] &= ~kAllNoop;\n    }\n  } else {\n    state.writelen = len;\n    if (callback !== nop) {\n      state.writecb = callback;\n    }\n    state[kState] |= kWriting | kSync | kExpectWriteCb;\n    stream._write(chunk, encoding, state.onwrite);\n    state[kState] &= ~kSync;\n  }\n\n  const ret = state.length < state.highWaterMark;\n\n  if (!ret) {\n    state[kState] |= kNeedDrain;\n  }\n\n  // Return false if errored or destroyed in order to break\n  // any synchronous while(stream.write(data)) loops.\n  return ret && (state[kState] & (kDestroyed | kErrored)) === 0;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  if (cb !== nop) {\n    state.writecb = cb;\n  }\n  state[kState] |= kWriting | kSync | kExpectWriteCb;\n  if ((state[kState] & kDestroyed) !== 0)\n    state.onwrite(new ERR_STREAM_DESTROYED('write'));\n  else if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state[kState] &= ~kSync;\n}\n\nfunction onwriteError(stream, state, er, cb) {\n  --state.pendingcb;\n\n  cb(er);\n  // Ensure callbacks are invoked even when autoDestroy is\n  // not enabled. Passing `er` here doesn't make sense since\n  // it's related to one specific write, not to the buffered\n  // writes.\n  errorBuffer(state);\n  // This can emit error, but error must always follow cb.\n  errorOrDestroy(stream, er);\n}\n\nfunction onwrite(stream, er) {\n  const state = stream._writableState;\n\n  if ((state[kState] & kExpectWriteCb) === 0) {\n    errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());\n    return;\n  }\n\n  const sync = (state[kState] & kSync) !== 0;\n  const cb = (state[kState] & kWriteCb) !== 0 ? state[kWriteCbValue] : nop;\n\n  state[kState] &= ~(kWriting | kExpectWriteCb | kWriteCb);\n  state.length -= state.writelen;\n  state.writelen = 0;\n\n  if (er) {\n    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    er.stack; // eslint-disable-line no-unused-expressions\n\n    if ((state[kState] & kErrored) === 0) {\n      state[kErroredValue] = er;\n      state[kState] |= kErrored;\n    }\n\n    // In case of duplex streams we need to notify the readable side of the\n    // error.\n    if (stream._readableState && !stream._readableState.errored) {\n      stream._readableState.errored = er;\n    }\n\n    if (sync) {\n      process.nextTick(onwriteError, stream, state, er, cb);\n    } else {\n      onwriteError(stream, state, er, cb);\n    }\n  } else {\n    if ((state[kState] & kBuffered) !== 0) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      const needDrain = (state[kState] & kNeedDrain) !== 0 && state.length === 0;\n      const needTick = needDrain || (state[kState] & kDestroyed !== 0) || cb !== nop;\n\n      // It is a common case that the callback passed to .write() is always\n      // the same. In that case, we do not schedule a new nextTick(), but\n      // rather just increase a counter, to improve performance and avoid\n      // memory allocations.\n      if (cb === nop) {\n        if ((state[kState] & kAfterWritePending) === 0 && needTick) {\n          process.nextTick(afterWrite, stream, state, 1, cb);\n          state[kState] |= kAfterWritePending;\n        } else {\n          state.pendingcb--;\n          if ((state[kState] & kEnding) !== 0) {\n            finishMaybe(stream, state, true);\n          }\n        }\n      } else if ((state[kState] & kAfterWriteTickInfo) !== 0 &&\n                 state[kAfterWriteTickInfoValue].cb === cb) {\n        state[kAfterWriteTickInfoValue].count++;\n      } else if (needTick) {\n        state[kAfterWriteTickInfoValue] = { count: 1, cb, stream, state };\n        process.nextTick(afterWriteTick, state[kAfterWriteTickInfoValue]);\n        state[kState] |= (kAfterWritePending | kAfterWriteTickInfo);\n      } else {\n        state.pendingcb--;\n        if ((state[kState] & kEnding) !== 0) {\n          finishMaybe(stream, state, true);\n        }\n      }\n    } else {\n      afterWrite(stream, state, 1, cb);\n    }\n  }\n}\n\nfunction afterWriteTick({ stream, state, count, cb }) {\n  state[kState] &= ~kAfterWriteTickInfo;\n  state[kAfterWriteTickInfoValue] = null;\n  return afterWrite(stream, state, count, cb);\n}\n\nfunction afterWrite(stream, state, count, cb) {\n  state[kState] &= ~kAfterWritePending;\n\n  const needDrain = (state[kState] & (kEnding | kNeedDrain | kDestroyed)) === kNeedDrain && state.length === 0;\n  if (needDrain) {\n    state[kState] &= ~kNeedDrain;\n    stream.emit('drain');\n  }\n\n  while (count-- > 0) {\n    state.pendingcb--;\n    cb(null);\n  }\n\n  if ((state[kState] & kDestroyed) !== 0) {\n    errorBuffer(state);\n  }\n\n  if ((state[kState] & kEnding) !== 0) {\n    finishMaybe(stream, state, true);\n  }\n}\n\n// If there's something in the buffer waiting, then invoke callbacks.\nfunction errorBuffer(state) {\n  if ((state[kState] & kWriting) !== 0) {\n    return;\n  }\n\n  if ((state[kState] & kBuffered) !== 0) {\n    for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n      const { chunk, callback } = state[kBufferedValue][n];\n      const len = (state[kState] & kObjectMode) !== 0 ? 1 : chunk.length;\n      state.length -= len;\n      callback(state.errored ?? new ERR_STREAM_DESTROYED('write'));\n    }\n  }\n\n\n  callFinishedCallbacks(state, state.errored ?? new ERR_STREAM_DESTROYED('end'));\n\n  resetBuffer(state);\n}\n\n// If there's something in the buffer waiting, then process it.\nfunction clearBuffer(stream, state) {\n  if ((state[kState] & (kDestroyed | kBufferProcessing | kCorked | kBuffered)) !== kBuffered) {\n    return;\n  }\n\n  const objectMode = (state[kState] & kObjectMode) !== 0;\n  const { [kBufferedValue]: buffered, bufferedIndex } = state;\n  const bufferedLength = buffered.length - bufferedIndex;\n\n  if (!bufferedLength) {\n    return;\n  }\n\n  let i = bufferedIndex;\n\n  state[kState] |= kBufferProcessing;\n  if (bufferedLength > 1 && stream._writev) {\n    state.pendingcb -= bufferedLength - 1;\n\n    const callback = (state[kState] & kAllNoop) !== 0 ? nop : (err) => {\n      for (let n = i; n < buffered.length; ++n) {\n        buffered[n].callback(err);\n      }\n    };\n    // Make a copy of `buffered` if it's going to be used by `callback` above,\n    // since `doWrite` will mutate the array.\n    const chunks = (state[kState] & kAllNoop) !== 0 && i === 0 ?\n      buffered : ArrayPrototypeSlice(buffered, i);\n    chunks.allBuffers = (state[kState] & kAllBuffers) !== 0;\n\n    doWrite(stream, state, true, state.length, chunks, '', callback);\n\n    resetBuffer(state);\n  } else {\n    do {\n      const { chunk, encoding, callback } = buffered[i];\n      buffered[i++] = null;\n      const len = objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, callback);\n    } while (i < buffered.length && (state[kState] & kWriting) === 0);\n\n    if (i === buffered.length) {\n      resetBuffer(state);\n    } else if (i > 256) {\n      buffered.splice(0, i);\n      state.bufferedIndex = 0;\n    } else {\n      state.bufferedIndex = i;\n    }\n  }\n  state[kState] &= ~kBufferProcessing;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  if (this._writev) {\n    this._writev([{ chunk, encoding }], cb);\n  } else {\n    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()');\n  }\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  const state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  let err;\n\n  if (chunk != null) {\n    const ret = _write(this, chunk, encoding);\n    if (ret instanceof Error) {\n      err = ret;\n    }\n  }\n\n  // .end() fully uncorks.\n  if ((state[kState] & kCorked) !== 0) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  if (err) {\n    // Do nothing...\n  } else if ((state[kState] & (kEnding | kErrored)) === 0) {\n    // This is forgiving in terms of unnecessary calls to end() and can hide\n    // logic errors. However, usually such errors are harmless and causing a\n    // hard error can be disproportionately destructive. It is not always\n    // trivial for the user to determine whether end() needs to be called\n    // or not.\n\n    state[kState] |= kEnding;\n    finishMaybe(this, state, true);\n    state[kState] |= kEnded;\n  } else if ((state[kState] & kFinished) !== 0) {\n    err = new ERR_STREAM_ALREADY_FINISHED('end');\n  } else if ((state[kState] & kDestroyed) !== 0) {\n    err = new ERR_STREAM_DESTROYED('end');\n  }\n\n  if (typeof cb === 'function') {\n    if (err) {\n      process.nextTick(cb, err);\n    } else if ((state[kState] & kErrored) !== 0) {\n      process.nextTick(cb, state[kErroredValue]);\n    } else if ((state[kState] & kFinished) !== 0) {\n      process.nextTick(cb, null);\n    } else {\n      state[kState] |= kOnFinished;\n      state[kOnFinishedValue] ??= [];\n      state[kOnFinishedValue].push(cb);\n    }\n  }\n\n  return this;\n};\n\nfunction needFinish(state) {\n  return (\n    // State is ended && constructed but not destroyed, finished, writing, errorEmitted or closedEmitted\n    (state[kState] & (\n      kEnding |\n          kDestroyed |\n          kConstructed |\n          kFinished |\n          kWriting |\n          kErrorEmitted |\n          kCloseEmitted |\n          kErrored |\n          kBuffered\n    )) === (kEnding | kConstructed) && state.length === 0);\n}\n\nfunction onFinish(stream, state, err) {\n  if ((state[kState] & kPrefinished) !== 0) {\n    errorOrDestroy(stream, err ?? ERR_MULTIPLE_CALLBACK());\n    return;\n  }\n  state.pendingcb--;\n  if (err) {\n    callFinishedCallbacks(state, err);\n    errorOrDestroy(stream, err, (state[kState] & kSync) !== 0);\n  } else if (needFinish(state)) {\n    state[kState] |= kPrefinished;\n    stream.emit('prefinish');\n    // Backwards compat. Don't check state.sync here.\n    // Some streams assume 'finish' will be emitted\n    // asynchronously relative to _final callback.\n    state.pendingcb++;\n    process.nextTick(finish, stream, state);\n  }\n}\n\nfunction prefinish(stream, state) {\n  if ((state[kState] & (kPrefinished | kFinalCalled)) !== 0) {\n    return;\n  }\n\n  if (typeof stream._final === 'function' && (state[kState] & kDestroyed) === 0) {\n    state[kState] |= kFinalCalled | kSync;\n    state.pendingcb++;\n\n    try {\n      stream._final((err) => onFinish(stream, state, err));\n    } catch (err) {\n      onFinish(stream, state, err);\n    }\n\n    state[kState] &= ~kSync;\n  } else {\n    state[kState] |= kFinalCalled | kPrefinished;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state, sync) {\n  if (needFinish(state)) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      if (sync) {\n        state.pendingcb++;\n        process.nextTick((stream, state) => {\n          if (needFinish(state)) {\n            finish(stream, state);\n          } else {\n            state.pendingcb--;\n          }\n        }, stream, state);\n      } else if (needFinish(state)) {\n        state.pendingcb++;\n        finish(stream, state);\n      }\n    }\n  }\n}\n\nfunction finish(stream, state) {\n  state.pendingcb--;\n  state[kState] |= kFinished;\n\n  callFinishedCallbacks(state, null);\n\n  stream.emit('finish');\n\n  if ((state[kState] & kAutoDestroy) !== 0) {\n    // In case of duplex streams we need a way to detect\n    // if the readable side is ready for autoDestroy as well.\n    const rState = stream._readableState;\n    const autoDestroy = !rState || (\n      rState.autoDestroy &&\n      // We don't expect the readable to ever 'end'\n      // if readable is explicitly set to false.\n      (rState.endEmitted || rState.readable === false)\n    );\n    if (autoDestroy) {\n      stream.destroy();\n    }\n  }\n}\n\nfunction callFinishedCallbacks(state, err) {\n  if ((state[kState] & kOnFinished) === 0) {\n    return;\n  }\n\n  const onfinishCallbacks = state[kOnFinishedValue];\n  state[kOnFinishedValue] = null;\n  state[kState] &= ~kOnFinished;\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i](err);\n  }\n}\n\nObjectDefineProperties(Writable.prototype, {\n  closed: {\n    __proto__: null,\n    get() {\n      return this._writableState ? (this._writableState[kState] & kClosed) !== 0 : false;\n    },\n  },\n\n  destroyed: {\n    __proto__: null,\n    get() {\n      return this._writableState ? (this._writableState[kState] & kDestroyed) !== 0 : false;\n    },\n    set(value) {\n      // Backward compatibility, the user is explicitly managing destroyed.\n      if (!this._writableState) return;\n\n      if (value) this._writableState[kState] |= kDestroyed;\n      else this._writableState[kState] &= ~kDestroyed;\n    },\n  },\n\n  writable: {\n    __proto__: null,\n    get() {\n      const w = this._writableState;\n      // w.writable === false means that this is part of a Duplex stream\n      // where the writable side was disabled upon construction.\n      // Compat. The user might manually disable writable side through\n      // deprecated setter.\n      return !!w && w.writable !== false && !w.errored &&\n        (w[kState] & (kEnding | kEnded | kDestroyed)) === 0;\n    },\n    set(val) {\n      // Backwards compatible.\n      if (this._writableState) {\n        this._writableState.writable = !!val;\n      }\n    },\n  },\n\n  writableFinished: {\n    __proto__: null,\n    get() {\n      const state = this._writableState;\n      return state ? (state[kState] & kFinished) !== 0 : false;\n    },\n  },\n\n  writableObjectMode: {\n    __proto__: null,\n    get() {\n      const state = this._writableState;\n      return state ? (state[kState] & kObjectMode) !== 0 : false;\n    },\n  },\n\n  writableBuffer: {\n    __proto__: null,\n    get() {\n      const state = this._writableState;\n      return state && state.getBuffer();\n    },\n  },\n\n  writableEnded: {\n    __proto__: null,\n    get() {\n      const state = this._writableState;\n      return state ? (state[kState] & kEnding) !== 0 : false;\n    },\n  },\n\n  writableNeedDrain: {\n    __proto__: null,\n    get() {\n      const state = this._writableState;\n      return state ? (state[kState] & (kDestroyed | kEnding | kNeedDrain)) === kNeedDrain : false;\n    },\n  },\n\n  writableHighWaterMark: {\n    __proto__: null,\n    get() {\n      const state = this._writableState;\n      return state && state.highWaterMark;\n    },\n  },\n\n  writableCorked: {\n    __proto__: null,\n    get() {\n      const state = this._writableState;\n      return state ? state.corked : 0;\n    },\n  },\n\n  writableLength: {\n    __proto__: null,\n    get() {\n      const state = this._writableState;\n      return state && state.length;\n    },\n  },\n\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      const state = this._writableState;\n      return state ? state.errored : null;\n    },\n  },\n\n  writableAborted: {\n    __proto__: null,\n    get: function() {\n      const state = this._writableState;\n      return (\n        (state[kState] & (kHasWritable | kWritable)) !== kHasWritable &&\n        (state[kState] & (kDestroyed | kErrored)) !== 0 &&\n        (state[kState] & kFinished) === 0\n      );\n    },\n  },\n});\n\nconst destroy = destroyImpl.destroy;\nWritable.prototype.destroy = function(err, cb) {\n  const state = this._writableState;\n\n  // Invoke pending callbacks.\n  if ((state[kState] & (kBuffered | kOnFinished)) !== 0 && (state[kState] & kDestroyed) === 0) {\n    process.nextTick(errorBuffer, state);\n  }\n\n  destroy.call(this, err, cb);\n  return this;\n};\n\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function(err, cb) {\n  cb(err);\n};\n\nWritable.prototype[EE.captureRejectionSymbol] = function(err) {\n  this.destroy(err);\n};\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nWritable.fromWeb = function(writableStream, options) {\n  return lazyWebStreams().newStreamWritableFromWritableStream(\n    writableStream,\n    options);\n};\n\nWritable.toWeb = function(streamWritable) {\n  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\n};\n"
    },
    "131": {
      "sourceCode": "'use strict';\n\nconst {\n  Array,\n  Symbol,\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst { FastBuffer } = require('internal/buffer');\nconst {\n  WriteWrap,\n  kReadBytesOrError,\n  kArrayBufferOffset,\n  kBytesWritten,\n  kLastWriteWasAsync,\n  streamBaseState,\n} = internalBinding('stream_wrap');\nconst { UV_EOF } = internalBinding('uv');\nconst {\n  errnoException,\n} = require('internal/errors');\nconst { owner_symbol } = require('internal/async_hooks').symbols;\nconst {\n  kTimeout,\n  setUnrefTimeout,\n  getTimerDuration,\n} = require('internal/timers');\nconst { isUint8Array } = require('internal/util/types');\nconst { clearTimeout } = require('timers');\nconst { validateFunction } = require('internal/validators');\n\nconst kMaybeDestroy = Symbol('kMaybeDestroy');\nconst kUpdateTimer = Symbol('kUpdateTimer');\nconst kAfterAsyncWrite = Symbol('kAfterAsyncWrite');\nconst kHandle = Symbol('kHandle');\nconst kSession = Symbol('kSession');\n\nlet debug = require('internal/util/debuglog').debuglog('stream', (fn) => {\n  debug = fn;\n});\nconst kBuffer = Symbol('kBuffer');\nconst kBufferGen = Symbol('kBufferGen');\nconst kBufferCb = Symbol('kBufferCb');\n\nfunction handleWriteReq(req, data, encoding) {\n  const { handle } = req;\n\n  switch (encoding) {\n    case 'buffer':\n    {\n      const ret = handle.writeBuffer(req, data);\n      if (streamBaseState[kLastWriteWasAsync])\n        req.buffer = data;\n      return ret;\n    }\n    case 'latin1':\n    case 'binary':\n      return handle.writeLatin1String(req, data);\n    case 'utf8':\n    case 'utf-8':\n      return handle.writeUtf8String(req, data);\n    case 'ascii':\n      return handle.writeAsciiString(req, data);\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return handle.writeUcs2String(req, data);\n    default:\n    {\n      const buffer = Buffer.from(data, encoding);\n      const ret = handle.writeBuffer(req, buffer);\n      if (streamBaseState[kLastWriteWasAsync])\n        req.buffer = buffer;\n      return ret;\n    }\n  }\n}\n\nfunction onWriteComplete(status) {\n  debug('onWriteComplete', status, this.error);\n\n  const stream = this.handle[owner_symbol];\n\n  if (stream.destroyed) {\n    if (typeof this.callback === 'function')\n      this.callback(null);\n    return;\n  }\n\n  // TODO (ronag): This should be moved before if(stream.destroyed)\n  // in order to avoid swallowing error.\n  if (status < 0) {\n    const ex = errnoException(status, 'write', this.error);\n    if (typeof this.callback === 'function')\n      this.callback(ex);\n    else\n      stream.destroy(ex);\n    return;\n  }\n\n  stream[kUpdateTimer]();\n  stream[kAfterAsyncWrite](this);\n\n  if (typeof this.callback === 'function')\n    this.callback(null);\n}\n\nfunction createWriteWrap(handle, callback) {\n  const req = new WriteWrap();\n\n  req.handle = handle;\n  req.oncomplete = onWriteComplete;\n  req.async = false;\n  req.bytes = 0;\n  req.buffer = null;\n  req.callback = callback;\n\n  return req;\n}\n\nfunction writevGeneric(self, data, cb) {\n  const req = createWriteWrap(self[kHandle], cb);\n  const allBuffers = data.allBuffers;\n  let chunks;\n  if (allBuffers) {\n    chunks = data;\n    for (let i = 0; i < data.length; i++)\n      data[i] = data[i].chunk;\n  } else {\n    chunks = new Array(data.length << 1);\n    for (let i = 0; i < data.length; i++) {\n      const entry = data[i];\n      chunks[i * 2] = entry.chunk;\n      chunks[i * 2 + 1] = entry.encoding;\n    }\n  }\n  const err = req.handle.writev(req, chunks, allBuffers);\n\n  // Retain chunks\n  if (err === 0) req._chunks = chunks;\n\n  afterWriteDispatched(req, err, cb);\n  return req;\n}\n\nfunction writeGeneric(self, data, encoding, cb) {\n  const req = createWriteWrap(self[kHandle], cb);\n  const err = handleWriteReq(req, data, encoding);\n\n  afterWriteDispatched(req, err, cb);\n  return req;\n}\n\nfunction afterWriteDispatched(req, err, cb) {\n  req.bytes = streamBaseState[kBytesWritten];\n  req.async = !!streamBaseState[kLastWriteWasAsync];\n\n  if (err !== 0)\n    return cb(errnoException(err, 'write', req.error));\n\n  if (!req.async && typeof req.callback === 'function') {\n    req.callback();\n  }\n}\n\nfunction onStreamRead(arrayBuffer) {\n  const nread = streamBaseState[kReadBytesOrError];\n\n  const handle = this;\n  const stream = this[owner_symbol];\n\n  stream[kUpdateTimer]();\n\n  if (nread > 0 && !stream.destroyed) {\n    let ret;\n    let result;\n    const userBuf = stream[kBuffer];\n    if (userBuf) {\n      result = (stream[kBufferCb](nread, userBuf) !== false);\n      const bufGen = stream[kBufferGen];\n      if (bufGen !== null) {\n        const nextBuf = bufGen();\n        if (isUint8Array(nextBuf))\n          stream[kBuffer] = ret = nextBuf;\n      }\n    } else {\n      const offset = streamBaseState[kArrayBufferOffset];\n      const buf = new FastBuffer(arrayBuffer, offset, nread);\n      result = stream.push(buf);\n    }\n    if (!result) {\n      handle.reading = false;\n      if (!stream.destroyed) {\n        const err = handle.readStop();\n        if (err)\n          stream.destroy(errnoException(err, 'read'));\n      }\n    }\n\n    return ret;\n  }\n\n  if (nread === 0) {\n    return;\n  }\n\n  // After seeing EOF, most streams will be closed permanently,\n  // and will not deliver any more read events after this point.\n  // (equivalently, it should have called readStop on itself already).\n  // Some streams may be reset and explicitly started again with a call\n  // to readStart, such as TTY.\n\n  if (nread !== UV_EOF) {\n    // CallJSOnreadMethod expects the return value to be a buffer.\n    // Ref: https://github.com/nodejs/node/pull/34375\n    stream.destroy(errnoException(nread, 'read'));\n    return;\n  }\n\n  // Defer this until we actually emit end\n  if (stream._readableState.endEmitted) {\n    if (stream[kMaybeDestroy])\n      stream[kMaybeDestroy]();\n  } else {\n    if (stream[kMaybeDestroy])\n      stream.on('end', stream[kMaybeDestroy]);\n\n    // Push a null to signal the end of data.\n    // Do it before `maybeDestroy` for correct order of events:\n    // `end` -> `close`\n    stream.push(null);\n    stream.read(0);\n  }\n}\n\nfunction setStreamTimeout(msecs, callback) {\n  if (this.destroyed)\n    return this;\n\n  this.timeout = msecs;\n\n  // Type checking identical to timers.enroll()\n  msecs = getTimerDuration(msecs, 'msecs');\n\n  // Attempt to clear an existing timer in both cases -\n  //  even if it will be rescheduled we don't want to leak an existing timer.\n  clearTimeout(this[kTimeout]);\n\n  if (msecs === 0) {\n    if (callback !== undefined) {\n      validateFunction(callback, 'callback');\n      this.removeListener('timeout', callback);\n    }\n  } else {\n    this[kTimeout] = setUnrefTimeout(this._onTimeout.bind(this), msecs);\n    if (this[kSession]) this[kSession][kUpdateTimer]();\n\n    if (callback !== undefined) {\n      validateFunction(callback, 'callback');\n      this.once('timeout', callback);\n    }\n  }\n  return this;\n}\n\nmodule.exports = {\n  writevGeneric,\n  writeGeneric,\n  onStreamRead,\n  kAfterAsyncWrite,\n  kMaybeDestroy,\n  kUpdateTimer,\n  kHandle,\n  kSession,\n  setStreamTimeout,\n  kBuffer,\n  kBufferCb,\n  kBufferGen,\n};\n"
    },
    "135": {
      "sourceCode": "// MIT License\n\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeSome,\n  RegExpPrototypeExec,\n  StringPrototypeSplit,\n  StringPrototypeToLowerCase,\n} = primordials;\n\nconst { validateInteger } = require('internal/validators');\n\nlet OSRelease;\n\nconst COLORS_2 = 1;\nconst COLORS_16 = 4;\nconst COLORS_256 = 8;\nconst COLORS_16m = 24;\n\n// Some entries were taken from `dircolors`\n// (https://linux.die.net/man/1/dircolors). The corresponding terminals might\n// support more than 16 colors, but this was not tested for.\n//\n// Copyright (C) 1996-2016 Free Software Foundation, Inc. Copying and\n// distribution of this file, with or without modification, are permitted\n// provided the copyright notice and this notice are preserved.\nconst TERM_ENVS = {\n  'eterm': COLORS_16,\n  'cons25': COLORS_16,\n  'console': COLORS_16,\n  'cygwin': COLORS_16,\n  'dtterm': COLORS_16,\n  'gnome': COLORS_16,\n  'hurd': COLORS_16,\n  'jfbterm': COLORS_16,\n  'konsole': COLORS_16,\n  'kterm': COLORS_16,\n  'mlterm': COLORS_16,\n  'mosh': COLORS_16m,\n  'putty': COLORS_16,\n  'st': COLORS_16,\n  // https://github.com/da-x/rxvt-unicode/tree/v9.22-with-24bit-color\n  'rxvt-unicode-24bit': COLORS_16m,\n  // https://gist.github.com/XVilka/8346728#gistcomment-2823421\n  'terminator': COLORS_16m,\n};\n\nconst TERM_ENVS_REG_EXP = [\n  /ansi/,\n  /color/,\n  /linux/,\n  /^con[0-9]*x[0-9]/,\n  /^rxvt/,\n  /^screen/,\n  /^xterm/,\n  /^vt100/,\n];\n\nlet warned = false;\nfunction warnOnDeactivatedColors(env) {\n  if (warned)\n    return;\n  let name = '';\n  if (env.NODE_DISABLE_COLORS !== undefined)\n    name = 'NODE_DISABLE_COLORS';\n  if (env.NO_COLOR !== undefined) {\n    if (name !== '') {\n      name += \"' and '\";\n    }\n    name += 'NO_COLOR';\n  }\n\n  if (name !== '') {\n    process.emitWarning(\n      `The '${name}' env is ignored due to the 'FORCE_COLOR' env being set.`,\n      'Warning',\n    );\n    warned = true;\n  }\n}\n\n// The `getColorDepth` API got inspired by multiple sources such as\n// https://github.com/chalk/supports-color,\n// https://github.com/isaacs/color-support.\nfunction getColorDepth(env = process.env) {\n  // Use level 0-3 to support the same levels as `chalk` does. This is done for\n  // consistency throughout the ecosystem.\n  if (env.FORCE_COLOR !== undefined) {\n    switch (env.FORCE_COLOR) {\n      case '':\n      case '1':\n      case 'true':\n        warnOnDeactivatedColors(env);\n        return COLORS_16;\n      case '2':\n        warnOnDeactivatedColors(env);\n        return COLORS_256;\n      case '3':\n        warnOnDeactivatedColors(env);\n        return COLORS_16m;\n      default:\n        return COLORS_2;\n    }\n  }\n\n  if (env.NODE_DISABLE_COLORS !== undefined ||\n      // See https://no-color.org/\n      env.NO_COLOR !== undefined ||\n      // The \"dumb\" special terminal, as defined by terminfo, doesn't support\n      // ANSI color control codes.\n      // See https://invisible-island.net/ncurses/terminfo.ti.html#toc-_Specials\n      env.TERM === 'dumb') {\n    return COLORS_2;\n  }\n\n  if (process.platform === 'win32') {\n    // Lazy load for startup performance.\n    if (OSRelease === undefined) {\n      const { release } = require('os');\n      OSRelease = StringPrototypeSplit(release(), '.');\n    }\n    // Windows 10 build 10586 is the first Windows release that supports 256\n    // colors. Windows 10 build 14931 is the first release that supports\n    // 16m/TrueColor.\n    if (+OSRelease[0] >= 10) {\n      const build = +OSRelease[2];\n      if (build >= 14931)\n        return COLORS_16m;\n      if (build >= 10586)\n        return COLORS_256;\n    }\n\n    return COLORS_16;\n  }\n\n  if (env.TMUX) {\n    return COLORS_256;\n  }\n\n  if (env.CI) {\n    if ([\n      'APPVEYOR',\n      'BUILDKITE',\n      'CIRCLECI',\n      'DRONE',\n      'GITHUB_ACTIONS',\n      'GITLAB_CI',\n      'TRAVIS',\n    ].some((sign) => sign in env) || env.CI_NAME === 'codeship') {\n      return COLORS_256;\n    }\n    return COLORS_2;\n  }\n\n  if ('TEAMCITY_VERSION' in env) {\n    return RegExpPrototypeExec(/^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/, env.TEAMCITY_VERSION) !== null ?\n      COLORS_16 : COLORS_2;\n  }\n\n  switch (env.TERM_PROGRAM) {\n    case 'iTerm.app':\n      if (!env.TERM_PROGRAM_VERSION ||\n        RegExpPrototypeExec(/^[0-2]\\./, env.TERM_PROGRAM_VERSION) !== null\n      ) {\n        return COLORS_256;\n      }\n      return COLORS_16m;\n    case 'HyperTerm':\n    case 'MacTerm':\n      return COLORS_16m;\n    case 'Apple_Terminal':\n      return COLORS_256;\n  }\n\n  if (env.COLORTERM === 'truecolor' || env.COLORTERM === '24bit') {\n    return COLORS_16m;\n  }\n\n  if (env.TERM) {\n    if (RegExpPrototypeExec(/^xterm-256/, env.TERM) !== null) {\n      return COLORS_256;\n    }\n\n    const termEnv = StringPrototypeToLowerCase(env.TERM);\n\n    if (TERM_ENVS[termEnv]) {\n      return TERM_ENVS[termEnv];\n    }\n    if (ArrayPrototypeSome(TERM_ENVS_REG_EXP,\n                           (term) => RegExpPrototypeExec(term, termEnv) !== null)) {\n      return COLORS_16;\n    }\n  }\n  // Move 16 color COLORTERM below 16m and 256\n  if (env.COLORTERM) {\n    return COLORS_16;\n  }\n  return COLORS_2;\n}\n\nfunction hasColors(count, env) {\n  if (env === undefined &&\n      (count === undefined || (typeof count === 'object' && count !== null))) {\n    env = count;\n    count = 16;\n  } else {\n    validateInteger(count, 'count', 2);\n  }\n\n  return count <= 2 ** getColorDepth(env);\n}\n\nmodule.exports = {\n  getColorDepth,\n  hasColors,\n};\n"
    },
    "136": {
      "sourceCode": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// WARNING: THIS MODULE IS PENDING DEPRECATION.\n//\n// No new pull requests targeting this module will be accepted\n// unless they address existing, critical bugs.\n\nconst {\n  ArrayPrototypeEvery,\n  ArrayPrototypeIndexOf,\n  ArrayPrototypeLastIndexOf,\n  ArrayPrototypePush,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSplice,\n  Error,\n  FunctionPrototypeCall,\n  ObjectDefineProperty,\n  Promise,\n  ReflectApply,\n  SafeMap,\n  SafeWeakMap,\n  Symbol,\n} = primordials;\n\nconst EventEmitter = require('events');\nconst {\n  ERR_DOMAIN_CALLBACK_NOT_AVAILABLE,\n  ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE,\n  ERR_UNHANDLED_ERROR,\n} = require('internal/errors').codes;\nconst { createHook } = require('async_hooks');\nconst { useDomainTrampoline } = require('internal/async_hooks');\n\nconst kWeak = Symbol('kWeak');\nconst { WeakReference } = require('internal/util');\n\n// Overwrite process.domain with a getter/setter that will allow for more\n// effective optimizations\nconst _domain = [null];\nObjectDefineProperty(process, 'domain', {\n  __proto__: null,\n  enumerable: true,\n  get: function() {\n    return _domain[0];\n  },\n  set: function(arg) {\n    return _domain[0] = arg;\n  },\n});\n\nconst vmPromises = new SafeWeakMap();\nconst pairing = new SafeMap();\nconst asyncHook = createHook({\n  init(asyncId, type, triggerAsyncId, resource) {\n    if (process.domain !== null && process.domain !== undefined) {\n      // If this operation is created while in a domain, let's mark it\n      pairing.set(asyncId, process.domain[kWeak]);\n      // Promises from other contexts, such as with the VM module, should not\n      // have a domain property as it can be used to escape the sandbox.\n      if (type !== 'PROMISE' || resource instanceof Promise) {\n        ObjectDefineProperty(resource, 'domain', {\n          __proto__: null,\n          configurable: true,\n          enumerable: false,\n          value: process.domain,\n          writable: true,\n        });\n      // Because promises from other contexts don't get a domain field,\n      // the domain needs to be held alive another way. Stuffing it in a\n      // weakmap connected to the promise lifetime can fix that.\n      } else {\n        vmPromises.set(resource, process.domain);\n      }\n    }\n  },\n  before(asyncId) {\n    const current = pairing.get(asyncId);\n    if (current !== undefined) { // Enter domain for this cb\n      // We will get the domain through current.get(), because the resource\n      // object's .domain property makes sure it is not garbage collected.\n      // However, we do need to make the reference to the domain non-weak,\n      // so that it cannot be garbage collected before the after() hook.\n      current.incRef();\n      current.get().enter();\n    }\n  },\n  after(asyncId) {\n    const current = pairing.get(asyncId);\n    if (current !== undefined) { // Exit domain for this cb\n      const domain = current.get();\n      current.decRef();\n      domain.exit();\n    }\n  },\n  destroy(asyncId) {\n    pairing.delete(asyncId); // cleaning up\n  },\n});\n\n// When domains are in use, they claim full ownership of the\n// uncaught exception capture callback.\nif (process.hasUncaughtExceptionCaptureCallback()) {\n  throw new ERR_DOMAIN_CALLBACK_NOT_AVAILABLE();\n}\n\n// Get the stack trace at the point where `domain` was required.\n// eslint-disable-next-line no-restricted-syntax\nconst domainRequireStack = new Error('require(`domain`) at this point').stack;\n\nconst { setUncaughtExceptionCaptureCallback } = process;\nprocess.setUncaughtExceptionCaptureCallback = function(fn) {\n  const err = new ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE();\n  err.stack = err.stack + '\\n' + '-'.repeat(40) + '\\n' + domainRequireStack;\n  throw err;\n};\n\n\nlet sendMakeCallbackDeprecation = false;\nfunction emitMakeCallbackDeprecation({ target, method }) {\n  if (!sendMakeCallbackDeprecation) {\n    process.emitWarning(\n      'Using a domain property in MakeCallback is deprecated. Use the ' +\n      'async_context variant of MakeCallback or the AsyncResource class ' +\n      'instead. ' +\n      `(Triggered by calling ${method?.name || '<anonymous>'} ` +\n      `on ${target?.constructor?.name}.)`,\n      'DeprecationWarning', 'DEP0097');\n    sendMakeCallbackDeprecation = true;\n  }\n}\n\nfunction topLevelDomainCallback(cb, ...args) {\n  const domain = this.domain;\n  if (exports.active && domain)\n    emitMakeCallbackDeprecation({ target: this, method: cb });\n\n  if (domain)\n    domain.enter();\n  const ret = ReflectApply(cb, this, args);\n  if (domain)\n    domain.exit();\n\n  return ret;\n}\n\n// It's possible to enter one domain while already inside\n// another one. The stack is each entered domain.\nlet stack = [];\nexports._stack = stack;\nuseDomainTrampoline(topLevelDomainCallback);\n\nfunction updateExceptionCapture() {\n  if (ArrayPrototypeEvery(stack,\n                          (domain) => domain.listenerCount('error') === 0)) {\n    setUncaughtExceptionCaptureCallback(null);\n  } else {\n    setUncaughtExceptionCaptureCallback(null);\n    setUncaughtExceptionCaptureCallback((er) => {\n      return process.domain._errorHandler(er);\n    });\n  }\n}\n\n\nprocess.on('newListener', (name, listener) => {\n  if (name === 'uncaughtException' &&\n      listener !== domainUncaughtExceptionClear) {\n    // Make sure the first listener for `uncaughtException` always clears\n    // the domain stack.\n    process.removeListener(name, domainUncaughtExceptionClear);\n    process.prependListener(name, domainUncaughtExceptionClear);\n  }\n});\n\nprocess.on('removeListener', (name, listener) => {\n  if (name === 'uncaughtException' &&\n      listener !== domainUncaughtExceptionClear) {\n    // If the domain listener would be the only remaining one, remove it.\n    const listeners = process.listeners('uncaughtException');\n    if (listeners.length === 1 && listeners[0] === domainUncaughtExceptionClear)\n      process.removeListener(name, domainUncaughtExceptionClear);\n  }\n});\n\nfunction domainUncaughtExceptionClear() {\n  stack.length = 0;\n  exports.active = process.domain = null;\n  updateExceptionCapture();\n}\n\n\nclass Domain extends EventEmitter {\n  constructor() {\n    super();\n\n    this.members = [];\n    this[kWeak] = new WeakReference(this);\n    asyncHook.enable();\n\n    this.on('removeListener', updateExceptionCapture);\n    this.on('newListener', updateExceptionCapture);\n  }\n}\n\nexports.Domain = Domain;\n\nexports.create = exports.createDomain = function createDomain() {\n  return new Domain();\n};\n\n// The active domain is always the one that we're currently in.\nexports.active = null;\nDomain.prototype.members = undefined;\n\n// Called by process._fatalException in case an error was thrown.\nDomain.prototype._errorHandler = function(er) {\n  let caught = false;\n\n  if ((typeof er === 'object' && er !== null) || typeof er === 'function') {\n    ObjectDefineProperty(er, 'domain', {\n      __proto__: null,\n      configurable: true,\n      enumerable: false,\n      value: this,\n      writable: true,\n    });\n    er.domainThrown = true;\n  }\n  // Pop all adjacent duplicates of the currently active domain from the stack.\n  // This is done to prevent a domain's error handler to run within the context\n  // of itself, and re-entering itself recursively handler as a result of an\n  // exception thrown in its context.\n  while (exports.active === this) {\n    this.exit();\n  }\n\n  // The top-level domain-handler is handled separately.\n  //\n  // The reason is that if V8 was passed a command line option\n  // asking it to abort on an uncaught exception (currently\n  // \"--abort-on-uncaught-exception\"), we want an uncaught exception\n  // in the top-level domain error handler to make the\n  // process abort. Using try/catch here would always make V8 think\n  // that these exceptions are caught, and thus would prevent it from\n  // aborting in these cases.\n  if (stack.length === 0) {\n    // If there's no error handler, do not emit an 'error' event\n    // as this would throw an error, make the process exit, and thus\n    // prevent the process 'uncaughtException' event from being emitted\n    // if a listener is set.\n    if (EventEmitter.listenerCount(this, 'error') > 0) {\n      // Clear the uncaughtExceptionCaptureCallback so that we know that, since\n      // the top-level domain is not active anymore, it would be ok to abort on\n      // an uncaught exception at this point\n      setUncaughtExceptionCaptureCallback(null);\n      try {\n        caught = this.emit('error', er);\n      } finally {\n        updateExceptionCapture();\n      }\n    }\n  } else {\n    // Wrap this in a try/catch so we don't get infinite throwing\n    try {\n      // One of three things will happen here.\n      //\n      // 1. There is a handler, caught = true\n      // 2. There is no handler, caught = false\n      // 3. It throws, caught = false\n      //\n      // If caught is false after this, then there's no need to exit()\n      // the domain, because we're going to crash the process anyway.\n      caught = this.emit('error', er);\n    } catch (er2) {\n      // The domain error handler threw!  oh no!\n      // See if another domain can catch THIS error,\n      // or else crash on the original one.\n      updateExceptionCapture();\n      if (stack.length) {\n        exports.active = process.domain = stack[stack.length - 1];\n        caught = process.domain._errorHandler(er2);\n      } else {\n        // Pass on to the next exception handler.\n        throw er2;\n      }\n    }\n  }\n\n  // Exit all domains on the stack.  Uncaught exceptions end the\n  // current tick and no domains should be left on the stack\n  // between ticks.\n  domainUncaughtExceptionClear();\n\n  return caught;\n};\n\n\nDomain.prototype.enter = function() {\n  // Note that this might be a no-op, but we still need\n  // to push it onto the stack so that we can pop it later.\n  exports.active = process.domain = this;\n  ArrayPrototypePush(stack, this);\n  updateExceptionCapture();\n};\n\n\nDomain.prototype.exit = function() {\n  // Don't do anything if this domain is not on the stack.\n  const index = ArrayPrototypeLastIndexOf(stack, this);\n  if (index === -1) return;\n\n  // Exit all domains until this one.\n  ArrayPrototypeSplice(stack, index);\n\n  exports.active = stack.length === 0 ? undefined : stack[stack.length - 1];\n  process.domain = exports.active;\n  updateExceptionCapture();\n};\n\n\n// note: this works for timers as well.\nDomain.prototype.add = function(ee) {\n  // If the domain is already added, then nothing left to do.\n  if (ee.domain === this)\n    return;\n\n  // Has a domain already - remove it first.\n  if (ee.domain)\n    ee.domain.remove(ee);\n\n  // Check for circular Domain->Domain links.\n  // They cause big issues.\n  //\n  // For example:\n  // var d = domain.create();\n  // var e = domain.create();\n  // d.add(e);\n  // e.add(d);\n  // e.emit('error', er); // RangeError, stack overflow!\n  if (this.domain && (ee instanceof Domain)) {\n    for (let d = this.domain; d; d = d.domain) {\n      if (ee === d) return;\n    }\n  }\n\n  ObjectDefineProperty(ee, 'domain', {\n    __proto__: null,\n    configurable: true,\n    enumerable: false,\n    value: this,\n    writable: true,\n  });\n  ArrayPrototypePush(this.members, ee);\n};\n\n\nDomain.prototype.remove = function(ee) {\n  ee.domain = null;\n  const index = ArrayPrototypeIndexOf(this.members, ee);\n  if (index !== -1)\n    ArrayPrototypeSplice(this.members, index, 1);\n};\n\n\nDomain.prototype.run = function(fn) {\n  this.enter();\n  const ret = ReflectApply(fn, this, ArrayPrototypeSlice(arguments, 1));\n  this.exit();\n\n  return ret;\n};\n\n\nfunction intercepted(_this, self, cb, fnargs) {\n  if (fnargs[0] && fnargs[0] instanceof Error) {\n    const er = fnargs[0];\n    er.domainBound = cb;\n    er.domainThrown = false;\n    ObjectDefineProperty(er, 'domain', {\n      __proto__: null,\n      configurable: true,\n      enumerable: false,\n      value: self,\n      writable: true,\n    });\n    self.emit('error', er);\n    return;\n  }\n\n  self.enter();\n  const ret = ReflectApply(cb, _this, ArrayPrototypeSlice(fnargs, 1));\n  self.exit();\n\n  return ret;\n}\n\n\nDomain.prototype.intercept = function(cb) {\n  const self = this;\n\n  function runIntercepted() {\n    return intercepted(this, self, cb, arguments);\n  }\n\n  return runIntercepted;\n};\n\n\nfunction bound(_this, self, cb, fnargs) {\n  self.enter();\n  const ret = ReflectApply(cb, _this, fnargs);\n  self.exit();\n\n  return ret;\n}\n\n\nDomain.prototype.bind = function(cb) {\n  const self = this;\n\n  function runBound() {\n    return bound(this, self, cb, arguments);\n  }\n\n  ObjectDefineProperty(runBound, 'domain', {\n    __proto__: null,\n    configurable: true,\n    enumerable: false,\n    value: this,\n    writable: true,\n  });\n\n  return runBound;\n};\n\n// Override EventEmitter methods to make it domain-aware.\nEventEmitter.usingDomains = true;\n\nconst eventInit = EventEmitter.init;\nEventEmitter.init = function(opts) {\n  ObjectDefineProperty(this, 'domain', {\n    __proto__: null,\n    configurable: true,\n    enumerable: false,\n    value: null,\n    writable: true,\n  });\n  if (exports.active && !(this instanceof exports.Domain)) {\n    this.domain = exports.active;\n  }\n\n  return FunctionPrototypeCall(eventInit, this, opts);\n};\n\nconst eventEmit = EventEmitter.prototype.emit;\nEventEmitter.prototype.emit = function emit(...args) {\n  const domain = this.domain;\n\n  const type = args[0];\n  const shouldEmitError = type === 'error' &&\n                          this.listenerCount(type) > 0;\n\n  // Just call original `emit` if current EE instance has `error`\n  // handler, there's no active domain or this is process\n  if (shouldEmitError || domain === null || domain === undefined ||\n      this === process) {\n    return ReflectApply(eventEmit, this, args);\n  }\n\n  if (type === 'error') {\n    const er = args.length > 1 && args[1] ?\n      args[1] : new ERR_UNHANDLED_ERROR();\n\n    if (typeof er === 'object') {\n      er.domainEmitter = this;\n      ObjectDefineProperty(er, 'domain', {\n        __proto__: null,\n        configurable: true,\n        enumerable: false,\n        value: domain,\n        writable: true,\n      });\n      er.domainThrown = false;\n    }\n\n    // Remove the current domain (and its duplicates) from the domains stack and\n    // set the active domain to its parent (if any) so that the domain's error\n    // handler doesn't run in its own context. This prevents any event emitter\n    // created or any exception thrown in that error handler from recursively\n    // executing that error handler.\n    const origDomainsStack = ArrayPrototypeSlice(stack);\n    const origActiveDomain = process.domain;\n\n    // Travel the domains stack from top to bottom to find the first domain\n    // instance that is not a duplicate of the current active domain.\n    let idx = stack.length - 1;\n    while (idx > -1 && process.domain === stack[idx]) {\n      --idx;\n    }\n\n    // Change the stack to not contain the current active domain, and only the\n    // domains above it on the stack.\n    if (idx < 0) {\n      stack.length = 0;\n    } else {\n      ArrayPrototypeSplice(stack, idx + 1);\n    }\n\n    // Change the current active domain\n    if (stack.length > 0) {\n      exports.active = process.domain = stack[stack.length - 1];\n    } else {\n      exports.active = process.domain = null;\n    }\n\n    updateExceptionCapture();\n\n    domain.emit('error', er);\n\n    // Now that the domain's error handler has completed, restore the domains\n    // stack and the active domain to their original values.\n    exports._stack = stack = origDomainsStack;\n    exports.active = process.domain = origActiveDomain;\n    updateExceptionCapture();\n\n    return false;\n  }\n\n  domain.enter();\n  const ret = ReflectApply(eventEmit, this, args);\n  domain.exit();\n\n  return ret;\n};\n"
    },
    "220": {
      "sourceCode": "\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst index_1 = require(\"../src/index\");\nconst profile = new index_1.Profiler('example001');\nfunction logMessage(message) {\n    console.log(message);\n}\nfunction load() {\n    for (let i = 0; i < 100000; i++) {\n        logMessage(i.toString());\n    }\n}\nfunction main() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const title = 'latest';\n        yield profile.start(title);\n        load();\n        logMessage('outside of main');\n        setTimeout(() => {\n            console.log('finish');\n        }, 1000);\n        yield profile.finish(title);\n    });\n}\nmain();\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vZXhhbXBsZTAwMS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLHdDQUF1QztBQUV2QyxNQUFNLE9BQU8sR0FBRyxJQUFJLGdCQUFRLENBQUMsWUFBWSxDQUFDLENBQUE7QUFFMUMsU0FBUyxVQUFVLENBQUMsT0FBZTtJQUNsQyxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFBO0FBQ3JCLENBQUM7QUFFRCxTQUFTLElBQUk7SUFDWixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDakMsVUFBVSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFBO0lBQ3pCLENBQUM7QUFDRixDQUFDO0FBRUQsU0FBZSxJQUFJOztRQUNsQixNQUFNLEtBQUssR0FBRyxRQUFRLENBQUE7UUFDdEIsTUFBTSxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFBO1FBRTFCLElBQUksRUFBRSxDQUFBO1FBRU4sVUFBVSxDQUFDLGlCQUFpQixDQUFDLENBQUE7UUFFN0IsVUFBVSxDQUFDLEdBQUcsRUFBRTtZQUNmLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUE7UUFDdEIsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFBO1FBQ1IsTUFBTSxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBQzVCLENBQUM7Q0FBQTtBQUVELElBQUksRUFBRSxDQUFBIn0="
    },
    "329": {
      "sourceCode": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {\n    if (k2 === undefined)\n        k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = { enumerable: true, get: function () { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function (o, m, k, k2) {\n    if (k2 === undefined)\n        k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function (o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule)\n        return mod;\n    var result = {};\n    if (mod != null)\n        for (var k in mod)\n            if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k))\n                __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathUtils = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst path = __importStar(require(\"path\"));\nconst pathCollator = new Intl.Collator(undefined, {\n    numeric: true,\n    sensitivity: 'base'\n});\nclass PathUtils {\n    static sortFilePathArray(filePathArray) {\n        filePathArray.sort(pathCollator.compare);\n    }\n    static getPathRelativeTo(from, to) {\n        return path.relative(from, to);\n    }\n    static makeAbsolute(startDir, relativeFilePath) {\n        if (PathUtils.isAbsolute(relativeFilePath)) {\n            return relativeFilePath;\n        }\n        return path.normalize(path.join(startDir, relativeFilePath));\n    }\n    static isAbsolute(pathString) {\n        return path.isAbsolute(pathString) || /^(?:[a-zA-Z]:)?\\\\?\\\\(?:[^\\\\/:*?\"<>|\\r\\n]+\\\\)*[^\\\\/:*?\"<>|\\r\\n]*$/.test(pathString);\n    }\n    static unifyPath(pathString) {\n        if (pathString === '' || pathString === '.' || pathString === './') {\n            return './';\n        }\n        if (pathString === '/') {\n            return '/';\n        }\n        if (pathString === '../') {\n            return '../';\n        }\n        const isAbsolute = PathUtils.isAbsolute(pathString);\n        pathString = pathString.replace(/\\\\/g, '/');\n        pathString = pathString.replace(/\\/+$/g, '');\n        if (!isAbsolute) {\n            if (pathString.slice(0, 2) !== './' && pathString.slice(0, 3) !== '../') {\n                return './' + pathString;\n            }\n        }\n        return pathString;\n    }\n    static findUp(filename, startDir) {\n        const { root } = path.parse(startDir);\n        let tmpDir = startDir;\n        while (tmpDir !== root) {\n            let list;\n            try {\n                list = fs.readdirSync(tmpDir);\n            }\n            catch (e) {\n                break;\n            }\n            if (list.includes(filename) && fs.statSync(path.join(tmpDir, filename)).isFile()) {\n                // found\n                return path.join(tmpDir, filename);\n            }\n            else {\n                tmpDir = path.normalize(path.join(tmpDir, '..'));\n            }\n        }\n        return undefined;\n    }\n}\nexports.PathUtils = PathUtils;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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"
    },
    "330": {
      "sourceCode": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {\n    if (k2 === undefined)\n        k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = { enumerable: true, get: function () { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function (o, m, k, k2) {\n    if (k2 === undefined)\n        k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function (o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule)\n        return mod;\n    var result = {};\n    if (mod != null)\n        for (var k in mod)\n            if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k))\n                __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnifiedPath = void 0;\nconst path = __importStar(require(\"path\"));\nconst PathUtils_1 = require(\"../helper/PathUtils\");\nclass UnifiedPath {\n    constructor(...args) {\n        if (args.length === 0 || args.length === 1) {\n            this._unifiedPath = PathUtils_1.PathUtils.unifyPath(args[0] || '');\n        }\n        else {\n            this._unifiedPath = PathUtils_1.PathUtils.unifyPath(args.join('/'));\n        }\n    }\n    static fromPathParts(parts) {\n        return new UnifiedPath(parts[0]).join(...parts.slice(1));\n    }\n    copy() {\n        return new UnifiedPath(this._unifiedPath);\n    }\n    /**\n     * String representation of a UnifiedPath\n     *\n     * @returns\n     */\n    toString() {\n        return this._unifiedPath;\n    }\n    /**\n     * Returns UnifiedPath as a string for the current platform\n     *\n     * @returns\n     */\n    toPlatformString() {\n        return this._unifiedPath.split('/').join(path.sep);\n    }\n    /**\n     * JSON representation of a UnifiedPath\n     *\n     * @returns\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Returns the directory name of a path\n     *\n     * @returns\n     */\n    dirName() {\n        return new UnifiedPath(path.dirname(this.toString()));\n    }\n    /**\n     * Returns the basename name of a path\n     *\n     * @returns The basename of the path (path/to/index.coffee.md -> index.coffee.md)\n     */\n    basename() {\n        return path.basename(this.toString());\n    }\n    /**\n     * Returns the extension of a path\n     *\n     * @returns The extension of the path (path/to/index.coffee.md -> .md)\n     */\n    extname() {\n        return path.extname(this.basename());\n    }\n    isRelative() {\n        return this._unifiedPath === '' || (this._unifiedPath[0] !== '/' && !this.isAbsoluteWindowsPath());\n    }\n    isAbsoluteWindowsPath() {\n        return /^[A-Za-z]:/.test(this._unifiedPath);\n    }\n    /**\n     * Gives the relative UnifiedPath that points from this to the other path\n     *\n     * @param other\n     * @returns\n     */\n    pathTo(other) {\n        if (typeof other === 'string') {\n            other = new UnifiedPath(other);\n        }\n        return new UnifiedPath(PathUtils_1.PathUtils.getPathRelativeTo(this.toString(), other.toString()));\n    }\n    /**\n     * Splits the path into an array of it's components\n     *\n     * @returns\n     */\n    split() {\n        if (!this._parts) {\n            const parts = this._unifiedPath.split('/');\n            if (parts[0] === '' && parts.length > 1) {\n                parts[0] = '/';\n            }\n            if (parts[0] === '.' && parts.length > 1) {\n                parts.splice(0, 1);\n            }\n            this._parts = parts;\n        }\n        return this._parts;\n    }\n    join(...args) {\n        if (args.length === 0) {\n            return new UnifiedPath(this._unifiedPath);\n        }\n        const parts = [];\n        for (const part of args) {\n            if (typeof part === 'string') {\n                parts.push(new UnifiedPath(part).toString());\n            }\n            else {\n                parts.push(part.toString());\n            }\n        }\n        return new UnifiedPath(path.posix.join(this._unifiedPath, ...parts));\n    }\n    /**\n     * Returns the unified path from the root of the path to the first occurrence of the given directory\n     * and the remainder\n     *\n     * /path/to/node_modules/node_module_name/file -> /path/to/node_modules\n     *\n     * @param dirName\n     * @returns\n     */\n    pathUntilSubDir(dirName) {\n        const pathParts = this.split();\n        const firstMatch = pathParts.indexOf(dirName);\n        if (firstMatch !== -1) {\n            return {\n                match: new UnifiedPath(path.posix.join(...pathParts.slice(0, firstMatch + 1))),\n                remainder: new UnifiedPath(path.posix.join(...pathParts.slice(firstMatch + 1))),\n            };\n        }\n        return undefined;\n    }\n}\nexports.UnifiedPath = UnifiedPath;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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"
    },
    "395": {
      "sourceCode": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {\n    if (k2 === undefined)\n        k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = { enumerable: true, get: function () { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function (o, m, k, k2) {\n    if (k2 === undefined)\n        k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function (o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule)\n        return mod;\n    var result = {};\n    if (mod != null)\n        for (var k in mod)\n            if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k))\n                __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InspectorHelper = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst inspector_1 = __importDefault(require(\"inspector\"));\nconst LoggerHelper_1 = require(\"./LoggerHelper\");\nconst PermissionHelper_1 = require(\"./PermissionHelper\");\nconst TypescriptParser_1 = require(\"./TypescriptParser\");\nconst SourceMap_1 = require(\"../model/SourceMap\");\nconst UnifiedPath_1 = require(\"../system/UnifiedPath\");\nclass InspectorHelper {\n    constructor() {\n        this._session = new inspector_1.default.Session();\n        this.sourceCodeMap = new Map();\n        this.sourceMapMap = new Map();\n        this.loadedFiles = new Map();\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._session.connect();\n            // wait for debugger to be enabled\n            yield new Promise((resolve) => {\n                this._session.post('Debugger.enable', resolve);\n            });\n        });\n    }\n    storeToFile(filePath, kind) {\n        if (!fs.existsSync(filePath.dirName().toPlatformString())) {\n            PermissionHelper_1.PermissionHelper.mkdirRecursivelyWithUserPermission(filePath.dirName().toPlatformString());\n        }\n        switch (kind) {\n            case 'pretty-json':\n                PermissionHelper_1.PermissionHelper.writeFileWithUserPermission(filePath.toPlatformString(), JSON.stringify(this, null, 2));\n                break;\n            case 'json':\n                PermissionHelper_1.PermissionHelper.writeFileWithUserPermission(filePath.toPlatformString(), JSON.stringify(this));\n                break;\n            default:\n                break;\n        }\n    }\n    static loadFromFile(filePath) {\n        if (!fs.existsSync(filePath.toPlatformString())) {\n            return undefined;\n        }\n        return InspectorHelper.fromJSON(fs.readFileSync(filePath.toPlatformString()).toString());\n    }\n    toJSON() {\n        return {\n            sourceCodeMap: Object.fromEntries(this.sourceCodeMap),\n            loadedFiles: Object.fromEntries(this.loadedFiles)\n        };\n    }\n    static fromJSON(json) {\n        let data;\n        if (typeof json === 'string') {\n            data = JSON.parse(json);\n        }\n        else {\n            data = json;\n        }\n        const result = new InspectorHelper();\n        for (const [key, value] of Object.entries(data.sourceCodeMap)) {\n            result.sourceCodeMap.set(key, value);\n        }\n        for (const [key, value] of Object.entries(data.loadedFiles)) {\n            result.loadedFiles.set(key, value);\n        }\n        return result;\n    }\n    listen() {\n        this._session.on('inspectorNotification', (message) => __awaiter(this, void 0, void 0, function* () {\n            if (message.method === 'Debugger.scriptParsed') {\n                const params = message.params;\n                yield this.sourceCodeFromId(params.scriptId);\n            }\n        }));\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield new Promise((resolve) => {\n                this._session.post('Debugger.disable', resolve);\n            });\n            this._session.disconnect();\n        });\n    }\n    fillSourceMapsFromCPUModel(cpuModel) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const scriptMap = new Map();\n            for (const location of cpuModel.ILocations) {\n                const scriptId = location.callFrame.scriptId.toString();\n                if (scriptMap.has(scriptId)) {\n                    continue;\n                }\n                scriptMap.set(scriptId, location.callFrame.url);\n            }\n            const promises = [];\n            for (const [scriptId, filePath] of scriptMap) {\n                promises.push(this.sourceMapFromId(new UnifiedPath_1.UnifiedPath(filePath), scriptId));\n            }\n            yield Promise.all(promises);\n        });\n    }\n    loadFile(relativePath, filePath) {\n        let source = this.loadedFiles.get(relativePath.toString());\n        if (source !== undefined) {\n            return source;\n        }\n        source = fs.readFileSync(filePath.toPlatformString()).toString();\n        this.loadedFiles.set(relativePath.toString(), source);\n        return source;\n    }\n    parseFile(relativePath, filePath) {\n        const source = this.loadFile(relativePath, filePath);\n        return TypescriptParser_1.TypescriptParser.parseSource(filePath, source);\n    }\n    sourceCodeFromId(scriptId, filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (scriptId === '0') {\n                return null;\n            }\n            let source = this.sourceCodeMap.get(scriptId);\n            if (source !== undefined) {\n                return source;\n            }\n            const result = yield (new Promise((resolve) => {\n                this._session.post('Debugger.getScriptSource', { scriptId }, (err, args) => {\n                    if (err) {\n                        resolve({ source: '', err });\n                    }\n                    else {\n                        resolve({ source: args.scriptSource });\n                    }\n                });\n            }));\n            if (result.err) {\n                LoggerHelper_1.LoggerHelper.error('Error getting script source', result.err, { scriptId, filePath });\n                throw result.err;\n            }\n            source = result.source;\n            this.sourceCodeMap.set(scriptId, source);\n            return source;\n        });\n    }\n    sourceMapFromId(filePath, scriptId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (scriptId === '0') {\n                return null;\n            }\n            let sourceMap = this.sourceMapMap.get(scriptId);\n            if (sourceMap !== undefined) {\n                return sourceMap;\n            }\n            const sourceCode = yield this.sourceCodeFromId(scriptId, filePath);\n            if (sourceCode === null) {\n                throw new Error(`No source map found for scriptId ${filePath.toPlatformString()} ${scriptId}`);\n            }\n            sourceMap = SourceMap_1.SourceMap.fromCompiledJSString(filePath, sourceCode);\n            this.sourceMapMap.set(scriptId, sourceMap);\n            return sourceMap;\n        });\n    }\n}\nexports.InspectorHelper = InspectorHelper;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsT0FBTyxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1RyxPQUFPLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxVQUFVLE9BQU8sRUFBRSxNQUFNO1FBQ3JELFNBQVMsU0FBUyxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUM7WUFBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQUMsQ0FBQztRQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7WUFBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFBQyxDQUFDLENBQUMsQ0FBQztRQUMzRixTQUFTLFFBQVEsQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDO1lBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQUMsQ0FBQztRQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7WUFBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFBQyxDQUFDLENBQUMsQ0FBQztRQUM5RixTQUFTLElBQUksQ0FBQyxNQUFNLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5RyxJQUFJLENBQUMsQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsVUFBVSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUMxRSxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMs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"
    },
    "396": {
      "sourceCode": "'use strict';\n\nconst {\n  JSONParse,\n  JSONStringify,\n  SafeMap,\n  SymbolDispose,\n} = primordials;\n\nconst {\n  ERR_INSPECTOR_ALREADY_ACTIVATED,\n  ERR_INSPECTOR_ALREADY_CONNECTED,\n  ERR_INSPECTOR_CLOSED,\n  ERR_INSPECTOR_COMMAND,\n  ERR_INSPECTOR_NOT_AVAILABLE,\n  ERR_INSPECTOR_NOT_CONNECTED,\n  ERR_INSPECTOR_NOT_ACTIVE,\n  ERR_INSPECTOR_NOT_WORKER,\n} = require('internal/errors').codes;\n\nconst { hasInspector } = internalBinding('config');\nif (!hasInspector)\n  throw new ERR_INSPECTOR_NOT_AVAILABLE();\n\nconst EventEmitter = require('events');\nconst { queueMicrotask } = require('internal/process/task_queues');\nconst {\n  isUint32,\n  validateFunction,\n  validateInt32,\n  validateObject,\n  validateString,\n} = require('internal/validators');\nconst { isMainThread } = require('worker_threads');\nconst { _debugEnd } = internalBinding('process_methods');\n\nconst {\n  Connection,\n  MainThreadConnection,\n  open,\n  url,\n  isEnabled,\n  waitForDebugger,\n  console,\n} = internalBinding('inspector');\n\nclass Session extends EventEmitter {\n  #connection = null;\n  #nextId = 1;\n  #messageCallbacks = new SafeMap();\n\n  /**\n   * Connects the session to the inspector back-end.\n   * @returns {void}\n   */\n  connect() {\n    if (this.#connection)\n      throw new ERR_INSPECTOR_ALREADY_CONNECTED('The inspector session');\n    this.#connection = new Connection((message) => this.#onMessage(message));\n  }\n\n  /**\n   * Connects the session to the main thread\n   * inspector back-end.\n   * @returns {void}\n   */\n  connectToMainThread() {\n    if (isMainThread)\n      throw new ERR_INSPECTOR_NOT_WORKER();\n    if (this.#connection)\n      throw new ERR_INSPECTOR_ALREADY_CONNECTED('The inspector session');\n    this.#connection =\n      new MainThreadConnection(\n        (message) => queueMicrotask(() => this.#onMessage(message)));\n  }\n\n  #onMessage(message) {\n    const parsed = JSONParse(message);\n    try {\n      if (parsed.id) {\n        const callback = this.#messageCallbacks.get(parsed.id);\n        this.#messageCallbacks.delete(parsed.id);\n        if (callback) {\n          if (parsed.error) {\n            return callback(\n              new ERR_INSPECTOR_COMMAND(parsed.error.code, parsed.error.message),\n            );\n          }\n\n          callback(null, parsed.result);\n        }\n      } else {\n        this.emit(parsed.method, parsed);\n        this.emit('inspectorNotification', parsed);\n      }\n    } catch (error) {\n      process.emitWarning(error);\n    }\n  }\n\n  /**\n   * Posts a message to the inspector back-end.\n   * @param {string} method\n   * @param {Record<unknown, unknown>} [params]\n   * @param {Function} [callback]\n   * @returns {void}\n   */\n  post(method, params, callback) {\n    validateString(method, 'method');\n    if (!callback && typeof params === 'function') {\n      callback = params;\n      params = null;\n    }\n    if (params) {\n      validateObject(params, 'params');\n    }\n    if (callback) {\n      validateFunction(callback, 'callback');\n    }\n\n    if (!this.#connection) {\n      throw new ERR_INSPECTOR_NOT_CONNECTED();\n    }\n    const id = this.#nextId++;\n    const message = { id, method };\n    if (params) {\n      message.params = params;\n    }\n    if (callback) {\n      this.#messageCallbacks.set(id, callback);\n    }\n    this.#connection.dispatch(JSONStringify(message));\n  }\n\n  /**\n   * Immediately closes the session, all pending\n   * message callbacks will be called with an\n   * error.\n   * @returns {void}\n   */\n  disconnect() {\n    if (!this.#connection)\n      return;\n    this.#connection.disconnect();\n    this.#connection = null;\n    const remainingCallbacks = this.#messageCallbacks.values();\n    for (const callback of remainingCallbacks) {\n      process.nextTick(callback, new ERR_INSPECTOR_CLOSED());\n    }\n    this.#messageCallbacks.clear();\n    this.#nextId = 1;\n  }\n}\n\n/**\n * Activates inspector on host and port.\n * @param {number} [port]\n * @param {string} [host]\n * @param {boolean} [wait]\n * @returns {void}\n */\nfunction inspectorOpen(port, host, wait) {\n  if (isEnabled()) {\n    throw new ERR_INSPECTOR_ALREADY_ACTIVATED();\n  }\n  // inspectorOpen() currently does not typecheck its arguments and adding\n  // such checks would be a potentially breaking change. However, the native\n  // open() function requires the port to fit into a 16-bit unsigned integer,\n  // causing an integer overflow otherwise, so we at least need to prevent that.\n  if (isUint32(port)) {\n    validateInt32(port, 'port', 0, 65535);\n  }\n  open(port, host);\n  if (wait)\n    waitForDebugger();\n\n  return { __proto__: null, [SymbolDispose]() { _debugEnd(); } };\n}\n\n/**\n * Blocks until a client (existing or connected later)\n * has sent the `Runtime.runIfWaitingForDebugger`\n * command.\n * @returns {void}\n */\nfunction inspectorWaitForDebugger() {\n  if (!waitForDebugger())\n    throw new ERR_INSPECTOR_NOT_ACTIVE();\n}\n\nmodule.exports = {\n  open: inspectorOpen,\n  close: _debugEnd,\n  url,\n  waitForDebugger: inspectorWaitForDebugger,\n  console,\n  Session,\n};\n"
    },
    "411": {
      "sourceCode": "\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PerformanceHelper = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst TimeHelper_1 = require(\"./TimeHelper\");\nconst PermissionHelper_1 = require(\"./PermissionHelper\");\nconst ENABLE_PERFORMANCE_TRACKING = process.env.OAKLEAN_ENABLE_PERFORMANCE_TRACKING !== undefined;\nclass PerformanceHelper {\n    constructor() {\n        this._measures = new Map();\n        this._firstMeasure = BigInt(0);\n        this._lastMeasure = BigInt(0);\n    }\n    static loadFromFile(path) {\n        if (fs_1.default.existsSync(path.toPlatformString())) {\n            const jsonString = fs_1.default.readFileSync(path.toPlatformString(), 'utf8').toString();\n            return JSON.parse(jsonString);\n        }\n        return { measures: {} };\n    }\n    static storeToFile(path, data) {\n        const dir = path.dirName();\n        if (!fs_1.default.existsSync(dir.toPlatformString())) {\n            PermissionHelper_1.PermissionHelper.mkdirRecursivelyWithUserPermission(dir);\n        }\n        fs_1.default.writeFileSync(path.toPlatformString(), JSON.stringify(data, null, 2));\n    }\n    exportAndSum(path) {\n        if (!ENABLE_PERFORMANCE_TRACKING) {\n            return;\n        }\n        const report = PerformanceHelper.loadFromFile(path);\n        for (const [name, measure] of this._measures) {\n            if (measure.end) {\n                const diff = Number(measure.end - measure.start);\n                report.measures[name] = (report.measures[name] || 0) + diff;\n            }\n        }\n        PerformanceHelper.storeToFile(path, report);\n    }\n    start(name) {\n        if (!ENABLE_PERFORMANCE_TRACKING) {\n            return;\n        }\n        const time = TimeHelper_1.TimeHelper.getCurrentHighResolutionTime();\n        if (!this._firstMeasure) {\n            this._firstMeasure = time;\n        }\n        this._measures.set(name, {\n            start: time,\n            end: null\n        });\n    }\n    stop(name) {\n        if (!ENABLE_PERFORMANCE_TRACKING) {\n            return;\n        }\n        const time = TimeHelper_1.TimeHelper.getCurrentHighResolutionTime();\n        this._lastMeasure = time;\n        const measure = this._measures.get(name);\n        if (measure) {\n            measure.end = time;\n        }\n    }\n    static printAccumulatedReport(path) {\n        const loadedReport = PerformanceHelper.loadFromFile(path);\n        console.log('Accumulated performance report:');\n        const report = {};\n        for (const name of Object.keys(loadedReport.measures)) {\n            report[name] = {\n                'Duration': `${(loadedReport.measures[name] / 1e9).toFixed(3)} s`\n            };\n        }\n        console.table(report, ['Duration']);\n    }\n    printReport(title) {\n        if (!ENABLE_PERFORMANCE_TRACKING) {\n            return;\n        }\n        const report = {};\n        const total = Number(this._lastMeasure - this._firstMeasure);\n        for (const [name, measure] of this._measures) {\n            if (measure.end) {\n                const diff = Number(measure.end - measure.start);\n                report[name] = {\n                    'Duration': `${(diff / 1e9).toFixed(3)} s`,\n                    'Percentage': `${((diff / total) * 100).toFixed(2)} %`\n                };\n            }\n            else {\n                report[name] = {\n                    'Duration': 'N/A',\n                    'Percentage': 'N/A'\n                };\n            }\n        }\n        console.log(`Performance report (${title}):`, (total / 1e9).toFixed(3), 's');\n        console.table(report, ['Duration', 'Percentage']);\n    }\n}\nexports.PerformanceHelper = PerformanceHelper;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4vUGVyZm9ybWFuY2VIZWxwZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxDQUFDO0FBQ2IsSUFBSSxlQUFlLEdBQUcsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLFVBQVUsR0FBRztJQUNqRSxPQUFPLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsQ0FBQztBQUM5RCxDQUFDLENBQUM7QUFDRixNQUFNLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxZQUFZLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUM5RCxPQUFPLENBQUMsaUJBQWlCLEdBQUcsS0FBSyxDQUFDLENBQUM7QUFDbkMsTUFBTSxJQUFJLEdBQUcsZUFBZSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQzVDLE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUM3QyxNQUFNLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0FBQ3pELE1BQU0sMkJBQTJCLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQ0FBbUMsS0FBSyxTQUFTLENBQUM7QUFDbEcsTUFBTSxpQkFBaUI7SUFDbkI7UUFDSSxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7UUFDM0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0IsSUFBSSxDQUFDLFlBQVksR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUNELE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSTtRQUNwQixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxnQkFBZ0Is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"
    },
    "431": {
      "sourceCode": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {\n    if (k2 === undefined)\n        k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = { enumerable: true, get: function () { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function (o, m, k, k2) {\n    if (k2 === undefined)\n        k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function (o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule)\n        return mod;\n    var result = {};\n    if (mod != null)\n        for (var k in mod)\n            if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k))\n                __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProfilerConfig = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst BaseModel_1 = require(\"./BaseModel\");\nconst config_1 = require(\"../constants/config\");\nconst PathUtils_1 = require(\"../helper/PathUtils\");\nconst UnifiedPath_1 = require(\"../system/UnifiedPath\");\nconst Crypto_1 = require(\"../system/Crypto\");\nconst PermissionHelper_1 = require(\"../helper/PermissionHelper\");\n// Types\nconst types_1 = require(\"../types\");\nclass ProfilerConfig extends BaseModel_1.BaseModel {\n    constructor(filePath, config) {\n        super();\n        this.filePath = filePath;\n        this.extends = config.extends;\n        this.registryOptions = config.registryOptions;\n        this.exportOptions = config.exportOptions;\n        this.projectOptions = config.projectOptions;\n        this.runtimeOptions = config.runtimeOptions;\n    }\n    static getDefaultConfig() {\n        return new ProfilerConfig(new UnifiedPath_1.UnifiedPath(process.cwd()).join(config_1.STATIC_CONFIG_FILENAME), config_1.DEFAULT_PROFILER_CONFIG);\n    }\n    getAnonymizedRuntimeOptions() {\n        if (this.runtimeOptions.sensorInterface) {\n            switch (this.runtimeOptions.sensorInterface.type) {\n                case types_1.SensorInterfaceType.windows:\n                    return Object.assign(Object.assign({}, this.runtimeOptions), { sensorInterface: {\n                            type: types_1.SensorInterfaceType.windows,\n                            options: {\n                                sampleInterval: this.runtimeOptions.sensorInterface.options.sampleInterval,\n                                outputFilePath: '<anonymized>'\n                            }\n                        } });\n                case types_1.SensorInterfaceType.perf:\n                    return Object.assign(Object.assign({}, this.runtimeOptions), { sensorInterface: {\n                            type: types_1.SensorInterfaceType.perf,\n                            options: {\n                                sampleInterval: this.runtimeOptions.sensorInterface.options.sampleInterval,\n                                outputFilePath: '<anonymized>'\n                            }\n                        } });\n                case types_1.SensorInterfaceType.powermetrics:\n                    return Object.assign(Object.assign({}, this.runtimeOptions), { sensorInterface: {\n                            type: types_1.SensorInterfaceType.powermetrics,\n                            options: {\n                                sampleInterval: this.runtimeOptions.sensorInterface.options.sampleInterval,\n                                outputFilePath: '<anonymized>'\n                            }\n                        } });\n            }\n        }\n        return this.runtimeOptions;\n    }\n    getV8CPUSamplingInterval() {\n        return this.runtimeOptions.v8.cpu.sampleInterval;\n    }\n    getRegistryUploadUrl() {\n        return `http://${this.registryOptions.url}/upload`;\n    }\n    uploadEnabled() {\n        var _a, _b;\n        return (((_a = this.registryOptions) === null || _a === void 0 ? void 0 : _a.url) !== undefined) && ((_b = this.registryOptions) === null || _b === void 0 ? void 0 : _b.url) !== '';\n    }\n    getProjectIdentifier() {\n        if (!Crypto_1.Crypto.validateUniqueID(this.projectOptions.identifier)) {\n            throw new Error('ProfilerConfig.getProjectIdentifier: identifier should be an uuid4');\n        }\n        return this.projectOptions.identifier;\n    }\n    getRootDir() {\n        if (PathUtils_1.PathUtils.isAbsolute(this.exportOptions.rootDir)) {\n            return new UnifiedPath_1.UnifiedPath(this.exportOptions.rootDir);\n        }\n        return this.filePath.dirName().join(this.exportOptions.rootDir);\n    }\n    getOutDir() {\n        if (PathUtils_1.PathUtils.isAbsolute(this.exportOptions.outDir)) {\n            return new UnifiedPath_1.UnifiedPath(this.exportOptions.outDir);\n        }\n        return this.filePath.dirName().join(this.exportOptions.outDir);\n    }\n    getOutHistoryDir() {\n        if (PathUtils_1.PathUtils.isAbsolute(this.exportOptions.outHistoryDir)) {\n            return new UnifiedPath_1.UnifiedPath(this.exportOptions.outHistoryDir);\n        }\n        return this.filePath.dirName().join(this.exportOptions.outHistoryDir);\n    }\n    getSensorInterfaceType() {\n        var _a;\n        return (_a = this.runtimeOptions.sensorInterface) === null || _a === void 0 ? void 0 : _a.type;\n    }\n    getSensorInterfaceOptions() {\n        var _a;\n        return (_a = this.runtimeOptions.sensorInterface) === null || _a === void 0 ? void 0 : _a.options;\n    }\n    shouldExportV8Profile() {\n        return this.exportOptions.exportV8Profile;\n    }\n    shouldExportReport() {\n        return this.exportOptions.exportReport;\n    }\n    shouldExportSensorInterfaceData() {\n        return this.exportOptions.exportSensorInterfaceData;\n    }\n    getSeedForMathRandom() {\n        return this.runtimeOptions.seeds['Math.random'];\n    }\n    configAsExtended(pathDiff) {\n        const exportOptions = this.exportOptions;\n        if (exportOptions) {\n            if (exportOptions.outDir && !PathUtils_1.PathUtils.isAbsolute(exportOptions.outDir)) {\n                exportOptions.outDir = pathDiff.join(exportOptions.outDir).toString();\n            }\n            if (exportOptions.outHistoryDir && !PathUtils_1.PathUtils.isAbsolute(exportOptions.outHistoryDir)) {\n                exportOptions.outHistoryDir = pathDiff.join(exportOptions.outHistoryDir).toString();\n            }\n            if (exportOptions.rootDir && !PathUtils_1.PathUtils.isAbsolute(exportOptions.rootDir)) {\n                exportOptions.rootDir = pathDiff.join(exportOptions.rootDir).toString();\n            }\n        }\n        return {\n            exportOptions: exportOptions,\n            projectOptions: this.projectOptions,\n            runtimeOptions: this.runtimeOptions,\n            registryOptions: this.registryOptions\n        };\n    }\n    /**\n     * Fills unspecified values of the config with values of the given config\n     *\n     * example usage:\n     * - every config that gets resolved inherits values of the default config (baseConfig)\n     * \t\tto ensure that unspecified values are filled with the default value. This happens via:\n     * \t\tconfig.implement(baseConfig):\n     *\n     * - if a config contains the extends keyword like this:\n     * \t\t{\n     * \t \t\t\"extends\": \"<config that gets extended>\"\n     * \t\t}\n     * \t\tthe config gets extended via:\n     * \t\tconfig.implement(<config that gets extended>):\n     *\n     * it also adjusts the inherited path values values to make them relative to the config\n     *\n     *\n     * @param config to inherit from\n     */\n    implement(config) {\n        var _a, _b, _c, _d, _e, _f;\n        const pathDiff = this.filePath.dirName().pathTo(config.filePath.dirName());\n        const configToExtend = config.configAsExtended(pathDiff);\n        const newExportOptions = Object.assign(Object.assign({}, configToExtend.exportOptions), this.exportOptions);\n        const newProjectOptions = Object.assign(Object.assign({}, configToExtend.projectOptions), this.projectOptions);\n        const newRuntimeOptions = Object.assign(Object.assign(Object.assign({}, configToExtend.runtimeOptions), this.runtimeOptions), { seeds: Object.assign(Object.assign({}, (((_a = configToExtend === null || configToExtend === void 0 ? void 0 : configToExtend.runtimeOptions) === null || _a === void 0 ? void 0 : _a.seeds) || {})), (((_b = this.runtimeOptions) === null || _b === void 0 ? void 0 : _b.seeds) || {})), v8: {\n                cpu: Object.assign(Object.assign({}, (((_d = (_c = configToExtend.runtimeOptions) === null || _c === void 0 ? void 0 : _c.v8) === null || _d === void 0 ? void 0 : _d.cpu) || {})), (((_f = (_e = this.runtimeOptions) === null || _e === void 0 ? void 0 : _e.v8) === null || _f === void 0 ? void 0 : _f.cpu) || {}))\n            } });\n        const newRegistryOptions = Object.assign(Object.assign({}, configToExtend.registryOptions), this.registryOptions);\n        this.exportOptions = newExportOptions;\n        this.projectOptions = newProjectOptions;\n        this.runtimeOptions = newRuntimeOptions;\n        this.registryOptions = newRegistryOptions;\n    }\n    static fromJSON(json) {\n        let data;\n        if (typeof json === 'string') {\n            data = JSON.parse(json);\n        }\n        else {\n            data = json;\n        }\n        if (data.projectOptions === undefined ||\n            data.projectOptions.identifier === undefined) {\n            throw new Error('ProfilerConfig: the project has no identifier yet');\n        }\n        if (!Crypto_1.Crypto.validateUniqueID(data.projectOptions.identifier)) {\n            throw new Error('ProfilerConfig.getProjectIdentifier: Loaded identifier from the config should be an uuid4');\n        }\n        return new ProfilerConfig(new UnifiedPath_1.UnifiedPath(''), {\n            extends: data.extends,\n            exportOptions: data.exportOptions,\n            projectOptions: data.projectOptions,\n            runtimeOptions: data.runtimeOptions,\n            registryOptions: data.registryOptions\n        });\n    }\n    toJSON() {\n        return ({\n            extends: this.extends,\n            exportOptions: this.exportOptions,\n            projectOptions: this.projectOptions,\n            runtimeOptions: this.runtimeOptions,\n            registryOptions: this.registryOptions\n        });\n    }\n    storeToFile(filePath) {\n        if (!fs.existsSync(filePath.dirName().toPlatformString())) {\n            PermissionHelper_1.PermissionHelper.mkdirRecursivelyWithUserPermission(filePath.dirName().toPlatformString());\n        }\n        PermissionHelper_1.PermissionHelper.writeFileWithUserPermission(filePath.toPlatformString(), JSON.stringify(this, null, 2));\n    }\n    // loads a config from a given file path and extends it\n    // this method is NOT used to ensure load a valid (complete) config, use resolveFromFile to achieve that\n    static loadFromFile(filePath) {\n        if (!fs.existsSync(filePath.toPlatformString())) {\n            return undefined;\n        }\n        const loadedConfig = ProfilerConfig.fromJSON(fs.readFileSync(filePath.toPlatformString()).toString());\n        loadedConfig.filePath = filePath;\n        if (loadedConfig.extends) {\n            const configToExtendFilePath = filePath.dirName().join(loadedConfig.extends);\n            const configToExtend = ProfilerConfig.loadFromFile(configToExtendFilePath);\n            if (configToExtend) {\n                loadedConfig.implement(configToExtend);\n                return loadedConfig;\n            }\n        }\n        return loadedConfig;\n    }\n    // loads a config from a given file path and fills all non defined values with the resp. default values\n    static resolveFromFile(filePath) {\n        const baseConfig = ProfilerConfig.getDefaultConfig();\n        if (!filePath) {\n            return baseConfig;\n        }\n        const config = this.loadFromFile(filePath);\n        if (config) {\n            baseConfig.filePath = config.filePath;\n            config.implement(baseConfig);\n            return config;\n        }\n        return baseConfig;\n    }\n    static autoResolveFromPath(startDir) {\n        // Searches from the given path upwards until it finds the config file\n        const configFilePath = PathUtils_1.PathUtils.findUp(config_1.STATIC_CONFIG_FILENAME, startDir.toPlatformString());\n        if (!configFilePath) {\n            return ProfilerConfig.resolveFromFile(undefined);\n        }\n        return ProfilerConfig.resolveFromFile(new UnifiedPath_1.UnifiedPath(configFilePath));\n    }\n    static autoResolve() {\n        // Searches from the processes execution path upwards until it finds the config file\n        return this.autoResolveFromPath(new UnifiedPath_1.UnifiedPath(process.cwd()));\n    }\n}\nexports.ProfilerConfig = ProfilerConfig;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TSxDQUFDLEVBQUUsRUFBRSxjQUFjLENBQUMsYUFBYSxDQUFDLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQzVHLE1BQU0saUJBQWlCLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxjQUFjLENBQUMsY0FBYyxDQUFDLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQy9HLE1BQU0saUJBQWlCLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLGNBQWMsQ0FBQyxjQUFjLENBQUMsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsY0FBYyxLQUFLLElBQUksSUFBSSxjQUFjLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLEtBQUssSUFBSSxJQUFJLEVBQUUsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssSUFBSSxJQUFJLEVBQUUsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRTtnQkFDdlosR0FBRyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMs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"
    },
    "538": {
      "sourceCode": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Profiler = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst inspector_1 = require(\"inspector\");\nconst seedrandom_1 = __importDefault(require(\"seedrandom\"));\nconst profiler_core_1 = require(\"@oaklean/profiler-core\");\nconst V8Profiler_1 = require(\"./model/V8Profiler\");\nconst TraceEventHelper_1 = require(\"./helper/TraceEventHelper\");\nconst PowerMetricsSensorInterface_1 = require(\"./interfaces/powermetrics/PowerMetricsSensorInterface\");\nconst PerfSensorInterface_1 = require(\"./interfaces/perf/PerfSensorInterface\");\nconst WindowsSensorInterface_1 = require(\"./interfaces/windows/WindowsSensorInterface\");\nclass Profiler {\n    constructor(subOutputDir, options) {\n        this.subOutputDir = subOutputDir;\n        this.config = profiler_core_1.ProfilerConfig.autoResolve();\n        this.options = options;\n        this.loadSensorInterface();\n        this._inspectorHelper = new profiler_core_1.InspectorHelper();\n    }\n    static getSensorInterface(config) {\n        const sensorInterfaceType = config.getSensorInterfaceType();\n        switch (sensorInterfaceType) {\n            case 'powermetrics': {\n                const options = config.getSensorInterfaceOptions();\n                if (options === undefined) {\n                    throw new Error('Profiler.getSensorInterface: sensorInterfaceOptions are not defined');\n                }\n                options.outputFilePath = config.getOutDir().join(options.outputFilePath).toPlatformString();\n                return new PowerMetricsSensorInterface_1.PowerMetricsSensorInterface(options);\n            }\n            case 'perf': {\n                const options = config.getSensorInterfaceOptions();\n                if (options === undefined) {\n                    throw new Error('Profiler.getSensorInterface: sensorInterfaceOptions are not defined');\n                }\n                options.outputFilePath = config.getOutDir().join(options.outputFilePath).toPlatformString();\n                return new PerfSensorInterface_1.PerfSensorInterface(options);\n            }\n            case 'windows': {\n                const options = config.getSensorInterfaceOptions();\n                if (options === undefined) {\n                    throw new Error('Profiler.getSensorInterface: sensorInterfaceOptions are not defined');\n                }\n                options.outputFilePath = config.getOutDir().join(options.outputFilePath).toPlatformString();\n                return new WindowsSensorInterface_1.WindowsSensorInterface(options);\n            }\n        }\n    }\n    loadSensorInterface() {\n        this._sensorInterface = Profiler.getSensorInterface(this.config);\n    }\n    static inject(subOutputDir) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const profiler = new Profiler(subOutputDir);\n            const title = new Date().getTime().toString();\n            const exitResolve = () => resolve('exit');\n            const sigIntResolve = () => resolve('SIGINT');\n            const sigUsr1Resolve = () => resolve('SIGUSR1');\n            const sigUsr2Resolve = () => resolve('SIGUSR2');\n            let stopped = false;\n            function resolve(origin) {\n                return __awaiter(this, void 0, void 0, function* () {\n                    if (!stopped) {\n                        stopped = true;\n                        profiler_core_1.LoggerHelper.log(`(${profiler_core_1.APP_NAME} Profiler) Finish Measurement, please wait...`);\n                        yield profiler.finish(title);\n                        process.removeListener('exit', exitResolve);\n                        process.removeListener('SIGINT', sigIntResolve);\n                        process.removeListener('SIGUSR1', sigUsr1Resolve);\n                        process.removeListener('SIGUSR2', sigUsr2Resolve);\n                        if (origin !== 'exit') {\n                            process.exit();\n                        }\n                    }\n                });\n            }\n            profiler_core_1.LoggerHelper.log(`(${profiler_core_1.APP_NAME} Profiler) Measurement started`);\n            yield profiler.start(title);\n            process.on('exit', exitResolve);\n            // //catches ctrl+c event\n            process.on('SIGINT', sigIntResolve);\n            // // catches \"kill pid\" (for example: nodemon restart)\n            process.on('SIGUSR1', sigUsr1Resolve);\n            process.on('SIGUSR2', sigUsr2Resolve);\n            return profiler;\n        });\n    }\n    startCapturingProfilerTracingEvents() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._traceEventSession !== undefined) {\n                throw new Error('startCapturingProfilerTracingEvents: Trace Event Session should not already be defined');\n            }\n            const session = new inspector_1.Session();\n            this._traceEventSession = session;\n            session.connect();\n            session.on('NodeTracing.dataCollected', (chunk) => {\n                for (const event of chunk.params.value) {\n                    if (event.pid === process.pid && event.cat === 'v8') {\n                        if (event.name === 'CpuProfiler::StartProfiling') { // captured start event of cpu profiler\n                            this._profilerStartTime = event.ts; // store high resolution begin time\n                        }\n                    }\n                }\n            });\n            const traceConfig = { includedCategories: ['v8'] }; // config to capture v8's trace events\n            yield TraceEventHelper_1.TraceEventHelper.post(session, 'NodeTracing.start', { traceConfig }); // start trace event capturing\n        });\n    }\n    stopCapturingProfilerTracingEvents() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._traceEventSession === undefined) {\n                throw new Error('stopCapturingProfilerTracingEvents: Trace Event Session should be defined');\n            }\n            yield TraceEventHelper_1.TraceEventHelper.post(this._traceEventSession, 'NodeTracing.stop', undefined);\n            this._traceEventSession.disconnect();\n            this._traceEventSession = undefined;\n        });\n    }\n    getCPUProfilerBeginTime() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let tries = 0;\n            while (this._profilerStartTime === undefined && tries < 10) {\n                profiler_core_1.LoggerHelper.error(`Cannot capture profiler start time on try: ${tries + 1}, try again after 1 second`);\n                tries += 1;\n                yield profiler_core_1.TimeHelper.sleep(1000);\n            }\n            if (this._profilerStartTime === undefined) {\n                throw new Error(`Could not capture cpu profilers begin time after ${tries} tries, measurements failed`);\n            }\n            return this._profilerStartTime;\n        });\n    }\n    start(title, executionDetails) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const performance = new profiler_core_1.PerformanceHelper();\n            performance.start('Profiler.start');\n            const outFileReport = this.outputReportPath(title);\n            const outDir = outFileReport.dirName();\n            performance.start('Profiler.start.createOutDir');\n            if (!fs.existsSync(outDir.toPlatformString())) {\n                profiler_core_1.PermissionHelper.mkdirRecursivelyWithUserPermission(outDir);\n            }\n            performance.stop('Profiler.start.createOutDir');\n            performance.start('Profiler.start.seedRandom');\n            const mathRandomSeed = this.config.getSeedForMathRandom();\n            if (mathRandomSeed) {\n                (0, seedrandom_1.default)(mathRandomSeed, { global: true });\n            }\n            performance.stop('Profiler.start.seedRandom');\n            if (executionDetails) {\n                this.executionDetails = executionDetails;\n            }\n            else {\n                performance.start('Profiler.start.resolveExecutionDetails');\n                this.executionDetails = yield profiler_core_1.ExecutionDetails.resolveExecutionDetails();\n                performance.stop('Profiler.start.resolveExecutionDetails');\n            }\n            performance.start('Profiler.start.V8Profiler.setGenerateType');\n            V8Profiler_1.V8Profiler.setGenerateType(1); // must be set to generate new cpuprofile format\n            performance.stop('Profiler.start.V8Profiler.setGenerateType');\n            performance.start('Profiler.start.getV8CPUSamplingInterval');\n            V8Profiler_1.V8Profiler.setSamplingInterval(this.config.getV8CPUSamplingInterval()); // sets the sampling interval in microseconds\n            performance.stop('Profiler.start.getV8CPUSamplingInterval');\n            performance.start('Profiler.start.startCapturingProfilerTracingEvents');\n            yield this.startCapturingProfilerTracingEvents();\n            performance.stop('Profiler.start.startCapturingProfilerTracingEvents');\n            performance.start('Profiler.start.sensorInterface.couldBeExecuted');\n            if (this._sensorInterface !== undefined && !(yield this._sensorInterface.couldBeExecuted())) {\n                // remove sensor interface from execution details since it cannot be executed\n                this.executionDetails.runTimeOptions.sensorInterface = undefined;\n                profiler_core_1.LoggerHelper.warn(`(${profiler_core_1.APP_NAME} Profiler) Warning: ` +\n                    'Sensor Interface can not be executed, no energy measurements will be collected');\n            }\n            performance.stop('Profiler.start.sensorInterface.couldBeExecuted');\n            performance.start('Profiler.start.sensorInterface.startProfiling');\n            yield ((_a = this._sensorInterface) === null || _a === void 0 ? void 0 : _a.startProfiling());\n            performance.stop('Profiler.start.sensorInterface.startProfiling');\n            // title - handle to stop profile again\n            // recsampels(boolean) - record samples, if false no cpu times will be captured\n            performance.start('Profiler.start.V8Profiler.startProfiling');\n            V8Profiler_1.V8Profiler.startProfiling(title, true);\n            performance.stop('Profiler.start.V8Profiler.startProfiling');\n            performance.start('Profiler.start.inspectorHelper.connect');\n            yield this._inspectorHelper.connect();\n            this._inspectorHelper.listen();\n            performance.stop('Profiler.start.inspectorHelper.connect');\n            performance.stop('Profiler.start');\n            performance.printReport('Profiler.start');\n            performance.exportAndSum(this.outputDir().join('performance.json'));\n        });\n    }\n    outputDir() {\n        return this.config.getOutDir().join(this.subOutputDir || '');\n    }\n    outputReportPath(title) {\n        return this.outputDir().join(`${title}.oak`);\n    }\n    outputMetricCollectionPath(title) {\n        return this.outputDir().join(`${title}.mcollection`);\n    }\n    outputProfilePath(title) {\n        return this.outputDir().join(`${title}.cpuprofile`);\n    }\n    outputInspectorHelperPath(title) {\n        return this.outputDir().join(`${title}.inspector.json`);\n    }\n    finish(title, highResolutionStopTime) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            const performance = new profiler_core_1.PerformanceHelper();\n            performance.start('Profiler.finish');\n            if (this.executionDetails === undefined) {\n                throw new Error('Profiler.finish: Profiler was not started yet');\n            }\n            if (highResolutionStopTime !== undefined) {\n                this.executionDetails.highResolutionStopTime = highResolutionStopTime.toString();\n            }\n            performance.start('Profiler.finish.stopProfiling');\n            const profile = V8Profiler_1.V8Profiler.stopProfiling(title);\n            performance.stop('Profiler.finish.stopProfiling');\n            performance.start('Profiler.finish.stopCapturingProfilerTracingEvents');\n            this.stopCapturingProfilerTracingEvents();\n            performance.stop('Profiler.finish.stopCapturingProfilerTracingEvents');\n            performance.start('Profiler.finish.sensorInterface.stopProfiling');\n            yield ((_a = this._sensorInterface) === null || _a === void 0 ? void 0 : _a.stopProfiling());\n            performance.stop('Profiler.finish.sensorInterface.stopProfiling');\n            const CPUProfilerBeginTime = BigInt(yield this.getCPUProfilerBeginTime()) * BigInt(1000);\n            this.executionDetails.highResolutionBeginTime = CPUProfilerBeginTime.toString();\n            const exportData = {\n                nodes: profile.nodes,\n                startTime: profile.startTime,\n                endTime: profile.endTime,\n                samples: profile.samples,\n                timeDeltas: profile.timeDeltas\n            };\n            let transformerAdapter = undefined;\n            if (((_b = this.options) === null || _b === void 0 ? void 0 : _b.transformerAdapter) === 'ts-jest') {\n                if (!this.options.jestAdapter.config || !this.options.jestAdapter.context) {\n                    throw new Error('Please provide the JestEnvironmentConfig and EnvironmentContext in the profiler options at options.jestAdapter');\n                }\n                transformerAdapter = new profiler_core_1.JestAdapter(this.options.jestAdapter.config, this.options.jestAdapter.context);\n                if (!fs.existsSync(this.outputDir().toPlatformString())) {\n                    profiler_core_1.PermissionHelper.mkdirRecursivelyWithUserPermission(this.outputDir());\n                }\n                performance.start('Profiler.finish.exportJestConfig');\n                profiler_core_1.PermissionHelper.writeFileWithUserPermission(this.outputDir().join('jest.config').toPlatformString(), JSON.stringify({\n                    config: this.options.jestAdapter.config,\n                    context: this.options.jestAdapter.context\n                }));\n                performance.stop('Profiler.finish.exportJestConfig');\n            }\n            const outFileCPUProfile = this.outputProfilePath(title);\n            const outFileInspectorHelper = this.outputInspectorHelperPath(title);\n            const outFileReport = this.outputReportPath(title);\n            const outFileMetricCollection = this.outputMetricCollectionPath(title);\n            if (this.config.shouldExportV8Profile()) {\n                performance.start('Profiler.finish.exportV8Profile');\n                profiler_core_1.PermissionHelper.writeFileWithUserPermission(outFileCPUProfile.toPlatformString(), JSON.stringify(exportData, null, 2));\n                performance.stop('Profiler.finish.exportV8Profile');\n            }\n            performance.start('Profiler.finish.sensorInterface.readSensorValues');\n            const metricsDataCollection = yield ((_c = this._sensorInterface) === null || _c === void 0 ? void 0 : _c.readSensorValues(process.pid));\n            performance.stop('Profiler.finish.sensorInterface.readSensorValues');\n            const rootDir = this.config.getRootDir();\n            const report = new profiler_core_1.ProjectReport(this.executionDetails, profiler_core_1.ReportKind.measurement);\n            if (this.config.shouldExportSensorInterfaceData()) {\n                if (metricsDataCollection !== undefined) {\n                    performance.start('Profiler.finish.exportMetricsDataCollection');\n                    metricsDataCollection.storeToFile(outFileMetricCollection);\n                    performance.stop('Profiler.finish.exportMetricsDataCollection');\n                }\n            }\n            performance.start('Profiler.finish.insertCPUProfile');\n            yield report.insertCPUProfile(rootDir, profile, this._inspectorHelper, metricsDataCollection);\n            performance.stop('Profiler.finish.insertCPUProfile');\n            performance.start('Profiler.finish.inspectorHelper.disconnect');\n            yield this._inspectorHelper.disconnect();\n            performance.stop('Profiler.finish.inspectorHelper.disconnect');\n            if (this.config.shouldExportV8Profile()) {\n                performance.start('Profiler.finish.exportInspectorHelper');\n                profiler_core_1.PermissionHelper.writeFileWithUserPermission(outFileInspectorHelper.toPlatformString(), JSON.stringify(this._inspectorHelper, null, 2));\n                performance.stop('Profiler.finish.exportInspectorHelper');\n            }\n            performance.start('Profiler.finish.trackUncommittedFiles');\n            yield report.trackUncommittedFiles(rootDir);\n            performance.stop('Profiler.finish.trackUncommittedFiles');\n            if (this.config.shouldExportReport()) {\n                performance.start('Profiler.finish.exportReport');\n                report.storeToFile(outFileReport, 'bin', this.config);\n                performance.stop('Profiler.finish.exportReport');\n            }\n            if (yield report.shouldBeStoredInRegistry()) {\n                yield report.uploadToRegistry(this.config);\n            }\n            performance.stop('Profiler.finish');\n            performance.printReport('Profiler.finish');\n            performance.exportAndSum(this.outputDir().join('performance.json'));\n            return report;\n        });\n    }\n}\nexports.Profiler = Profiler;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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"
    },
    "547": {
      "sourceCode": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.V8Profiler = void 0;\nconst profiler_core_1 = require(\"@oaklean/profiler-core\");\nconst WEBPACK_URL_REGEX = /webpack-internal:\\/\\/(.+?[^/]\\/)([^?]+)(.*)$/;\nfunction parseWebpackSourceMapUrl(url) {\n    const matches = WEBPACK_URL_REGEX.exec(url);\n    if (matches && matches.length > 2) {\n        const module = matches[1];\n        const filePath = matches[2];\n        return {\n            module,\n            filePath\n        };\n    }\n    return null;\n}\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst v8Profiler = require('v8-profiler-next');\nclass V8Profiler {\n    static startProfiling(name, recsamples, mode) {\n        v8Profiler.startProfiling(name, recsamples, mode);\n    }\n    static stopProfiling(name) {\n        const profile = v8Profiler.stopProfiling(name);\n        V8Profiler.cleanUpProfile(profile);\n        V8Profiler.unifyProfile(profile);\n        return profile;\n    }\n    static setGenerateType(type) {\n        v8Profiler.setGenerateType(type);\n    }\n    static setSamplingInterval(num) {\n        v8Profiler.setSamplingInterval(num);\n    }\n    /**\n     * Unifies the V8 Profile to ensure compatibility between linux / mac / windows\n     * All filePaths are converted to unix paths\n     *\n     * @param profile\n     */\n    static unifyProfile(profile) {\n        for (const node of profile.nodes) {\n            if (node.callFrame.url !== '' && !node.callFrame.url.startsWith('node:')) {\n                if (node.callFrame.url.startsWith('file://')) {\n                    node.callFrame.url = node.callFrame.url.slice(7);\n                }\n                if (node.callFrame.url.startsWith('webpack-internal://')) {\n                    const match = parseWebpackSourceMapUrl(node.callFrame.url);\n                    if (match !== null) {\n                        node.callFrame.url = match.filePath;\n                        console.log({\n                            id: node.id,\n                            module: match.module,\n                            url: match.filePath,\n                            line: node.callFrame.lineNumber,\n                            col: node.callFrame.columnNumber\n                        });\n                    }\n                }\n                node.callFrame.url = new profiler_core_1.UnifiedPath(node.callFrame.url).toString();\n            }\n        }\n    }\n    // Method to fix accumulated errors in cpu profiles caused by negative timeDelta\n    // https://github.com/jlfwong/speedscope/blob/main/src/import/chrome.ts\n    // https://github.com/jlfwong/speedscope/pull/305\n    static cleanUpProfile(profile) {\n        if (profile.samples === undefined || profile.timeDeltas === undefined) {\n            throw new Error('V8Profiler.cleanUpProfile: profile format is not complete');\n        }\n        const sampleTimes = [];\n        // The first delta is relative to the profile startTime.\n        // Ref: https://github.com/v8/v8/blob/44bd8fd7/src/inspector/js_protocol.json#L1485\n        let elapsed = profile.timeDeltas[0];\n        // Prevents negative time deltas from causing bad data. See\n        // https://github.com/jlfwong/speedscope/pull/305 for details.\n        let lastValidElapsed = elapsed;\n        // The chrome CPU profile format doesn't collapse identical samples. We'll do that\n        // here to save a ton of work later doing mergers.\n        for (let i = 0; i < profile.samples.length; i++) {\n            if (elapsed < lastValidElapsed) {\n                sampleTimes.push(lastValidElapsed);\n            }\n            else {\n                sampleTimes.push(elapsed);\n                lastValidElapsed = elapsed;\n            }\n            if (i === profile.samples.length - 1) {\n                if (elapsed < lastValidElapsed) {\n                    sampleTimes.push(lastValidElapsed);\n                }\n                else {\n                    sampleTimes.push(elapsed);\n                    lastValidElapsed = elapsed;\n                }\n            }\n            else {\n                const timeDelta = profile.timeDeltas[i + 1];\n                elapsed += timeDelta;\n            }\n        }\n        let latest = sampleTimes[0];\n        const timeDeltas = [latest];\n        for (let i = 1; i < sampleTimes.length - 1; i++) {\n            const delta = sampleTimes[i] - latest;\n            timeDeltas.push(delta);\n            latest = sampleTimes[i];\n        }\n        profile.timeDeltas = timeDeltas;\n    }\n}\nexports.V8Profiler = V8Profiler;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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"
    },
    "548": {
      "sourceCode": "'use strict';\n\nconst Stream = require('stream').Stream;\nconst inherits = require('util').inherits;\nconst binding = require('./lib/binding');\nconst workerThreads = require('./lib/worker_threads');\n\nfunction global_check() {\n  const version = process.versions.node.split('.').map(item => Number(item));\n  const greater_than_12_15_0 = version[0] > 12 || (version[0] === 12 && version[1] > 15);\n  return { greater_than_12_15_0 };\n}\n\nbinding.setup({\n  debug: !!process.env.V8_PROFILER_DEBUG,\n  thread_id: workerThreads.threadId\n}, global_check);\n\nfunction nodes(snapshot) {\n  let n = snapshot.nodesCount, i, nodes = [];\n  for (i = 0; i < n; i++) {\n    nodes[i] = snapshot.getNode(i);\n  }\n  return nodes;\n}\n\nfunction nodesHist(snapshot) {\n  let objects = {};\n  nodes(snapshot).forEach(function (node) {\n    let key = node.type === 'Object' ? node.name : node.type;\n    objects[key] = objects[node.name] || 0;\n    objects[key]++;\n  });\n  return objects;\n}\n\nfunction Snapshot() { }\n\nSnapshot.prototype.getHeader = function () {\n  return {\n    typeId: this.typeId,\n    uid: this.uid,\n    title: this.title\n  };\n};\n\n/**\n* @param {Snapshot} other\n* @returns {Object}\n*/\nSnapshot.prototype.compare = function (other) {\n  let selfHist = nodesHist(this),\n    otherHist = nodesHist(other),\n    keys = Object.keys(selfHist).concat(Object.keys(otherHist)),\n    diff = {};\n\n  keys.forEach(function (key) {\n    if (key in diff) { return; }\n\n    let selfCount = selfHist[key] || 0,\n      otherCount = otherHist[key] || 0;\n\n    diff[key] = otherCount - selfCount;\n  });\n\n  return diff;\n};\n\nfunction ExportStream() {\n  Stream.Transform.call(this);\n  this._transform = function noTransform(chunk, encoding, done) {\n    done(null, chunk);\n  };\n}\ninherits(ExportStream, Stream.Transform);\n\n/**\n* @param {Stream.Writable|function} dataReceiver\n* @returns {Stream|undefined}\n*/\nSnapshot.prototype.export = function (dataReceiver) {\n  dataReceiver = dataReceiver || new ExportStream();\n\n  let toStream = dataReceiver instanceof Stream,\n    chunks = toStream ? null : [];\n\n  function onChunk(chunk, len) {\n    if (toStream) { dataReceiver.write(chunk); }\n    else { chunks.push(chunk); }\n  }\n\n  function onDone() {\n    if (toStream) { dataReceiver.end(); }\n    else { dataReceiver(null, chunks.join('')); }\n  }\n\n  this.serialize(onChunk, onDone);\n\n  return toStream ? dataReceiver : undefined;\n};\n\nfunction CpuProfile() { }\n\nCpuProfile.prototype.getHeader = function () {\n  return {\n    typeId: this.typeId,\n    uid: this.uid,\n    title: this.title\n  };\n};\n\nCpuProfile.prototype.export = function (dataReceiver) {\n  dataReceiver = dataReceiver || new ExportStream();\n\n  let toStream = dataReceiver instanceof Stream;\n  let error, result;\n\n  try {\n    result = JSON.stringify(this);\n  } catch (err) {\n    error = err;\n  }\n\n  process.nextTick(function () {\n    if (toStream) {\n      if (error) {\n        dataReceiver.emit('error', error);\n      }\n\n      dataReceiver.end(result);\n    } else {\n      dataReceiver(error, result);\n    }\n  });\n\n  return toStream ? dataReceiver : undefined;\n};\n\nfunction SamplingHeapProfile() { }\n\nSamplingHeapProfile.prototype.export = function (dataReceiver) {\n  dataReceiver = dataReceiver || new ExportStream();\n\n  let toStream = dataReceiver instanceof Stream;\n  let error, result;\n\n  try {\n    result = JSON.stringify(this);\n  } catch (err) {\n    error = err;\n  }\n\n  process.nextTick(function () {\n    if (toStream) {\n      if (error) {\n        dataReceiver.emit('error', error);\n      }\n\n      dataReceiver.end(result);\n    } else {\n      dataReceiver(error, result);\n    }\n  });\n\n  return toStream ? dataReceiver : undefined;\n};\n\nlet startTime, endTime;\nlet activeProfiles = [];\n\nlet profiler = {\n  /*HEAP PROFILER API*/\n\n  get snapshots() { return binding.heap.snapshots; },\n\n  takeSnapshot: function (name, control) {\n    if (typeof name === 'function') {\n      control = name;\n      name = '';\n    }\n\n    if (typeof control !== 'function') {\n      control = function noop() { };\n    }\n\n    name = name ? '' + name : '';\n\n    let snapshot = binding.heap.takeSnapshot(name, control);\n    snapshot.__proto__ = Snapshot.prototype;\n    snapshot.title = name ? name : snapshot.title;\n    return snapshot;\n  },\n\n  deleteAllSnapshots: function () {\n    Object.keys(binding.heap.snapshots).forEach(function (key) {\n      binding.heap.snapshots[key].delete();\n    });\n  },\n\n  startTrackingHeapObjects: function () {\n    binding.heap.startTrackingHeapObjects();\n  },\n\n  stopTrackingHeapObjects: function () {\n    binding.heap.stopTrackingHeapObjects();\n  },\n\n  getHeapStats: function (iterator, callback) {\n    if (typeof iterator !== 'function') { iterator = function noop() { }; }\n\n    if (typeof callback !== 'function') { callback = function noop() { }; }\n\n    return binding.heap.getHeapStats(iterator, callback);\n  },\n\n  getObjectByHeapObjectId: function (id) {\n    id = parseInt(id, 10);\n    if (isNaN(id)) { return; }\n\n    return binding.heap.getObjectByHeapObjectId(id);\n  },\n\n  getHeapObjectId: function (value) {\n    if (!arguments.length) { return; }\n    return binding.heap.getHeapObjectId(value);\n  },\n\n  /*CPU PROFILER API*/\n\n  get profiles() { return binding.cpu.profiles; },\n\n  setGenerateType: function (type) {\n    const types = [0, 1];\n    if (types.indexOf(type) > -1) {\n      binding.cpu.setGenerateType(type);\n    } else {\n      console.error(`type should in [${types.join(', ')}], got ${type}.`);\n    }\n  },\n\n  setProfilesCleanupLimit: function (limit) {\n    if (!isNaN(limit)) {\n      binding.cpu.setProfilesCleanupLimit(Number(limit));\n    } else {\n      console.error(`limit should be number.`);\n    }\n  },\n\n  startProfiling: function (name, recsamples, mode) {\n    if (activeProfiles.length === 0 && typeof process._startProfilerIdleNotifier === 'function') {\n      process._startProfilerIdleNotifier();\n    }\n\n    if (typeof name === 'boolean') {\n      recsamples = name;\n      name = '';\n    }\n\n    if ([0, 1].indexOf(mode) === -1) {\n      mode = 0;\n    }\n\n    recsamples = recsamples === undefined ? true : Boolean(recsamples);\n    name = name && '' + name || '';\n\n    if (activeProfiles.indexOf(name) < 0) { activeProfiles.push(name); }\n\n    startTime = Date.now();\n    binding.cpu.startProfiling(name, recsamples, mode);\n  },\n\n  stopProfiling: function (name) {\n    let index = activeProfiles.indexOf(name);\n    if (name && index < 0) { return; }\n\n    let profile = binding.cpu.stopProfiling(name);\n    endTime = Date.now();\n    profile.__proto__ = CpuProfile.prototype;\n    if (!profile.startTime) { profile.startTime = startTime; }\n    if (!profile.endTime) { profile.endTime = endTime; }\n\n    if (name) { activeProfiles.splice(index, 1); }\n    else { activeProfiles.length = activeProfiles.length - 1; }\n\n    if (activeProfiles.length === 0 && typeof process._stopProfilerIdleNotifier === 'function') {\n      process._stopProfilerIdleNotifier();\n    }\n\n    return profile;\n  },\n\n  setSamplingInterval: function (num) {\n    if (activeProfiles.length) {\n      throw new Error('setSamplingInterval must be called when there are no profiles being recorded.');\n    }\n\n    num = parseInt(num, 10) || 1000;\n    binding.cpu.setSamplingInterval(num);\n  },\n\n  deleteAllProfiles: function () {\n    Object.keys(binding.cpu.profiles).forEach(function (key) {\n      binding.cpu.profiles[key].delete();\n    });\n  },\n\n  collectSample: function () {\n    if (process.versions.modules >= 48) {\n      binding.cpu.collectSample();\n    }\n  },\n\n  /*SAMPLING HEAP PROFILER API*/\n\n  startSamplingHeapProfiling: function (interval, depth) {\n    if (process.versions.modules < 48) { throw new Error('Sampling heap profiler needs node version >= node-v6.0.0!'); }\n    if (arguments.length === 2) { binding.samplingHeap.startSamplingHeapProfiling(interval, depth); }\n    else { binding.samplingHeap.startSamplingHeapProfiling(); }\n  },\n\n  stopSamplingHeapProfiling: function () {\n    if (process.versions.modules < 48) { throw new Error('Sampling heap profiler needs node version >= node-v6.0.0!'); }\n    let profile = binding.samplingHeap.stopSamplingHeapProfiling();\n    profile.__proto__ = SamplingHeapProfile.prototype;\n    return profile;\n  }\n};\n\nmodule.exports = profiler;\nprocess.profiler = profiler;\n"
    }
  },
  "fileInfoPerPath": {
    "./packages/profiler/src/Profiler.ts": {
      "sourceCode": "import * as fs from 'fs'\nimport { Session } from 'inspector'\n\nimport seedrandom from 'seedrandom'\nimport {\n\tAPP_NAME,\n\tUnifiedPath,\n\tProfilerConfig,\n\tProjectReport,\n\tIProjectReportExecutionDetails,\n\tJestAdapter,\n\tTimeHelper,\n\tNanoSeconds_BigInt,\n\tMicroSeconds_number,\n\tReportKind,\n\tPermissionHelper,\n\tLoggerHelper,\n\tExecutionDetails,\n\tPerformanceHelper,\n\tInspectorHelper\n} from '@oaklean/profiler-core'\nimport { JestEnvironmentConfig, EnvironmentContext } from '@jest/environment'\n\nimport { V8Profiler } from './model/V8Profiler'\nimport { TraceEventHelper } from './helper/TraceEventHelper'\nimport { BaseSensorInterface } from './interfaces/BaseSensorInterface'\nimport { PowerMetricsSensorInterface } from './interfaces/powermetrics/PowerMetricsSensorInterface'\nimport { PerfSensorInterface } from './interfaces/perf/PerfSensorInterface'\nimport { WindowsSensorInterface } from './interfaces/windows/WindowsSensorInterface'\n\nexport type TransformerAdapter = 'ts-jest'\n\nexport type ProfilerOptions = {\n\ttransformerAdapter?: TransformerAdapter\n\tjestAdapter: {\n\t\tconfig: JestEnvironmentConfig,\n\t\tcontext: EnvironmentContext\n\t}\n}\n\ninterface TraceEventParams {\n\tpid: number,\n\ttid: number,\n\tts: number,\n\ttts: number,\n\tph: string,\n\tcat: string,\n\tname: string,\n\tdur: number\n\ttdur: number\n}\n\nexport class Profiler {\n\tsubOutputDir: string | undefined\n\tconfig: ProfilerConfig\n\toptions?: ProfilerOptions\n\texecutionDetails?: IProjectReportExecutionDetails\n\n\tprivate _inspectorHelper: InspectorHelper\n\tprivate _sensorInterface: BaseSensorInterface | undefined\n\tprivate _traceEventSession: Session | undefined\n\tprivate _profilerStartTime: MicroSeconds_number | undefined\n\n\tconstructor(\n\t\tsubOutputDir?: string,\n\t\toptions?: ProfilerOptions\n\t) {\n\t\tthis.subOutputDir = subOutputDir\n\t\tthis.config = ProfilerConfig.autoResolve()\n\t\tthis.options = options\n\t\tthis.loadSensorInterface()\n\t\tthis._inspectorHelper = new InspectorHelper()\n\t}\n\n\tstatic getSensorInterface(config: ProfilerConfig) {\n\t\tconst sensorInterfaceType = config.getSensorInterfaceType()\n\t\tswitch (sensorInterfaceType) {\n\t\t\tcase 'powermetrics': {\n\t\t\t\tconst options = config.getSensorInterfaceOptions()\n\t\t\t\tif (options === undefined) {\n\t\t\t\t\tthrow new Error('Profiler.getSensorInterface: sensorInterfaceOptions are not defined')\n\t\t\t\t}\n\t\t\t\toptions.outputFilePath = config.getOutDir().join(options.outputFilePath).toPlatformString()\n\t\t\t\treturn new PowerMetricsSensorInterface(options)\n\t\t\t}\n\t\t\tcase 'perf': {\n\t\t\t\tconst options = config.getSensorInterfaceOptions()\n\t\t\t\tif (options === undefined) {\n\t\t\t\t\tthrow new Error('Profiler.getSensorInterface: sensorInterfaceOptions are not defined')\n\t\t\t\t}\n\t\t\t\toptions.outputFilePath = config.getOutDir().join(options.outputFilePath).toPlatformString()\n\t\t\t\treturn new PerfSensorInterface(options)\n\t\t\t}\n\t\t\tcase 'windows': {\n\t\t\t\tconst options = config.getSensorInterfaceOptions()\n\t\t\t\tif (options === undefined) {\n\t\t\t\t\tthrow new Error('Profiler.getSensorInterface: sensorInterfaceOptions are not defined')\n\t\t\t\t}\n\t\t\t\toptions.outputFilePath = config.getOutDir().join(options.outputFilePath).toPlatformString()\n\t\t\t\treturn new WindowsSensorInterface(options)\n\t\t\t}\n\t\t}\n\t}\n\n\tloadSensorInterface() {\n\t\tthis._sensorInterface = Profiler.getSensorInterface(this.config)\n\t}\n\n\tstatic async inject(subOutputDir?: string): Promise<Profiler> {\n\t\tconst profiler = new Profiler(subOutputDir)\n\n\t\tconst title = new Date().getTime().toString()\n\n\t\tconst exitResolve = () => resolve('exit')\n\t\tconst sigIntResolve = () => resolve('SIGINT')\n\t\tconst sigUsr1Resolve = () => resolve('SIGUSR1')\n\t\tconst sigUsr2Resolve = () => resolve('SIGUSR2')\n\n\n\t\tlet stopped = false\n\t\tasync function resolve(origin: string) {\n\t\t\tif (!stopped) {\n\t\t\t\tstopped = true\n\t\t\t\tLoggerHelper.log(`(${APP_NAME} Profiler) Finish Measurement, please wait...`)\n\t\t\t\tawait profiler.finish(title)\n\t\t\t\tprocess.removeListener('exit', exitResolve)\n\t\t\t\tprocess.removeListener('SIGINT', sigIntResolve)\n\t\t\t\tprocess.removeListener('SIGUSR1', sigUsr1Resolve)\n\t\t\t\tprocess.removeListener('SIGUSR2', sigUsr2Resolve)\n\t\t\t\tif (origin !== 'exit') {\n\t\t\t\t\tprocess.exit()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLoggerHelper.log(`(${APP_NAME} Profiler) Measurement started`)\n\t\tawait profiler.start(title)\n\n\t\tprocess.on('exit', exitResolve)\n\n\t\t// //catches ctrl+c event\n\t\tprocess.on('SIGINT', sigIntResolve)\n\n\t\t// // catches \"kill pid\" (for example: nodemon restart)\n\t\tprocess.on('SIGUSR1', sigUsr1Resolve)\n\t\tprocess.on('SIGUSR2', sigUsr2Resolve)\n\n\t\treturn profiler\n\t}\n\n\tasync startCapturingProfilerTracingEvents() {\n\t\tif (this._traceEventSession !== undefined) {\n\t\t\tthrow new Error('startCapturingProfilerTracingEvents: Trace Event Session should not already be defined')\n\t\t}\n\t\tconst session = new Session()\n\t\tthis._traceEventSession = session\n\t\tsession.connect()\n\t\tsession.on('NodeTracing.dataCollected', (chunk) => {\n\t\t\tfor (const event of (chunk.params.value as TraceEventParams[])) {\n\t\t\t\tif (event.pid === process.pid && event.cat === 'v8') {\n\t\t\t\t\tif (event.name === 'CpuProfiler::StartProfiling') { // captured start event of cpu profiler\n\t\t\t\t\t\tthis._profilerStartTime = event.ts as MicroSeconds_number // store high resolution begin time\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tconst traceConfig = { includedCategories: ['v8'] } // config to capture v8's trace events\n\t\tawait TraceEventHelper.post(session, 'NodeTracing.start', { traceConfig }) // start trace event capturing\n\t}\n\n\tasync stopCapturingProfilerTracingEvents() {\n\t\tif (this._traceEventSession === undefined) {\n\t\t\tthrow new Error('stopCapturingProfilerTracingEvents: Trace Event Session should be defined')\n\t\t}\n\t\tawait TraceEventHelper.post(this._traceEventSession, 'NodeTracing.stop', undefined)\n\t\tthis._traceEventSession.disconnect()\n\t\tthis._traceEventSession = undefined\n\t}\n\n\tasync getCPUProfilerBeginTime(): Promise<MicroSeconds_number> {\n\t\tlet tries = 0\n\t\twhile (this._profilerStartTime === undefined && tries < 10) {\n\t\t\tLoggerHelper.error(`Cannot capture profiler start time on try: ${tries + 1}, try again after 1 second`)\n\t\t\ttries += 1\n\t\t\tawait TimeHelper.sleep(1000)\n\t\t}\n\t\tif (this._profilerStartTime === undefined) {\n\t\t\tthrow new Error(`Could not capture cpu profilers begin time after ${tries} tries, measurements failed`)\n\t\t}\n\t\treturn this._profilerStartTime\n\t}\n\n\tasync start(title: string, executionDetails?: IProjectReportExecutionDetails) {\n\t\tconst performance = new PerformanceHelper()\n\t\tperformance.start('Profiler.start')\n\n\t\tconst outFileReport = this.outputReportPath(title)\n\t\tconst outDir = outFileReport.dirName()\n\n\t\tperformance.start('Profiler.start.createOutDir')\n\t\tif (!fs.existsSync(outDir.toPlatformString())) {\n\t\t\tPermissionHelper.mkdirRecursivelyWithUserPermission(outDir)\n\t\t}\n\t\tperformance.stop('Profiler.start.createOutDir')\n\n\t\tperformance.start('Profiler.start.seedRandom')\n\t\tconst mathRandomSeed = this.config.getSeedForMathRandom()\n\t\tif (mathRandomSeed) {\n\t\t\tseedrandom(mathRandomSeed, { global: true })\n\t\t}\n\t\tperformance.stop('Profiler.start.seedRandom')\n\n\t\tif (executionDetails) {\n\t\t\tthis.executionDetails = executionDetails\n\t\t} else {\n\t\t\tperformance.start('Profiler.start.resolveExecutionDetails')\n\t\t\tthis.executionDetails = await ExecutionDetails.resolveExecutionDetails()\n\t\t\tperformance.stop('Profiler.start.resolveExecutionDetails')\n\t\t}\n\t\tperformance.start('Profiler.start.V8Profiler.setGenerateType')\n\t\tV8Profiler.setGenerateType(1) // must be set to generate new cpuprofile format\n\t\tperformance.stop('Profiler.start.V8Profiler.setGenerateType')\n\n\t\tperformance.start('Profiler.start.getV8CPUSamplingInterval')\n\t\tV8Profiler.setSamplingInterval(this.config.getV8CPUSamplingInterval()) // sets the sampling interval in microseconds\n\t\tperformance.stop('Profiler.start.getV8CPUSamplingInterval')\n\n\t\tperformance.start('Profiler.start.startCapturingProfilerTracingEvents')\n\t\tawait this.startCapturingProfilerTracingEvents()\n\t\tperformance.stop('Profiler.start.startCapturingProfilerTracingEvents')\n\n\t\tperformance.start('Profiler.start.sensorInterface.couldBeExecuted')\n\t\tif (this._sensorInterface !== undefined && !await this._sensorInterface.couldBeExecuted()) {\n\t\t\t// remove sensor interface from execution details since it cannot be executed\n\t\t\tthis.executionDetails.runTimeOptions.sensorInterface = undefined\n\t\t\tLoggerHelper.warn(`(${APP_NAME} Profiler) Warning: ` + \n\t\t\t\t'Sensor Interface can not be executed, no energy measurements will be collected')\n\t\t}\n\t\tperformance.stop('Profiler.start.sensorInterface.couldBeExecuted')\n\n\t\tperformance.start('Profiler.start.sensorInterface.startProfiling')\n\t\tawait this._sensorInterface?.startProfiling()\n\t\tperformance.stop('Profiler.start.sensorInterface.startProfiling')\n\n\t\t// title - handle to stop profile again\n\t\t// recsampels(boolean) - record samples, if false no cpu times will be captured\n\t\tperformance.start('Profiler.start.V8Profiler.startProfiling')\n\t\tV8Profiler.startProfiling(title, true)\n\t\tperformance.stop('Profiler.start.V8Profiler.startProfiling')\n\t\tperformance.start('Profiler.start.inspectorHelper.connect')\n\t\tawait this._inspectorHelper.connect()\n\t\tthis._inspectorHelper.listen()\n\t\tperformance.stop('Profiler.start.inspectorHelper.connect')\n\t\tperformance.stop('Profiler.start')\n\t\tperformance.printReport('Profiler.start')\n\t\tperformance.exportAndSum(this.outputDir().join('performance.json'))\n\t}\n\n\toutputDir(): UnifiedPath {\n\t\treturn this.config.getOutDir().join(this.subOutputDir || '')\n\t}\n\n\toutputReportPath(title: string): UnifiedPath {\n\t\treturn this.outputDir().join(`${title}.oak`)\n\t}\n\n\toutputMetricCollectionPath(title: string): UnifiedPath {\n\t\treturn this.outputDir().join(`${title}.mcollection`)\n\t}\n\n\toutputProfilePath(title: string): UnifiedPath {\n\t\treturn this.outputDir().join(`${title}.cpuprofile`)\n\t}\n\n\toutputInspectorHelperPath(title: string): UnifiedPath {\n\t\treturn this.outputDir().join(`${title}.inspector.json`)\n\t}\n\n\tasync finish(title: string, highResolutionStopTime?: NanoSeconds_BigInt): Promise<ProjectReport> {\n\t\tconst performance = new PerformanceHelper()\n\t\t\n\t\tperformance.start('Profiler.finish')\n\t\tif (this.executionDetails === undefined) {\n\t\t\tthrow new Error('Profiler.finish: Profiler was not started yet')\n\t\t}\n\t\tif (highResolutionStopTime !== undefined) {\n\t\t\tthis.executionDetails.highResolutionStopTime = highResolutionStopTime.toString()\n\t\t}\n\n\t\tperformance.start('Profiler.finish.stopProfiling')\n\t\tconst profile = V8Profiler.stopProfiling(title)\n\t\tperformance.stop('Profiler.finish.stopProfiling')\n\n\t\tperformance.start('Profiler.finish.stopCapturingProfilerTracingEvents')\n\t\tthis.stopCapturingProfilerTracingEvents()\n\t\tperformance.stop('Profiler.finish.stopCapturingProfilerTracingEvents')\n\n\t\tperformance.start('Profiler.finish.sensorInterface.stopProfiling')\n\t\tawait this._sensorInterface?.stopProfiling()\n\t\tperformance.stop('Profiler.finish.sensorInterface.stopProfiling')\n\n\t\tconst CPUProfilerBeginTime = BigInt(await this.getCPUProfilerBeginTime()) * BigInt(1000) as NanoSeconds_BigInt\n\t\tthis.executionDetails.highResolutionBeginTime = CPUProfilerBeginTime.toString()\n\n\t\tconst exportData = {\n\t\t\tnodes: profile.nodes,\n\t\t\tstartTime: profile.startTime,\n\t\t\tendTime: profile.endTime,\n\t\t\tsamples: profile.samples,\n\t\t\ttimeDeltas: profile.timeDeltas\n\t\t}\n\t\tlet transformerAdapter = undefined\n\t\tif (this.options?.transformerAdapter === 'ts-jest') {\n\t\t\tif (!this.options.jestAdapter.config || !this.options.jestAdapter.context) {\n\t\t\t\tthrow new Error('Please provide the JestEnvironmentConfig and EnvironmentContext in the profiler options at options.jestAdapter')\n\t\t\t}\n\t\t\ttransformerAdapter = new JestAdapter(\n\t\t\t\tthis.options.jestAdapter.config,\n\t\t\t\tthis.options.jestAdapter.context\n\t\t\t)\n\t\t\tif (!fs.existsSync(this.outputDir().toPlatformString())) {\n\t\t\t\tPermissionHelper.mkdirRecursivelyWithUserPermission(this.outputDir())\n\t\t\t}\n\t\t\tperformance.start('Profiler.finish.exportJestConfig')\n\t\t\tPermissionHelper.writeFileWithUserPermission(\n\t\t\t\tthis.outputDir().join('jest.config').toPlatformString(),\n\t\t\t\tJSON.stringify({\n\t\t\t\t\tconfig: this.options.jestAdapter.config,\n\t\t\t\t\tcontext: this.options.jestAdapter.context\n\t\t\t\t})\n\t\t\t)\n\t\t\tperformance.stop('Profiler.finish.exportJestConfig')\n\t\t}\n\t\tconst outFileCPUProfile = this.outputProfilePath(title)\n\t\tconst outFileInspectorHelper = this.outputInspectorHelperPath(title)\n\t\tconst outFileReport = this.outputReportPath(title)\n\t\tconst outFileMetricCollection = this.outputMetricCollectionPath(title)\n\t\tif (this.config.shouldExportV8Profile()) {\n\t\t\tperformance.start('Profiler.finish.exportV8Profile')\n\t\t\tPermissionHelper.writeFileWithUserPermission(\n\t\t\t\toutFileCPUProfile.toPlatformString(),\n\t\t\t\tJSON.stringify(exportData, null, 2),\n\t\t\t)\n\t\t\tperformance.stop('Profiler.finish.exportV8Profile')\n\t\t}\n\t\tperformance.start('Profiler.finish.sensorInterface.readSensorValues')\n\t\tconst metricsDataCollection = await this._sensorInterface?.readSensorValues(process.pid)\n\t\tperformance.stop('Profiler.finish.sensorInterface.readSensorValues')\n\n\t\tconst rootDir = this.config.getRootDir()\n\t\tconst report = new ProjectReport(this.executionDetails, ReportKind.measurement)\n\t\tif (this.config.shouldExportSensorInterfaceData()) {\n\t\t\tif (metricsDataCollection !== undefined) {\n\t\t\t\tperformance.start('Profiler.finish.exportMetricsDataCollection')\n\t\t\t\tmetricsDataCollection.storeToFile(outFileMetricCollection)\n\t\t\t\tperformance.stop('Profiler.finish.exportMetricsDataCollection')\n\t\t\t}\n\t\t}\n\n\t\tperformance.start('Profiler.finish.insertCPUProfile')\n\t\tawait report.insertCPUProfile(\n\t\t\trootDir,\n\t\t\tprofile,\n\t\t\tthis._inspectorHelper,\n\t\t\tmetricsDataCollection\n\t\t)\n\t\tperformance.stop('Profiler.finish.insertCPUProfile')\n\n\t\tperformance.start('Profiler.finish.inspectorHelper.disconnect')\n\t\tawait this._inspectorHelper.disconnect()\n\t\tperformance.stop('Profiler.finish.inspectorHelper.disconnect')\n\n\t\tif (this.config.shouldExportV8Profile()) {\n\t\t\tperformance.start('Profiler.finish.exportInspectorHelper')\n\t\t\tPermissionHelper.writeFileWithUserPermission(\n\t\t\t\toutFileInspectorHelper.toPlatformString(),\n\t\t\t\tJSON.stringify(this._inspectorHelper, null, 2),\n\t\t\t)\n\t\t\tperformance.stop('Profiler.finish.exportInspectorHelper')\n\t\t}\n\n\t\tperformance.start('Profiler.finish.trackUncommittedFiles')\n\t\tawait report.trackUncommittedFiles(rootDir)\n\t\tperformance.stop('Profiler.finish.trackUncommittedFiles')\n\n\t\tif (this.config.shouldExportReport()) {\n\t\t\tperformance.start('Profiler.finish.exportReport')\n\t\t\treport.storeToFile(outFileReport, 'bin', this.config)\n\t\t\tperformance.stop('Profiler.finish.exportReport')\n\t\t}\n\n\t\tif (await report.shouldBeStoredInRegistry()) {\n\t\t\tawait report.uploadToRegistry(this.config)\n\t\t}\n\t\tperformance.stop('Profiler.finish')\n\t\tperformance.printReport('Profiler.finish')\n\t\tperformance.exportAndSum(this.outputDir().join('performance.json'))\n\n\t\treturn report\n\t}\n}\n"
    },
    "./packages/profiler/src/model/V8Profiler.ts": {
      "sourceCode": "import * as fs from 'fs'\n\nimport type { Protocol as Cdp } from 'devtools-protocol'\nimport { MicroSeconds_number, UnifiedPath } from '@oaklean/profiler-core'\n\nconst WEBPACK_URL_REGEX = /webpack-internal:\\/\\/(.+?[^/]\\/)([^?]+)(.*)$/\n\nfunction parseWebpackSourceMapUrl(url: string) {\n\tconst matches = WEBPACK_URL_REGEX.exec(url)\n\tif (matches && matches.length > 2) {\n\t\tconst module = matches[1]\n\t\tconst filePath = matches[2]\n\t\treturn {\n\t\t\tmodule,\n\t\t\tfilePath\n\t\t}\n\t}\n\treturn null\n}\n\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst v8Profiler = require('v8-profiler-next')\n\nexport class V8Profiler {\n\tstatic startProfiling(name: string, recsamples?: boolean, mode?: 0 | 1) : void {\n\t\tv8Profiler.startProfiling(name, recsamples, mode)\n\t}\n\n\tstatic stopProfiling(name?: string): Cdp.Profiler.Profile {\n\t\tconst profile = v8Profiler.stopProfiling(name)\n\t\tV8Profiler.cleanUpProfile(profile)\n\t\tV8Profiler.unifyProfile(profile)\n\t\treturn profile\n\t}\n\n\tstatic setGenerateType(type: 0 | 1) {\n\t\tv8Profiler.setGenerateType(type)\n\t}\n\n\tstatic setSamplingInterval(num: MicroSeconds_number) {\n\t\tv8Profiler.setSamplingInterval(num)\n\t}\n\n\t/**\n\t * Unifies the V8 Profile to ensure compatibility between linux / mac / windows\n\t * All filePaths are converted to unix paths\n\t * \n\t * @param profile \n\t */\n\tstatic unifyProfile(profile: Cdp.Profiler.Profile) {\n\t\tfor (const node of profile.nodes) {\n\t\t\tif (node.callFrame.url !== '' && !node.callFrame.url.startsWith('node:')) {\n\t\t\t\tif (node.callFrame.url.startsWith('file://')) {\n\t\t\t\t\tnode.callFrame.url = node.callFrame.url.slice(7)\n\t\t\t\t}\n\t\t\t\tif (node.callFrame.url.startsWith('webpack-internal://')) {\n\t\t\t\t\tconst match = parseWebpackSourceMapUrl(node.callFrame.url)\n\t\t\t\t\tif (match !== null) {\n\t\t\t\t\t\tnode.callFrame.url = match.filePath\n\t\t\t\t\t\tconsole.log({\n\t\t\t\t\t\t\tid: node.id,\n\t\t\t\t\t\t\tmodule: match.module,\n\t\t\t\t\t\t\turl: match.filePath,\n\t\t\t\t\t\t\tline: node.callFrame.lineNumber,\n\t\t\t\t\t\t\tcol: node.callFrame.columnNumber\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode.callFrame.url = new UnifiedPath(node.callFrame.url).toString()\n\t\t\t}\n\t\t}\n\t}\n\n\t// Method to fix accumulated errors in cpu profiles caused by negative timeDelta\n\t// https://github.com/jlfwong/speedscope/blob/main/src/import/chrome.ts\n\t// https://github.com/jlfwong/speedscope/pull/305\n\tstatic cleanUpProfile(profile: Cdp.Profiler.Profile) {\n\t\tif (profile.samples === undefined || profile.timeDeltas === undefined) {\n\t\t\tthrow new Error('V8Profiler.cleanUpProfile: profile format is not complete')\n\t\t}\n\t\tconst sampleTimes: number[] = []\n\n\t\t// The first delta is relative to the profile startTime.\n\t\t// Ref: https://github.com/v8/v8/blob/44bd8fd7/src/inspector/js_protocol.json#L1485\n\t\tlet elapsed = profile.timeDeltas[0]\n\n\t\t// Prevents negative time deltas from causing bad data. See\n\t\t// https://github.com/jlfwong/speedscope/pull/305 for details.\n\t\tlet lastValidElapsed = elapsed\n\n\t\t// The chrome CPU profile format doesn't collapse identical samples. We'll do that\n\t\t// here to save a ton of work later doing mergers.\n\t\tfor (let i = 0; i < profile.samples.length; i++) {\n\t\t\tif (elapsed < lastValidElapsed) {\n\t\t\t\tsampleTimes.push(lastValidElapsed)\n\t\t\t} else {\n\t\t\t\tsampleTimes.push(elapsed)\n\t\t\t\tlastValidElapsed = elapsed\n\t\t\t}\n\n\t\t\tif (i === profile.samples.length - 1) {\n\t\t\t\tif (elapsed < lastValidElapsed) {\n\t\t\t\t\tsampleTimes.push(lastValidElapsed)\n\t\t\t\t} else {\n\t\t\t\t\tsampleTimes.push(elapsed)\n\t\t\t\t\tlastValidElapsed = elapsed\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst timeDelta = profile.timeDeltas[i + 1]\n\t\t\t\telapsed += timeDelta\n\t\t\t}\n\t\t}\n\n\t\tlet latest = sampleTimes[0]\n\t\tconst timeDeltas = [latest]\n\n\t\tfor (let i = 1; i < sampleTimes.length - 1; i++) {\n\t\t\tconst delta = sampleTimes[i] - latest\n\t\t\ttimeDeltas.push(delta)\n\t\t\tlatest = sampleTimes[i]\n\t\t}\n\n\t\tprofile.timeDeltas = timeDeltas\n\t}\n}"
    },
    "./packages/profiler-core/dist/src/helper/InspectorHelper.js": {
      "sourceCode": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InspectorHelper = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst inspector_1 = __importDefault(require(\"inspector\"));\nconst LoggerHelper_1 = require(\"./LoggerHelper\");\nconst PermissionHelper_1 = require(\"./PermissionHelper\");\nconst TypescriptParser_1 = require(\"./TypescriptParser\");\nconst SourceMap_1 = require(\"../model/SourceMap\");\nconst UnifiedPath_1 = require(\"../system/UnifiedPath\");\nclass InspectorHelper {\n    constructor() {\n        this._session = new inspector_1.default.Session();\n        this.sourceCodeMap = new Map();\n        this.sourceMapMap = new Map();\n        this.loadedFiles = new Map();\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._session.connect();\n            // wait for debugger to be enabled\n            yield new Promise((resolve) => {\n                this._session.post('Debugger.enable', resolve);\n            });\n        });\n    }\n    storeToFile(filePath, kind) {\n        if (!fs.existsSync(filePath.dirName().toPlatformString())) {\n            PermissionHelper_1.PermissionHelper.mkdirRecursivelyWithUserPermission(filePath.dirName().toPlatformString());\n        }\n        switch (kind) {\n            case 'pretty-json':\n                PermissionHelper_1.PermissionHelper.writeFileWithUserPermission(filePath.toPlatformString(), JSON.stringify(this, null, 2));\n                break;\n            case 'json':\n                PermissionHelper_1.PermissionHelper.writeFileWithUserPermission(filePath.toPlatformString(), JSON.stringify(this));\n                break;\n            default:\n                break;\n        }\n    }\n    static loadFromFile(filePath) {\n        if (!fs.existsSync(filePath.toPlatformString())) {\n            return undefined;\n        }\n        return InspectorHelper.fromJSON(fs.readFileSync(filePath.toPlatformString()).toString());\n    }\n    toJSON() {\n        return {\n            sourceCodeMap: Object.fromEntries(this.sourceCodeMap),\n            loadedFiles: Object.fromEntries(this.loadedFiles)\n        };\n    }\n    static fromJSON(json) {\n        let data;\n        if (typeof json === 'string') {\n            data = JSON.parse(json);\n        }\n        else {\n            data = json;\n        }\n        const result = new InspectorHelper();\n        for (const [key, value] of Object.entries(data.sourceCodeMap)) {\n            result.sourceCodeMap.set(key, value);\n        }\n        for (const [key, value] of Object.entries(data.loadedFiles)) {\n            result.loadedFiles.set(key, value);\n        }\n        return result;\n    }\n    listen() {\n        this._session.on('inspectorNotification', (message) => __awaiter(this, void 0, void 0, function* () {\n            if (message.method === 'Debugger.scriptParsed') {\n                const params = message.params;\n                yield this.sourceCodeFromId(params.scriptId);\n            }\n        }));\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield new Promise((resolve) => {\n                this._session.post('Debugger.disable', resolve);\n            });\n            this._session.disconnect();\n        });\n    }\n    fillSourceMapsFromCPUModel(cpuModel) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const scriptMap = new Map();\n            for (const location of cpuModel.ILocations) {\n                const scriptId = location.callFrame.scriptId.toString();\n                if (scriptMap.has(scriptId)) {\n                    continue;\n                }\n                scriptMap.set(scriptId, location.callFrame.url);\n            }\n            const promises = [];\n            for (const [scriptId, filePath] of scriptMap) {\n                promises.push(this.sourceMapFromId(new UnifiedPath_1.UnifiedPath(filePath), scriptId));\n            }\n            yield Promise.all(promises);\n        });\n    }\n    loadFile(relativePath, filePath) {\n        let source = this.loadedFiles.get(relativePath.toString());\n        if (source !== undefined) {\n            return source;\n        }\n        source = fs.readFileSync(filePath.toPlatformString()).toString();\n        this.loadedFiles.set(relativePath.toString(), source);\n        return source;\n    }\n    parseFile(relativePath, filePath) {\n        const source = this.loadFile(relativePath, filePath);\n        return TypescriptParser_1.TypescriptParser.parseSource(filePath, source);\n    }\n    sourceCodeFromId(scriptId, filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (scriptId === '0') {\n                return null;\n            }\n            let source = this.sourceCodeMap.get(scriptId);\n            if (source !== undefined) {\n                return source;\n            }\n            const result = yield (new Promise((resolve) => {\n                this._session.post('Debugger.getScriptSource', { scriptId }, (err, args) => {\n                    if (err) {\n                        resolve({ source: '', err });\n                    }\n                    else {\n                        resolve({ source: args.scriptSource });\n                    }\n                });\n            }));\n            if (result.err) {\n                LoggerHelper_1.LoggerHelper.error('Error getting script source', result.err, { scriptId, filePath });\n                throw result.err;\n            }\n            source = result.source;\n            this.sourceCodeMap.set(scriptId, source);\n            return source;\n        });\n    }\n    sourceMapFromId(filePath, scriptId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (scriptId === '0') {\n                return null;\n            }\n            let sourceMap = this.sourceMapMap.get(scriptId);\n            if (sourceMap !== undefined) {\n                return sourceMap;\n            }\n            const sourceCode = yield this.sourceCodeFromId(scriptId, filePath);\n            if (sourceCode === null) {\n                throw new Error(`No source map found for scriptId ${filePath.toPlatformString()} ${scriptId}`);\n            }\n            sourceMap = SourceMap_1.SourceMap.fromCompiledJSString(filePath, sourceCode);\n            this.sourceMapMap.set(scriptId, sourceMap);\n            return sourceMap;\n        });\n    }\n}\nexports.InspectorHelper = InspectorHelper;\n//# sourceMappingURL=data:application/json;base64,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"
    },
    "./packages/profiler-core/dist/src/model/ProfilerConfig.js": {
      "sourceCode": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProfilerConfig = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst BaseModel_1 = require(\"./BaseModel\");\nconst config_1 = require(\"../constants/config\");\nconst PathUtils_1 = require(\"../helper/PathUtils\");\nconst UnifiedPath_1 = require(\"../system/UnifiedPath\");\nconst Crypto_1 = require(\"../system/Crypto\");\nconst PermissionHelper_1 = require(\"../helper/PermissionHelper\");\n// Types\nconst types_1 = require(\"../types\");\nclass ProfilerConfig extends BaseModel_1.BaseModel {\n    constructor(filePath, config) {\n        super();\n        this.filePath = filePath;\n        this.extends = config.extends;\n        this.registryOptions = config.registryOptions;\n        this.exportOptions = config.exportOptions;\n        this.projectOptions = config.projectOptions;\n        this.runtimeOptions = config.runtimeOptions;\n    }\n    static getDefaultConfig() {\n        return new ProfilerConfig(new UnifiedPath_1.UnifiedPath(process.cwd()).join(config_1.STATIC_CONFIG_FILENAME), config_1.DEFAULT_PROFILER_CONFIG);\n    }\n    getAnonymizedRuntimeOptions() {\n        if (this.runtimeOptions.sensorInterface) {\n            switch (this.runtimeOptions.sensorInterface.type) {\n                case types_1.SensorInterfaceType.windows:\n                    return Object.assign(Object.assign({}, this.runtimeOptions), { sensorInterface: {\n                            type: types_1.SensorInterfaceType.windows,\n                            options: {\n                                sampleInterval: this.runtimeOptions.sensorInterface.options.sampleInterval,\n                                outputFilePath: '<anonymized>'\n                            }\n                        } });\n                case types_1.SensorInterfaceType.perf:\n                    return Object.assign(Object.assign({}, this.runtimeOptions), { sensorInterface: {\n                            type: types_1.SensorInterfaceType.perf,\n                            options: {\n                                sampleInterval: this.runtimeOptions.sensorInterface.options.sampleInterval,\n                                outputFilePath: '<anonymized>'\n                            }\n                        } });\n                case types_1.SensorInterfaceType.powermetrics:\n                    return Object.assign(Object.assign({}, this.runtimeOptions), { sensorInterface: {\n                            type: types_1.SensorInterfaceType.powermetrics,\n                            options: {\n                                sampleInterval: this.runtimeOptions.sensorInterface.options.sampleInterval,\n                                outputFilePath: '<anonymized>'\n                            }\n                        } });\n            }\n        }\n        return this.runtimeOptions;\n    }\n    getV8CPUSamplingInterval() {\n        return this.runtimeOptions.v8.cpu.sampleInterval;\n    }\n    getRegistryUploadUrl() {\n        return `http://${this.registryOptions.url}/upload`;\n    }\n    uploadEnabled() {\n        var _a, _b;\n        return (((_a = this.registryOptions) === null || _a === void 0 ? void 0 : _a.url) !== undefined) && ((_b = this.registryOptions) === null || _b === void 0 ? void 0 : _b.url) !== '';\n    }\n    getProjectIdentifier() {\n        if (!Crypto_1.Crypto.validateUniqueID(this.projectOptions.identifier)) {\n            throw new Error('ProfilerConfig.getProjectIdentifier: identifier should be an uuid4');\n        }\n        return this.projectOptions.identifier;\n    }\n    getRootDir() {\n        if (PathUtils_1.PathUtils.isAbsolute(this.exportOptions.rootDir)) {\n            return new UnifiedPath_1.UnifiedPath(this.exportOptions.rootDir);\n        }\n        return this.filePath.dirName().join(this.exportOptions.rootDir);\n    }\n    getOutDir() {\n        if (PathUtils_1.PathUtils.isAbsolute(this.exportOptions.outDir)) {\n            return new UnifiedPath_1.UnifiedPath(this.exportOptions.outDir);\n        }\n        return this.filePath.dirName().join(this.exportOptions.outDir);\n    }\n    getOutHistoryDir() {\n        if (PathUtils_1.PathUtils.isAbsolute(this.exportOptions.outHistoryDir)) {\n            return new UnifiedPath_1.UnifiedPath(this.exportOptions.outHistoryDir);\n        }\n        return this.filePath.dirName().join(this.exportOptions.outHistoryDir);\n    }\n    getSensorInterfaceType() {\n        var _a;\n        return (_a = this.runtimeOptions.sensorInterface) === null || _a === void 0 ? void 0 : _a.type;\n    }\n    getSensorInterfaceOptions() {\n        var _a;\n        return (_a = this.runtimeOptions.sensorInterface) === null || _a === void 0 ? void 0 : _a.options;\n    }\n    shouldExportV8Profile() {\n        return this.exportOptions.exportV8Profile;\n    }\n    shouldExportReport() {\n        return this.exportOptions.exportReport;\n    }\n    shouldExportSensorInterfaceData() {\n        return this.exportOptions.exportSensorInterfaceData;\n    }\n    getSeedForMathRandom() {\n        return this.runtimeOptions.seeds['Math.random'];\n    }\n    configAsExtended(pathDiff) {\n        const exportOptions = this.exportOptions;\n        if (exportOptions) {\n            if (exportOptions.outDir && !PathUtils_1.PathUtils.isAbsolute(exportOptions.outDir)) {\n                exportOptions.outDir = pathDiff.join(exportOptions.outDir).toString();\n            }\n            if (exportOptions.outHistoryDir && !PathUtils_1.PathUtils.isAbsolute(exportOptions.outHistoryDir)) {\n                exportOptions.outHistoryDir = pathDiff.join(exportOptions.outHistoryDir).toString();\n            }\n            if (exportOptions.rootDir && !PathUtils_1.PathUtils.isAbsolute(exportOptions.rootDir)) {\n                exportOptions.rootDir = pathDiff.join(exportOptions.rootDir).toString();\n            }\n        }\n        return {\n            exportOptions: exportOptions,\n            projectOptions: this.projectOptions,\n            runtimeOptions: this.runtimeOptions,\n            registryOptions: this.registryOptions\n        };\n    }\n    /**\n     * Fills unspecified values of the config with values of the given config\n     *\n     * example usage:\n     * - every config that gets resolved inherits values of the default config (baseConfig)\n     * \t\tto ensure that unspecified values are filled with the default value. This happens via:\n     * \t\tconfig.implement(baseConfig):\n     *\n     * - if a config contains the extends keyword like this:\n     * \t\t{\n     * \t \t\t\"extends\": \"<config that gets extended>\"\n     * \t\t}\n     * \t\tthe config gets extended via:\n     * \t\tconfig.implement(<config that gets extended>):\n     *\n     * it also adjusts the inherited path values values to make them relative to the config\n     *\n     *\n     * @param config to inherit from\n     */\n    implement(config) {\n        var _a, _b, _c, _d, _e, _f;\n        const pathDiff = this.filePath.dirName().pathTo(config.filePath.dirName());\n        const configToExtend = config.configAsExtended(pathDiff);\n        const newExportOptions = Object.assign(Object.assign({}, configToExtend.exportOptions), this.exportOptions);\n        const newProjectOptions = Object.assign(Object.assign({}, configToExtend.projectOptions), this.projectOptions);\n        const newRuntimeOptions = Object.assign(Object.assign(Object.assign({}, configToExtend.runtimeOptions), this.runtimeOptions), { seeds: Object.assign(Object.assign({}, (((_a = configToExtend === null || configToExtend === void 0 ? void 0 : configToExtend.runtimeOptions) === null || _a === void 0 ? void 0 : _a.seeds) || {})), (((_b = this.runtimeOptions) === null || _b === void 0 ? void 0 : _b.seeds) || {})), v8: {\n                cpu: Object.assign(Object.assign({}, (((_d = (_c = configToExtend.runtimeOptions) === null || _c === void 0 ? void 0 : _c.v8) === null || _d === void 0 ? void 0 : _d.cpu) || {})), (((_f = (_e = this.runtimeOptions) === null || _e === void 0 ? void 0 : _e.v8) === null || _f === void 0 ? void 0 : _f.cpu) || {}))\n            } });\n        const newRegistryOptions = Object.assign(Object.assign({}, configToExtend.registryOptions), this.registryOptions);\n        this.exportOptions = newExportOptions;\n        this.projectOptions = newProjectOptions;\n        this.runtimeOptions = newRuntimeOptions;\n        this.registryOptions = newRegistryOptions;\n    }\n    static fromJSON(json) {\n        let data;\n        if (typeof json === 'string') {\n            data = JSON.parse(json);\n        }\n        else {\n            data = json;\n        }\n        if (data.projectOptions === undefined ||\n            data.projectOptions.identifier === undefined) {\n            throw new Error('ProfilerConfig: the project has no identifier yet');\n        }\n        if (!Crypto_1.Crypto.validateUniqueID(data.projectOptions.identifier)) {\n            throw new Error('ProfilerConfig.getProjectIdentifier: Loaded identifier from the config should be an uuid4');\n        }\n        return new ProfilerConfig(new UnifiedPath_1.UnifiedPath(''), {\n            extends: data.extends,\n            exportOptions: data.exportOptions,\n            projectOptions: data.projectOptions,\n            runtimeOptions: data.runtimeOptions,\n            registryOptions: data.registryOptions\n        });\n    }\n    toJSON() {\n        return ({\n            extends: this.extends,\n            exportOptions: this.exportOptions,\n            projectOptions: this.projectOptions,\n            runtimeOptions: this.runtimeOptions,\n            registryOptions: this.registryOptions\n        });\n    }\n    storeToFile(filePath) {\n        if (!fs.existsSync(filePath.dirName().toPlatformString())) {\n            PermissionHelper_1.PermissionHelper.mkdirRecursivelyWithUserPermission(filePath.dirName().toPlatformString());\n        }\n        PermissionHelper_1.PermissionHelper.writeFileWithUserPermission(filePath.toPlatformString(), JSON.stringify(this, null, 2));\n    }\n    // loads a config from a given file path and extends it\n    // this method is NOT used to ensure load a valid (complete) config, use resolveFromFile to achieve that\n    static loadFromFile(filePath) {\n        if (!fs.existsSync(filePath.toPlatformString())) {\n            return undefined;\n        }\n        const loadedConfig = ProfilerConfig.fromJSON(fs.readFileSync(filePath.toPlatformString()).toString());\n        loadedConfig.filePath = filePath;\n        if (loadedConfig.extends) {\n            const configToExtendFilePath = filePath.dirName().join(loadedConfig.extends);\n            const configToExtend = ProfilerConfig.loadFromFile(configToExtendFilePath);\n            if (configToExtend) {\n                loadedConfig.implement(configToExtend);\n                return loadedConfig;\n            }\n        }\n        return loadedConfig;\n    }\n    // loads a config from a given file path and fills all non defined values with the resp. default values\n    static resolveFromFile(filePath) {\n        const baseConfig = ProfilerConfig.getDefaultConfig();\n        if (!filePath) {\n            return baseConfig;\n        }\n        const config = this.loadFromFile(filePath);\n        if (config) {\n            baseConfig.filePath = config.filePath;\n            config.implement(baseConfig);\n            return config;\n        }\n        return baseConfig;\n    }\n    static autoResolveFromPath(startDir) {\n        // Searches from the given path upwards until it finds the config file\n        const configFilePath = PathUtils_1.PathUtils.findUp(config_1.STATIC_CONFIG_FILENAME, startDir.toPlatformString());\n        if (!configFilePath) {\n            return ProfilerConfig.resolveFromFile(undefined);\n        }\n        return ProfilerConfig.resolveFromFile(new UnifiedPath_1.UnifiedPath(configFilePath));\n    }\n    static autoResolve() {\n        // Searches from the processes execution path upwards until it finds the config file\n        return this.autoResolveFromPath(new UnifiedPath_1.UnifiedPath(process.cwd()));\n    }\n}\nexports.ProfilerConfig = ProfilerConfig;\n//# sourceMappingURL=data:application/json;base64,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"
    },
    "./packages/profiler-core/dist/src/helper/PathUtils.js": {
      "sourceCode": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathUtils = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst path = __importStar(require(\"path\"));\nconst pathCollator = new Intl.Collator(undefined, {\n    numeric: true,\n    sensitivity: 'base'\n});\nclass PathUtils {\n    static sortFilePathArray(filePathArray) {\n        filePathArray.sort(pathCollator.compare);\n    }\n    static getPathRelativeTo(from, to) {\n        return path.relative(from, to);\n    }\n    static makeAbsolute(startDir, relativeFilePath) {\n        if (PathUtils.isAbsolute(relativeFilePath)) {\n            return relativeFilePath;\n        }\n        return path.normalize(path.join(startDir, relativeFilePath));\n    }\n    static isAbsolute(pathString) {\n        return path.isAbsolute(pathString) || /^(?:[a-zA-Z]:)?\\\\?\\\\(?:[^\\\\/:*?\"<>|\\r\\n]+\\\\)*[^\\\\/:*?\"<>|\\r\\n]*$/.test(pathString);\n    }\n    static unifyPath(pathString) {\n        if (pathString === '' || pathString === '.' || pathString === './') {\n            return './';\n        }\n        if (pathString === '/') {\n            return '/';\n        }\n        if (pathString === '../') {\n            return '../';\n        }\n        const isAbsolute = PathUtils.isAbsolute(pathString);\n        pathString = pathString.replace(/\\\\/g, '/');\n        pathString = pathString.replace(/\\/+$/g, '');\n        if (!isAbsolute) {\n            if (pathString.slice(0, 2) !== './' && pathString.slice(0, 3) !== '../') {\n                return './' + pathString;\n            }\n        }\n        return pathString;\n    }\n    static findUp(filename, startDir) {\n        const { root } = path.parse(startDir);\n        let tmpDir = startDir;\n        while (tmpDir !== root) {\n            let list;\n            try {\n                list = fs.readdirSync(tmpDir);\n            }\n            catch (e) {\n                break;\n            }\n            if (list.includes(filename) && fs.statSync(path.join(tmpDir, filename)).isFile()) {\n                // found\n                return path.join(tmpDir, filename);\n            }\n            else {\n                tmpDir = path.normalize(path.join(tmpDir, '..'));\n            }\n        }\n        return undefined;\n    }\n}\nexports.PathUtils = PathUtils;\n//# sourceMappingURL=data:application/json;base64,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"
    },
    "./packages/profiler-core/dist/src/system/UnifiedPath.js": {
      "sourceCode": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnifiedPath = void 0;\nconst path = __importStar(require(\"path\"));\nconst PathUtils_1 = require(\"../helper/PathUtils\");\nclass UnifiedPath {\n    constructor(...args) {\n        if (args.length === 0 || args.length === 1) {\n            this._unifiedPath = PathUtils_1.PathUtils.unifyPath(args[0] || '');\n        }\n        else {\n            this._unifiedPath = PathUtils_1.PathUtils.unifyPath(args.join('/'));\n        }\n    }\n    static fromPathParts(parts) {\n        return new UnifiedPath(parts[0]).join(...parts.slice(1));\n    }\n    copy() {\n        return new UnifiedPath(this._unifiedPath);\n    }\n    /**\n     * String representation of a UnifiedPath\n     *\n     * @returns\n     */\n    toString() {\n        return this._unifiedPath;\n    }\n    /**\n     * Returns UnifiedPath as a string for the current platform\n     *\n     * @returns\n     */\n    toPlatformString() {\n        return this._unifiedPath.split('/').join(path.sep);\n    }\n    /**\n     * JSON representation of a UnifiedPath\n     *\n     * @returns\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Returns the directory name of a path\n     *\n     * @returns\n     */\n    dirName() {\n        return new UnifiedPath(path.dirname(this.toString()));\n    }\n    /**\n     * Returns the basename name of a path\n     *\n     * @returns The basename of the path (path/to/index.coffee.md -> index.coffee.md)\n     */\n    basename() {\n        return path.basename(this.toString());\n    }\n    /**\n     * Returns the extension of a path\n     *\n     * @returns The extension of the path (path/to/index.coffee.md -> .md)\n     */\n    extname() {\n        return path.extname(this.basename());\n    }\n    isRelative() {\n        return this._unifiedPath === '' || (this._unifiedPath[0] !== '/' && !this.isAbsoluteWindowsPath());\n    }\n    isAbsoluteWindowsPath() {\n        return /^[A-Za-z]:/.test(this._unifiedPath);\n    }\n    /**\n     * Gives the relative UnifiedPath that points from this to the other path\n     *\n     * @param other\n     * @returns\n     */\n    pathTo(other) {\n        if (typeof other === 'string') {\n            other = new UnifiedPath(other);\n        }\n        return new UnifiedPath(PathUtils_1.PathUtils.getPathRelativeTo(this.toString(), other.toString()));\n    }\n    /**\n     * Splits the path into an array of it's components\n     *\n     * @returns\n     */\n    split() {\n        if (!this._parts) {\n            const parts = this._unifiedPath.split('/');\n            if (parts[0] === '' && parts.length > 1) {\n                parts[0] = '/';\n            }\n            if (parts[0] === '.' && parts.length > 1) {\n                parts.splice(0, 1);\n            }\n            this._parts = parts;\n        }\n        return this._parts;\n    }\n    join(...args) {\n        if (args.length === 0) {\n            return new UnifiedPath(this._unifiedPath);\n        }\n        const parts = [];\n        for (const part of args) {\n            if (typeof part === 'string') {\n                parts.push(new UnifiedPath(part).toString());\n            }\n            else {\n                parts.push(part.toString());\n            }\n        }\n        return new UnifiedPath(path.posix.join(this._unifiedPath, ...parts));\n    }\n    /**\n     * Returns the unified path from the root of the path to the first occurrence of the given directory\n     * and the remainder\n     *\n     * /path/to/node_modules/node_module_name/file -> /path/to/node_modules\n     *\n     * @param dirName\n     * @returns\n     */\n    pathUntilSubDir(dirName) {\n        const pathParts = this.split();\n        const firstMatch = pathParts.indexOf(dirName);\n        if (firstMatch !== -1) {\n            return {\n                match: new UnifiedPath(path.posix.join(...pathParts.slice(0, firstMatch + 1))),\n                remainder: new UnifiedPath(path.posix.join(...pathParts.slice(firstMatch + 1))),\n            };\n        }\n        return undefined;\n    }\n}\nexports.UnifiedPath = UnifiedPath;\n//# sourceMappingURL=data:application/json;base64,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"
    },
    "./packages/profiler/examples/example001.ts": {
      "sourceCode": "import { Profiler } from '../src/index'\n\nconst profile = new Profiler('example001')\n\nfunction logMessage(message: string) {\n\tconsole.log(message)\n}\n\nfunction load() {\n\tfor (let i = 0; i < 100000; i++) {\n\t\tlogMessage(i.toString())\n\t}\n}\n\nasync function main() {\n\tconst title = 'latest'\n\tawait profile.start(title)\n\n\tload()\n\n\tlogMessage('outside of main')\n\n\tsetTimeout(() => {\n\t\tconsole.log('finish')\n\t}, 1000)\n\tawait profile.finish(title)\n}\n\nmain()"
    },
    "./packages/profiler-core/dist/src/helper/PerformanceHelper.js": {
      "sourceCode": "\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PerformanceHelper = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst TimeHelper_1 = require(\"./TimeHelper\");\nconst PermissionHelper_1 = require(\"./PermissionHelper\");\nconst ENABLE_PERFORMANCE_TRACKING = process.env.OAKLEAN_ENABLE_PERFORMANCE_TRACKING !== undefined;\nclass PerformanceHelper {\n    constructor() {\n        this._measures = new Map();\n        this._firstMeasure = BigInt(0);\n        this._lastMeasure = BigInt(0);\n    }\n    static loadFromFile(path) {\n        if (fs_1.default.existsSync(path.toPlatformString())) {\n            const jsonString = fs_1.default.readFileSync(path.toPlatformString(), 'utf8').toString();\n            return JSON.parse(jsonString);\n        }\n        return { measures: {} };\n    }\n    static storeToFile(path, data) {\n        const dir = path.dirName();\n        if (!fs_1.default.existsSync(dir.toPlatformString())) {\n            PermissionHelper_1.PermissionHelper.mkdirRecursivelyWithUserPermission(dir);\n        }\n        fs_1.default.writeFileSync(path.toPlatformString(), JSON.stringify(data, null, 2));\n    }\n    exportAndSum(path) {\n        if (!ENABLE_PERFORMANCE_TRACKING) {\n            return;\n        }\n        const report = PerformanceHelper.loadFromFile(path);\n        for (const [name, measure] of this._measures) {\n            if (measure.end) {\n                const diff = Number(measure.end - measure.start);\n                report.measures[name] = (report.measures[name] || 0) + diff;\n            }\n        }\n        PerformanceHelper.storeToFile(path, report);\n    }\n    start(name) {\n        if (!ENABLE_PERFORMANCE_TRACKING) {\n            return;\n        }\n        const time = TimeHelper_1.TimeHelper.getCurrentHighResolutionTime();\n        if (!this._firstMeasure) {\n            this._firstMeasure = time;\n        }\n        this._measures.set(name, {\n            start: time,\n            end: null\n        });\n    }\n    stop(name) {\n        if (!ENABLE_PERFORMANCE_TRACKING) {\n            return;\n        }\n        const time = TimeHelper_1.TimeHelper.getCurrentHighResolutionTime();\n        this._lastMeasure = time;\n        const measure = this._measures.get(name);\n        if (measure) {\n            measure.end = time;\n        }\n    }\n    static printAccumulatedReport(path) {\n        const loadedReport = PerformanceHelper.loadFromFile(path);\n        console.log('Accumulated performance report:');\n        const report = {};\n        for (const name of Object.keys(loadedReport.measures)) {\n            report[name] = {\n                'Duration': `${(loadedReport.measures[name] / 1e9).toFixed(3)} s`\n            };\n        }\n        console.table(report, ['Duration']);\n    }\n    printReport(title) {\n        if (!ENABLE_PERFORMANCE_TRACKING) {\n            return;\n        }\n        const report = {};\n        const total = Number(this._lastMeasure - this._firstMeasure);\n        for (const [name, measure] of this._measures) {\n            if (measure.end) {\n                const diff = Number(measure.end - measure.start);\n                report[name] = {\n                    'Duration': `${(diff / 1e9).toFixed(3)} s`,\n                    'Percentage': `${((diff / total) * 100).toFixed(2)} %`\n                };\n            }\n            else {\n                report[name] = {\n                    'Duration': 'N/A',\n                    'Percentage': 'N/A'\n                };\n            }\n        }\n        console.log(`Performance report (${title}):`, (total / 1e9).toFixed(3), 's');\n        console.table(report, ['Duration', 'Percentage']);\n    }\n}\nexports.PerformanceHelper = PerformanceHelper;\n//# sourceMappingURL=data:application/json;base64,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"
    }
  },
  "nodeModules": {}
}